<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Canvas</name>
    </assembly>
    <members>
        <member name="T:System.Diagnostics.Contracts.PureAttribute">
            <summary>Indicates that a type or method is pure, that is, it does not make any visible state changes.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>
            Specifies that the method will not return if the associated Boolean parameter is passed the specified value.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute"/> class
            with the specified parameter value.
            </summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable
            by diagnostics if the argument to the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>
            Gets a value indicating whether the condition parameter value
            is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.op_Implicit(System.Boolean)~System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of DoesNotReturnIfAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)"/>.
            </summary>
            <param name="parameterValue">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of DoesNotReturnIfAttribute by passing the parameter <paramref name="parameterValue"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)"/>.
            </returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>
            Specifies that an output will not be null even if the corresponding type allows it.
            Specifies that an input argument was not null when the call returns.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>,
            the parameter may be null even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute"/> class
            with the specified return value condition.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition
            is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.op_Implicit(System.Boolean)~System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of MaybeNullWhenAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)"/>.
            </summary>
            <param name="returnValue">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of MaybeNullWhenAttribute by passing the parameter <paramref name="returnValue"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)"/>.
            </returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>,
            the parameter will not be null even if the corresponding type allows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute"/>
            class with the specified return value condition.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.op_Implicit(System.Boolean)~System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of NotNullWhenAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)"/>.
            </summary>
            <param name="returnValue">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of NotNullWhenAttribute by passing the parameter <paramref name="returnValue"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)"/>.
            </returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute"/> class
            with the associated parameter name.
            </summary>
            <param name="parameterName">
            The associated parameter name.
            The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.op_Implicit(System.String)~System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of NotNullIfNotNullAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)"/>.
            </summary>
            <param name="parameterName">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of NotNullIfNotNullAttribute by passing the parameter <paramref name="parameterName"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>
            Specifies that the method or property will ensure that the
            listed field and property members have not-null values.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute"/>
            class with a field or property member.
            </summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute"/> class
            with the list of field and property members.
            </summary>
            <param name="members">
            The list of field and AttributeTargets.Property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or AttributeTargets.Property member names.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.op_Implicit(System.String)~System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of MemberNotNullAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)"/>.
            </summary>
            <param name="member">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of MemberNotNullAttribute by passing the parameter <paramref name="member"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.op_Implicit(System.String[])~System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of MemberNotNullAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])"/>.
            </summary>
            <param name="members">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of MemberNotNullAttribute by passing the parameter <paramref name="members"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])"/>.
            </returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property members
            have not-null values when returning with the specified return value condition.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute"/> class
            with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute"/> class
            with the specified return value condition and list of field and property members.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition
            is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.op_Implicit(System.ValueTuple{System.Boolean,System.String})~System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of MemberNotNullWhenAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of MemberNotNullWhenAttribute by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)"/>.
            </returns>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.op_Implicit(System.ValueTuple{System.Boolean,System.String[]})~System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of MemberNotNullWhenAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of MemberNotNullWhenAttribute by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])"/>.
            </returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type,
            and callers do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>Specifies the syntax used in a string.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.CompositeFormat">
            <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateOnlyFormat">
            <summary>The syntax identifier for strings containing date format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateTimeFormat">
            <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.EnumFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Enum"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.GuidFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Guid"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Json">
            <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.NumericFormat">
            <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex">
            <summary>The syntax identifier for strings containing regular expressions.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeOnlyFormat">
            <summary>The syntax identifier for strings containing time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeSpanFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.TimeSpan"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Uri">
            <summary>The syntax identifier for strings containing URIs.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Xml">
            <summary>The syntax identifier for strings containing XML.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> class
            with the identifier of the syntax used.
            </summary>
            <param name="syntax">The syntax identifier.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> class
            with the identifier of the syntax used.
            </summary>
            <param name="syntax">The syntax identifier.</param>
            <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Syntax">
            <summary>Gets the identifier of the syntax used.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Arguments">
            <summary>Gets the optional arguments associated with the specific syntax employed.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.op_Implicit(System.String)~System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of StringSyntaxAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)"/>.
            </summary>
            <param name="syntax">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of StringSyntaxAttribute by passing the parameter <paramref name="syntax"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.op_Implicit(System.ValueTuple{System.String,System.Object[]})~System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of StringSyntaxAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of StringSyntaxAttribute by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])"/>.
            </returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>Used to indicate a byref escapes and is not scoped.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute">
            <summary>Indicates that an API is experimental and it may change in the future.</summary>
            <remarks><para>
            This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
            feature is used. Authors can use this attribute to ship preview features in their assemblies.
            </para></remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute"/> class, specifying the
            ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <param name="diagnosticId">
            The ID that the compiler will use when reporting a use of the API the attribute applies to.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.DiagnosticId">
            <summary>
            Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <value>The unique diagnostic ID.</value>
            <remarks><para>
            The diagnostic ID is shown in build output for warnings and errors.
            This property represents the unique ID that can be used to suppress the warnings or errors, if needed.
            </para></remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.UrlFormat">
            <summary>
            Gets or sets the URL for corresponding documentation. The API accepts a format string
            instead of an actual URL, creating a generic URL that includes the diagnostic ID.
            </summary>
            <value>The format string that represents a URL to corresponding documentation.</value>
            <remarks><para>
            An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.
            </para></remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.op_Implicit(System.String)~System.Diagnostics.CodeAnalysis.ExperimentalAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of ExperimentalAttribute by using the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)"/>.
            </summary>
            <param name="diagnosticId">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of ExperimentalAttribute by passing the parameter <paramref name="diagnosticId"/> to the constructor
            <see cref="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="T:System.Diagnostics.UnreachableException">
            <summary>Exception thrown when the program executes an instruction that was thought to be unreachable.</summary>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with a specified error message
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.op_Implicit(System.String)~System.Diagnostics.UnreachableException">
            <summary>
            Implicitly converts the parameter by creating the new instance of UnreachableException by using the constructor
            <see cref="M:System.Diagnostics.UnreachableException.#ctor(System.String)"/>.
            </summary>
            <param name="message">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of UnreachableException by passing the parameter <paramref name="message"/> to the constructor
            <see cref="M:System.Diagnostics.UnreachableException.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.op_Implicit(System.ValueTuple{System.String,System.Exception})~System.Diagnostics.UnreachableException">
            <summary>
            Implicitly converts the parameter by creating the new instance of UnreachableException by using the constructor
            <see cref="M:System.Diagnostics.UnreachableException.#ctor(System.String,System.Exception)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of UnreachableException by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:System.Diagnostics.UnreachableException.#ctor(System.String,System.Exception)"/>.
            </returns>
        </member>
        <member name="T:System.Linq.EnumerableAggregate">
            <summary>The backport of the AggregateBy method for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:System.Linq.EnumerableAggregate.AggregateBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},``2,System.Func{``2,``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Performs a specified accumulator function over a sequence.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
            <param name="source">The sequence to accumulate over.</param>
            <param name="keySelector">The key selector function.</param>
            <param name="seed">The initial accumulator value.</param>
            <param name="func">The accumulator function.</param>
            <param name="keyComparer">The key comparer.</param>
            <returns>The accumulated value.</returns>
        </member>
        <member name="M:System.Linq.EnumerableAggregate.AggregateBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,``2},System.Func{``2,``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Performs a specified accumulator function over a sequence.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
            <param name="source">The sequence to accumulate over.</param>
            <param name="keySelector">The key selector function.</param>
            <param name="seedSelector">The seed selector function.</param>
            <param name="func">The accumulator function.</param>
            <param name="keyComparer">The key comparer.</param>
            <returns>The accumulated value.</returns>
        </member>
        <member name="T:System.Linq.EnumerableCount">
            <summary>The backport of the CountBy method for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:System.Linq.EnumerableCount.CountBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Performs a count by operation.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <param name="source">The sequence to count by.</param>
            <param name="keySelector">The key selector function.</param>
            <param name="keyComparer">The key comparer.</param>
            <returns>The count by operation.</returns>
        </member>
        <member name="T:System.Linq.EnumerableIndex">
            <summary>The backport of the Index method for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:System.Linq.EnumerableIndex.Index``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns an enumerable that incorporates the element's index into a tuple.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">The source enumerable providing the elements.</param>
            <returns>The enumerable that incorporates the element's index into a tuple.</returns>
        </member>
        <member name="T:System.Linq.EnumerableChunk">
            <summary>The backport of the Chunk method for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:System.Linq.EnumerableChunk.Chunk``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Splits the elements of a sequence into chunks of size at most <paramref name="size"/>.</summary>
            <remarks><para>
            Each chunk except the last one will be of size <paramref name="size"/>.
            The last chunk will contain the remaining elements and may be of smaller size.
            </para></remarks>
            <typeparam name="TSource">The type of elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to chunk.</param>
            <param name="size">The maximum size of each chunk.</param>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the elements the
            input sequence split into chunks of size <paramref name="size"/>.
            </returns>
        </member>
        <member name="T:System.Linq.EnumerableMinMax">
            <summary>The backport of the MinBy and MaxBy methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:System.Linq.EnumerableMinMax.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the minimum value in a generic sequence according to a specified key selector function.
            </summary>
            <remarks><para>
            If <typeparamref name="TKey"/> is a reference type and the source sequence is empty or contains
            only values that are <see langword="null"/>, this method returns <see langword="null"/>.
            </para></remarks>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <typeparam name="TKey">The type of key to compare elements by.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>The value with the minimum key in the sequence.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentException">
            No key extracted from <paramref name="source"/> implements the
            <see cref="T:System.IComparable"/> or <see cref="T:System.IComparable`1"/> interface.
            </exception>
        </member>
        <member name="M:System.Linq.EnumerableMinMax.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Returns the minimum value in a generic sequence according to a specified key selector function.
            </summary>
            <remarks><para>
            If <typeparamref name="TKey"/> is a reference type and the source sequence is empty or contains
            only values that are <see langword="null" />, this method returns <see langword="null"/>.
            </para></remarks>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <typeparam name="TKey">The type of key to compare elements by.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
            <returns>The value with the minimum key in the sequence.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentException">
            No key extracted from <paramref name="source" /> implements the <see cref="T:System.IComparable"/>
            or <see cref="T:System.IComparable`1"/> interface.
            </exception>
        </member>
        <member name="M:System.Linq.EnumerableMinMax.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the maximum value in a generic sequence according to a specified key selector function.
            </summary>
            <remarks><para>
            If <typeparamref name="TKey"/> is a reference type and the source sequence is empty or contains
            only values that are <see langword="null"/>, this method returns <see langword="null"/>.
            </para></remarks>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <typeparam name="TKey">The type of key to compare elements by.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <exception cref="T:System.ArgumentException">
            No key extracted from <paramref name="source" /> implements the <see cref="T:System.IComparable"/>
            or <see cref="T:System.IComparable`1"/> interface.
            </exception>
            <returns>The value with the maximum key in the sequence.</returns>
        </member>
        <member name="M:System.Linq.EnumerableMinMax.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Returns the maximum value in a generic sequence according to a specified key selector function.
            </summary>
            <remarks><para>
            If <typeparamref name="TKey"/> is a reference type and the source sequence is empty or contains
            only values that are <see langword="null"/>, this method returns <see langword="null"/>.
            </para></remarks>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <typeparam name="TKey">The type of key to compare elements by.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
            <exception cref="T:System.ArgumentException">
            No key extracted from <paramref name="source"/> implements the <see cref="T:System.IComparable"/>
            or <see cref="T:System.IComparable`1"/> interface.
            </exception>
            <returns>The value with the maximum key in the sequence.</returns>
        </member>
        <member name="T:System.Linq.EnumerableOrder">
            <summary>The backport of the Order and OrderDescending methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:System.Linq.EnumerableOrder.Order``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Sorts the elements of a sequence in ascending order.</summary>
            <typeparam name="T">The type of elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values to order.</param>
            <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1"/> whose elements are sorted.</returns>
        </member>
        <member name="M:System.Linq.EnumerableOrder.Order``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>Sorts the elements of a sequence in ascending order.</summary>
            <typeparam name="T">The type of elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values to order.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare keys.</param>
            <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1"/> whose elements are sorted.</returns>
        </member>
        <member name="M:System.Linq.EnumerableOrder.OrderDescending``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Sorts the elements of a sequence in descending order.</summary>
            <typeparam name="T">The type of elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values to order.</param>
            <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1"/> whose elements are sorted.</returns>
        </member>
        <member name="M:System.Linq.EnumerableOrder.OrderDescending``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>Sorts the elements of a sequence in descending order.</summary>
            <typeparam name="T">The type of elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values to order.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare keys.</param>
            <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1"/> whose elements are sorted.</returns>
        </member>
        <member name="T:System.Linq.EnumerableTryGetNonEnumeratedCount">
            <summary>The backport of the TryGetNonEnumeratedCount method for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:System.Linq.EnumerableTryGetNonEnumeratedCount.TryGetNonEnumeratedCount``1(System.Collections.Generic.IEnumerable{``0},System.Int32@)">
            <summary>Attempts to determine the number of elements in a sequence without forcing an enumeration.</summary>
            <remarks><para>
            The method performs a series of type tests, identifying common subtypes whose count
            can be determined without enumerating; this includes <see cref="T:System.Collections.Generic.ICollection`1"/>,
            <see cref="T:System.Collections.ICollection"/> as well as internal types used in the LINQ implementation.
            </para><para>
            The method is typically a constant-time operation, but ultimately this depends on the complexity
            characteristics of the underlying collection implementation.
            </para></remarks>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <param name="count">
            When this method returns, contains the number of elements in <paramref name="source"/>,
            or 0 if the count couldn't be determined without enumeration.
            </param>
            <returns>A sequence of tuples with elements taken from the first and second sequence, in that order.</returns>
        </member>
        <member name="T:System.Linq.EnumerableUnion">
            <summary>
            The backport of the DistinctBy, ExceptBy, UnionBy, and IntersectBy methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:System.Linq.EnumerableUnion.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Returns distinct elements from a sequence according to a specified key selector function.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <typeparam name="TKey">The type of key to distinguish elements by.</typeparam>
            <param name="source">The sequence to remove duplicate elements from.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains distinct elements from the source sequence.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <remarks>
            <para>This method is implemented by using deferred execution. The immediate return value is an object that stores all the information that is required to perform the action. The query represented by this method is not executed until the object is enumerated either by calling its `GetEnumerator` method directly or by using `foreach` in Visual C# or `For Each` in Visual Basic.</para>
            <para>The <see cref="M:System.Linq.EnumerableUnion.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" /> method returns an unordered sequence that contains no duplicate values. The default equality comparer, <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />, is used to compare values.</para>
            </remarks>
        </member>
        <member name="M:System.Linq.EnumerableUnion.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Returns distinct elements from a sequence according to a specified key selector function.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <typeparam name="TKey">The type of key to distinguish elements by.</typeparam>
            <param name="source">The sequence to remove duplicate elements from.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains distinct elements from the source sequence.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is <see langword="null" />.</exception>
            <remarks>
            <para>This method is implemented by using deferred execution. The immediate return value is an object that stores all the information that is required to perform the action. The query represented by this method is not executed until the object is enumerated either by calling its `GetEnumerator` method directly or by using `foreach` in Visual C# or `For Each` in Visual Basic.</para>
            <para>The <see cref="M:System.Linq.EnumerableUnion.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" /> method returns an unordered sequence that contains no duplicate values. If <paramref name="comparer" /> is <see langword="null" />, the default equality comparer, <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />, is used to compare values.</para>
            </remarks>
        </member>
        <member name="M:System.Linq.EnumerableUnion.ExceptBy``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1})">
            <summary>Produces the set difference of two sequences according to a specified key selector function.</summary>
            <typeparam name="TSource">The type of the elements of the input sequence.</typeparam>
            <typeparam name="TKey">The type of key to identify elements by.</typeparam>
            <param name="first">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose keys that are
            not also in <paramref name="second"/> will be returned.
            </param>
            <param name="second">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose keys that also occur in the first
            sequence will cause those elements to be removed from the returned sequence.
            </param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
        </member>
        <member name="M:System.Linq.EnumerableUnion.ExceptBy``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Produces the set difference of two sequences according to a specified key selector function.</summary>
            <typeparam name="TSource">The type of the elements of the input sequence.</typeparam>
            <typeparam name="TKey">The type of key to identify elements by.</typeparam>
            <param name="first">
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose keys that are
            not also in <paramref name="second"/> will be returned.
            </param>
            <param name="second">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose keys that also occur in the first
            sequence will cause those elements to be removed from the returned sequence.
            </param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.</param>
            <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
        </member>
        <member name="M:System.Linq.EnumerableUnion.UnionBy``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Produces the set union of two sequences according to a specified key selector function.</summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <typeparam name="TKey">The type of key to identify elements by.</typeparam>
            <param name="first">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements form the first set for the union.
            </param>
            <param name="second">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements form the second set for the union.
            </param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the elements from both input sequences, excluding duplicates.
            </returns>
        </member>
        <member name="M:System.Linq.EnumerableUnion.UnionBy``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Produces the set union of two sequences according to a specified key selector function.</summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <typeparam name="TKey">The type of key to identify elements by.</typeparam>
            <param name="first">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements form the first set for the union.
            </param>
            <param name="second">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements form the second set for the union.
            </param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.</param>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the elements from both input sequences, excluding duplicates.
            </returns>
        </member>
        <member name="M:System.Linq.EnumerableUnion.IntersectBy``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1})">
            <summary>
            Produces the set intersection of two sequences according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <typeparam name="TKey">The type of key to identify elements by.</typeparam>
            <param name="first">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements that
            also appear in <paramref name="second"/> will be returned.
            </param>
            <param name="second">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements that also appear in the first sequence will be returned.
            </param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>A sequence that contains the elements that form the set intersection of two sequences.</returns>
        </member>
        <member name="M:System.Linq.EnumerableUnion.IntersectBy``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Produces the set intersection of two sequences according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <typeparam name="TKey">The type of key to identify elements by.</typeparam>
            <param name="first">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements that
            also appear in <paramref name="second"/> will be returned.
            </param>
            <param name="second">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements that also appear in the first sequence will be returned.
            </param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.</param>
            <returns>A sequence that contains the elements that form the set intersection of two sequences.</returns>
        </member>
        <member name="T:System.Linq.EnumerableZip">
            <summary>The backport of Zip methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:System.Linq.EnumerableZip.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Produces a sequence of tuples with elements from the two specified sequences.
            </summary>
            <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
            <param name="first">The first sequence to merge.</param>
            <param name="second">The second sequence to merge.</param>
            <returns>A sequence of tuples with elements taken from the first and second sequence, in that order.</returns>
        </member>
        <member name="M:System.Linq.EnumerableZip.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>
            Produces a sequence of tuples with elements from the three specified sequences.
            </summary>
            <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
            <typeparam name="TThird">The type of the elements of the third input sequence.</typeparam>
            <param name="first">The first sequence to merge.</param>
            <param name="second">The second sequence to merge.</param>
            <param name="third">The third sequence to merge.</param>
            <returns>
            A sequence of tuples with elements taken from the first, second, and third sequences, in that order.
            </returns>
        </member>
        <member name="M:System.Linq.EnumerableZip.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Applies a specified function to the corresponding elements of two sequences,
            producing a sequence of the results.
            </summary>
            <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
            <typeparam name="TResult">The type of the elements of the result sequence.</typeparam>
            <param name="first">The first sequence to merge.</param>
            <param name="second">The second sequence to merge.</param>
            <param name="resultSelector">A function that specifies how to merge the elements from the two sequences.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains merged elements of two input sequences.</returns>
        </member>
        <member name="T:System.Collections.Generic.CollectionExtensions">
            <summary>Provides extension methods for generic collections.</summary>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <inheritdoc cref="M:System.Collections.Generic.CollectionExtensions.GetValueOrDefault``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0)"/>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <inheritdoc cref="M:System.Collections.Generic.CollectionExtensions.GetValueOrDefault``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0,``1)"/>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.GetValueOrDefault``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0)">
            <summary>
            Tries to get the value associated with the specified
            <paramref name="key"/> in the <paramref name="dictionary"/>.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">
            A dictionary with keys of type <typeparamref name="TKey"/> and the values of type <typeparamref name="TValue"/>.
            </param>
            <param name="key">The key of the value to get.</param>
            <returns>
            A <typeparamref name="TValue"/> instance. When the method is successful, the returned
            object is the value associated with the specified <paramref name="key"/>.
            When the method fails, it returns the <see langword="default"/> value for <typeparamref name="TValue"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.GetValueOrDefault``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0,``1)">
            <summary>
            Tries to get the value associated with the specified
            <paramref name="key"/> in the <paramref name="dictionary"/>.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">
            A dictionary with keys of type <typeparamref name="TKey"/> and the values of type <typeparamref name="TValue"/>.
            </param>
            <param name="key">The key of the value to get.</param>
            <param name="defaultValue">
            The default value to return when the <paramref name="dictionary"/>
            cannot find a value associated with the specified <paramref name="key"/>.
            </param>
            <returns>
            A <typeparamref name="TValue"/> instance. When the method is successful, the returned
            object is the value associated with the specified <paramref name="key"/>.
            When the method fails, it returns <paramref name="defaultValue"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.TryAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Tries to add the specified <paramref name="key"/> and <paramref name="value"/> to the <paramref name="dictionary"/>.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">
            A dictionary with keys of type <typeparamref name="TKey"/> and the values of type <typeparamref name="TValue"/>.
            </param>
            <param name="key">The key of the value to add.</param>
            <param name="value">The value to add.</param>
            <returns>
            <see langword="true"/>when the <paramref name="key"/> and <paramref name="value"/> are successfully
            added to the <paramref name="dictionary"/>; <see langword="false"/> when the <paramref name="dictionary"/>
            already contains the specified <paramref name="key"/>, in which case nothing gets added.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.Remove``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1@)">
            <summary>
            Tries to remove the value with the specified <paramref name="key"/> from the <paramref name="dictionary"/>.
            </summary>
            <typeparam name="TKey">The type of the keys in the <paramref name="dictionary"/>.</typeparam>
            <typeparam name="TValue">The type of the values in the <paramref name="dictionary"/>.</typeparam>
            <param name="dictionary">
            A dictionary with keys of type <typeparamref name="TKey"/> and the values of type <typeparamref name="TValue"/>.
            </param>
            <param name="key">The key of the value to remove.</param>
            <param name="value">
            When this method returns <see langword="true"/>, the removed value; when this method returns
            <see langword="false"/>, the <see langword="default"/> value for <typeparamref name="TValue"/>.
            </param>
            <returns>
            <see langword="true"/> when a value is found in the <paramref name="dictionary"/> with the specified
            <paramref name="key"/>; <see langword="false"/> when the <paramref name="dictionary"/>
            cannot find a value associated with the specified <paramref name="key"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.AsReadOnly``1(System.Collections.Generic.IList{``0})">
            <summary>Returns a read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> wrapper for the specified list.</summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
            <param name="list">The list to wrap.</param>
            <returns>An object that acts as a read-only wrapper around the current <see cref="T:System.Collections.Generic.IList`1"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.AddRange``1(System.Collections.Generic.List{``0},System.ReadOnlySpan{``0})">
            <summary>Adds the elements of the specified span to the end of the <see cref="T:System.Collections.Generic.List`1"/>.</summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="list">The list to which the elements should be added.</param>
            <param name="source">The span whose elements should be added to the end of the <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="list"/> is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.InsertRange``1(System.Collections.Generic.List{``0},System.Int32,System.ReadOnlySpan{``0})">
            <summary>Inserts the elements of a span into the <see cref="T:System.Collections.Generic.List`1"/> at the specified index.</summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="list">The list into which the elements should be inserted.</param>
            <param name="index">The zero-based index at which the new elements should be inserted.</param>
            <param name="source">The span whose elements should be added to the <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is less than 0 or greater than <paramref name="list"/>'s <see cref="P:System.Collections.Generic.List`1.Count"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.CopyTo``1(System.Collections.Generic.List{``0},System.Span{``0})">
            <summary>Copies the entire <see cref="T:System.Collections.Generic.List`1"/> to a span.</summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="list">The list from which the elements are copied.</param>
            <param name="destination">
            The span that is the destination of the elements copied from <paramref name="list"/>.
            </param>
            <exception cref="T:System.ArgumentException">
            The number of elements in the source <see cref="T:System.Collections.Generic.List`1"/> is greater
            than the number of elements that the destination span can contain.
            </exception>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyCollection`1">
            <summary>Provides a read-only, covariant view of a generic list.</summary>
            <typeparam name="T">The type of item on the list.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyCollection`1.Count">
            <summary>Gets the amount of items on the list.</summary>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyDictionary`2">
            <summary>Represents a generic read-only collection of key/value pairs.</summary>
            <typeparam name="TKey">The type of keys in the read-only dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the read-only dictionary.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Keys">
            <summary>Gets an enumerable collection that contains the keys in the read-only dictionary.</summary>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Values">
            <summary>Gets an enumerable collection that contains the values in the read-only dictionary.</summary>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Item(`0)">
            <summary>Gets the element that has the specified key in the read-only dictionary.</summary>
            <param name="key">The key to locate.</param>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the read-only dictionary contains an element that has the specified key.</summary>
            <param name="key">The key to locate.</param>
            <returns>
            <see langword="true"/> if the read-only dictionary contains an element that has the specified key;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>Gets the value that is associated with the specified key.</summary>
            <param name="key">The key to locate.</param>
            <param name="value">
            When this method returns, the value associated with the specified key, if the key is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <see langword="true"/> if the object that implements the <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>
            interface contains an element that has the specified key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyList`1">
            <summary>Represents a read-only collection of elements that can be accessed by index.</summary>
            <typeparam name="T">The type of elements in the read-only list.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyList`1.Item(System.Int32)">
            <summary>Performs an index operation on the list.</summary>
            <param name="index">The item to retrieve.</param>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlySet`1">
            <summary>Provides a readonly abstraction of a set.</summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.Contains(`0)">
            <summary>Determines if the set contains a specific item.</summary>
            <param name="item">The item to check if the set contains.</param>
            <returns><see langword="true"/> if found; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) subset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set is a proper subset of other; otherwise <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) superset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the collection is a proper superset of other; otherwise <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determine whether the current set is a subset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true"/> if the current set is a subset of other; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determine whether the current set is a super set of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true"/> if the current set is a subset of other; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set overlaps with the specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set and other share at least one common element;
            otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set is equal to other; otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="T:System.Collections.Generic.ISet`1">
            <summary>Provides the base interface for the abstraction of sets.</summary>
            <remarks><para>
            This interface provides methods for implementing sets,
            which are collections that have unique elements and specific operations.
            </para></remarks>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes all elements in the specified collection from the current set.</summary>
            <remarks><para>
            This method is an O(<c>n</c>) operation,
            where <c>n</c> is the number of elements in the <paramref name="other"/> parameter.
            </para></remarks>
            <param name="other">The collection of items to remove from the set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains only elements that are also in a specified collection.
            </summary>
            <remarks><para>This method ignores any duplicate elements in other.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains only elements that are present
            either in the current set or in the specified collection, but not both.
            </summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains all elements that are present in the current set,
            in the specified collection, or in both.
            </summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.Add(`0)">
            <summary>
            Adds an element to the current set and returns a value to indicate if the element was successfully added.
            </summary>
            <param name="item">The element to add to the set.</param>
            <returns>
            <see langword="true"/> if the element is added to the set;
            <see langword="false"/> if the element is already in the set.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) superset of a specified collection.</summary>
            <remarks><para>
            If the current set is a proper superset of <paramref name="other"/>,
            <paramref name="other"/> must have at least one element that the current set does not have.
            </para><para>
            An empty set is a proper superset of any other collection. Therefore, this method returns <see langword="true"/>
            if the current set is empty, unless the <paramref name="other"/> parameter is also an empty set.
            </para><para>
            This method always returns <see langword="false"/> if the current set is
            less than or equal to the number of elements in <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a proper superset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) subset of a specified collection.</summary>
            <remarks><para>
            If the current set is a proper subset of <paramref name="other"/>,
            <paramref name="other"/> must have at least one element that the current set does not have.
            </para><para>
            An empty set is a proper subset of any other collection. Therefore, this method returns <see langword="true"/>
            if the current set is empty, unless the <paramref name="other"/> parameter is also an empty set.
            </para><para>
            This method always returns <see langword="false"/> if the current set has
            more or the same number of elements than <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a proper subset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a set is a subset of a specified collection.</summary>
            <remarks><para>
            If <paramref name="other"/> contains the same elements as the current set,
            the current set is still considered a subset of <paramref name="other"/>.
            </para><para>
            This method always returns <see langword="false"/> if the current
            set has elements that are not in <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a subset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a superset of a specified collection.</summary>
            <remarks><para>
            If <paramref name="other"/> contains the same elements as the current set,
            the current set is still considered a superset of <paramref name="other"/>.
            </para><para>
            This method always returns <see langword="false"/> if the current
            set has fewer elements than <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a superset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set overlaps with the specified collection.</summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set and <paramref name="other"/> share at least one common element;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is equal to <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:System.Runtime.InteropServices.MemoryMarshal">
            <summary>
            Provides a collection of methods for interoperating with <see cref="!:Memory&lt;T&gt;"/>, <see cref="!:ReadOnlyMemory&lt;T&gt;"/>,
            <see cref="T:System.Span`1"/>, and <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
            <summary>
            Casts a Span of one primitive type <typeparamref name="TFrom"/>
            to another primitive type <typeparamref name="TTo"/>.
            These types may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <remarks><para>
            Supported only for platforms that support misaligned memory
            access or when the memory block is aligned by other means.
            </para></remarks>
            <typeparam name="TFrom">The type of the source span.</typeparam>
            <typeparam name="TTo">The type of the target span.</typeparam>
            <param name="span">The source slice, of type <typeparamref name="TFrom"/>.</param>
            <returns>The converted span.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
            <summary>
            Casts a ReadOnlySpan of one primitive type <typeparamref name="TFrom"/> to another primitive type <typeparamref name="TTo"/>.
            These types may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <remarks><para>
            Supported only for platforms that support misaligned memory
            access or when the memory block is aligned by other means.
            </para></remarks>
            <typeparam name="TFrom">The type of the source span.</typeparam>
            <typeparam name="TTo">The type of the target span.</typeparam>
            <param name="span">The source slice, of type <typeparamref name="TFrom"/>.</param>
            <returns>The converted read-only span.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
            <summary>
            Create a new span over a portion of a regular managed object. This can be useful
            if part of a managed object represents a "fixed array." This is dangerous because the
            <paramref name="length"/> is not checked.
            </summary>
            <typeparam name="T">The type of <paramref name="reference"/>.</typeparam>
            <param name="reference">A reference to data.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <returns>The lifetime of the returned span will not be validated for safety by span-aware languages.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
            <summary>
            Create a new read-only span over a portion of a regular managed object. This can be useful
            if part of a managed object represents a "fixed array." This is dangerous because the
            <paramref name="length"/> is not checked.
            </summary>
            <typeparam name="T">The type of <paramref name="reference"/>.</typeparam>
            <param name="reference">A reference to data.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <returns>The lifetime of the returned span will not be validated for safety by span-aware languages.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterceptsLocationAttribute">
            <summary>Indicates that a location is intercepted by this method.</summary>
            <param name="filePath">The file path to the intercepted location.</param>
            <param name="line">The line number to the intercepted location.</param>
            <param name="character">The character number to the intercepted location.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterceptsLocationAttribute.#ctor(System.String,System.Int32,System.Int32)">
            <summary>Indicates that a location is intercepted by this method.</summary>
            <param name="filePath">The file path to the intercepted location.</param>
            <param name="line">The line number to the intercepted location.</param>
            <param name="character">The character number to the intercepted location.</param>
        </member>
        <member name="T:System.Runtime.CompilerServices.CollectionBuilderAttribute">
            <summary>
            Initialize the attribute to refer to the <paramref name="methodName"/>
            method on the <paramref name="builderType"/> type.
            </summary>
            <param name="builderType">The type of the builder to use to construct the collection.</param>
            <param name="methodName">The name of the method on the builder to use to construct the collection.</param>
            <remarks><para>
            <paramref name="methodName"/> must refer to a static method that accepts a single parameter of
            type <c>ReadOnlySpan&lt;T&gt;</c> and returns an instance of the collection being built containing
            a copy of the data from that span. In future releases of .NET, additional patterns may be supported.
            </para></remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.CollectionBuilderAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initialize the attribute to refer to the <paramref name="methodName"/>
            method on the <paramref name="builderType"/> type.
            </summary>
            <param name="builderType">The type of the builder to use to construct the collection.</param>
            <param name="methodName">The name of the method on the builder to use to construct the collection.</param>
            <remarks><para>
            <paramref name="methodName"/> must refer to a static method that accepts a single parameter of
            type <c>ReadOnlySpan&lt;T&gt;</c> and returns an instance of the collection being built containing
            a copy of the data from that span. In future releases of .NET, additional patterns may be supported.
            </para></remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.BuilderType">
            <summary>Gets the type of the builder to use to construct the collection.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.MethodName">
            <summary>Gets the name of the method on the builder to use to construct the collection.</summary>
            <remarks><para>
            This should match the metadata name of the target method.
            For example, this might be ".ctor" if targeting the type's constructor.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute">
            <summary>
            Indicates the type of the async method builder that should be used by a language compiler to
            build the attributed async method or to build the attributed type when used as the return type
            of an async method.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.#ctor(System.Type)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute"/> class.</summary>
            <param name="builderType">The <see cref="T:System.Type"/> of the associated builder.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.BuilderType">
            <summary>Gets the <see cref="T:System.Type"/> of the associated builder.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.op_Implicit(System.Type)~System.Runtime.CompilerServices.AsyncMethodBuilderAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of AsyncMethodBuilderAttribute by using the constructor
            <see cref="M:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.#ctor(System.Type)"/>.
            </summary>
            <param name="builderType">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of AsyncMethodBuilderAttribute by passing the parameter <paramref name="builderType"/> to the constructor
            <see cref="M:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.#ctor(System.Type)"/>.
            </returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>Indicates the attributed type is to be used as an interpolated string handler.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <remarks><para>
            The empty string may be used as the name of the receiver in an instance method.
            </para></remarks>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <remarks><para>
            The empty string may be used as the name of the receiver in an instance method.
            </para></remarks>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>Gets the names of the arguments that should be passed to the handler.</summary>
            <remarks><para>
            The empty string may be used as the name of the receiver in an instance method.
            </para></remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.op_Implicit(System.String)~System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of InterpolatedStringHandlerArgumentAttribute by using the constructor
            <see cref="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)"/>.
            </summary>
            <param name="argument">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of InterpolatedStringHandlerArgumentAttribute by passing the parameter <paramref name="argument"/> to the constructor
            <see cref="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.op_Implicit(System.String[])~System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of InterpolatedStringHandlerArgumentAttribute by using the constructor
            <see cref="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])"/>.
            </summary>
            <param name="arguments">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of InterpolatedStringHandlerArgumentAttribute by passing the parameter <paramref name="arguments"/> to the constructor
            <see cref="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])"/>.
            </returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
            <summary>
            Used to indicate to the compiler that a method should be called in its containing module's initializer.
            </summary>
            <remarks><para>
            When one or more valid methods with this attribute are found in a compilation,
            the compiler will emit a module initializer that calls each of the attributed methods.<br />
            Certain requirements are imposed on any method targeted with this attribute:
            </para><list type="bullet">
            <item><description>The method must be <see langword="static"/>.</description></item>
            <item><description>
            The method must be an ordinary member method, as opposed to a property accessor,
            constructor, local function, and so on.
            </description></item>
            <item><description>The method must be parameterless..</description></item>
            <item><description>The method must return <see langword="void"/>.</description></item>
            <item><description>The method must not be generic or be contained in a generic type.</description></item>
            <item><description>
            The method's effective accessibility must be <see langword="internal"/> or <see langword="public"/>.
            </description></item>
            </list><para>
            For more information, see the
            <a href="https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer">
            ECMA specification
            </a>.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerFilePathAttribute">
            <summary>
            Allows you to obtain the full path of the source file that contains the caller.
            This is the file path at the time of compile.
            </summary>
            <remarks><para>
            You apply the <see cref="T:System.Runtime.CompilerServices.CallerFilePathAttribute"/> attribute to an optional parameter that has a default value.
            You must specify an explicit default value for the optional parameter.
            You can't apply this attribute to parameters that aren't specified as optional.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerLineNumberAttribute">
            <summary>Allows you to obtain the line number in the source file at which the method is called.</summary>
            <remarks><para>
            You apply the <see cref="T:System.Runtime.CompilerServices.CallerLineNumberAttribute"/> attribute to an optional parameter that
            has a default value. You must specify an explicit default value for the optional parameter.
            You can't apply this attribute to parameters that aren't specified as optional.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerMemberNameAttribute">
            <summary>Allows you to obtain the method or property name of the caller to the method.</summary>
            <remarks><para>
            You apply the <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/> attribute to an optional parameter that
            has a default value. You must specify an explicit default value for the optional parameter.
            You can't apply this attribute to parameters that aren't specified as optional.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>Indicates that a parameter captures the expression passed for another parameter as a string.</summary>
            <remarks><para>This attribute is implemented in the compiler for C# 10 and later versions only.</para></remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.</summary>
            <param name="parameterName">
            The name of the parameter whose expression should be captured as a string.
            </param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>Gets the name of the parameter whose expression should be captured as a string.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.op_Implicit(System.String)~System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of CallerArgumentExpressionAttribute by using the constructor
            <see cref="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)"/>.
            </summary>
            <param name="parameterName">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of CallerArgumentExpressionAttribute by passing the parameter <paramref name="parameterName"/> to the constructor
            <see cref="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
            </summary>
            <remarks><para>
            This attribute is unsafe because it may reveal uninitialized memory to the application in certain
            instances (e.g., reading from uninitialized stackalloc'd memory). If applied to a method directly,
            the attribute applies to that method and all nested functions (lambdas, local functions) below it.
            If applied to a type or module, it applies to all methods nested inside. This attribute is intentionally
            not permitted on assemblies. Use at the module level instead to apply to multiple type declarations.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute">
            <summary>
            Indicates that an API is in preview. This attribute allows call sites to be
            flagged with a diagnostic that indicates that a preview feature is used.
            Authors can use this attribute to ship preview features in their assemblies.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.#ctor">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute"/> class.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute"/> class
            with the specified message.
            </summary>
            <param name="message">An optional message associated with this attribute instance.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.Message">
            <summary>Gets the optional message associated with this attribute instance.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.Url">
            <summary>Gets or sets the optional URL associated with this attribute instance.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.op_Implicit(System.String)~System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of RequiresPreviewFeaturesAttribute by using the constructor
            <see cref="M:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.#ctor(System.String)"/>.
            </summary>
            <param name="message">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of RequiresPreviewFeaturesAttribute by passing the parameter <paramref name="message"/> to the constructor
            <see cref="M:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is
            required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> class.</summary>
            <param name="featureName">The name of the compiler feature.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>Gets the name of the compiler feature.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            Gets or sets a value indicating whether the compiler can choose to allow access to the location
            where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.op_Implicit(System.String)~System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of CompilerFeatureRequiredAttribute by using the constructor
            <see cref="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)"/>.
            </summary>
            <param name="featureName">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of CompilerFeatureRequiredAttribute by passing the parameter <paramref name="featureName"/> to the constructor
            <see cref="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>Specifies that a type has required members or that a member is required.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InlineArrayAttribute">
            <summary>Indicates that the instance's storage is sequentially replicated "length" times.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InlineArrayAttribute.#ctor(System.Int32)">
            <summary>Indicates that the instance's storage is sequentially replicated "length" times.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.InlineArrayAttribute.Length">
            <summary>Gets the length of the inlined array.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InlineArrayAttribute.op_Implicit(System.Int32)~System.Runtime.CompilerServices.InlineArrayAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of InlineArrayAttribute by using the constructor
            <see cref="M:System.Runtime.CompilerServices.InlineArrayAttribute.#ctor(System.Int32)"/>.
            </summary>
            <param name="length">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of InlineArrayAttribute by passing the parameter <paramref name="length"/> to the constructor
            <see cref="M:System.Runtime.CompilerServices.InlineArrayAttribute.#ctor(System.Int32)"/>.
            </returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.MethodImplOptions">
            <summary>
            Specifies constants that define the details of how a method is implemented.
            This enumeration supports a bitwise combination of its member values.
            </summary>
            <remarks><para>
            This enumeration is used with the <see cref="T:System.Runtime.CompilerServices.MethodImplAttribute"/> attribute.
            You can specify multiple <see cref="T:System.Runtime.CompilerServices.MethodImplOptions"/> values by using the bitwise OR operator.
            </para></remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.Unmanaged">
            <summary>The method is implemented in unmanaged code.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.NoInlining">
            <summary>
            The method cannot be inlined.
            Inlining is an optimization by which a method call is replaced with the method body.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.ForwardRef">
            <summary>The method is declared, but its implementation is provided elsewhere.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.Synchronized">
            <summary>
            The method can be executed by only one thread at a time.
            Static methods lock on the type, whereas instance methods lock on the instance.
            Only one thread can execute in any of the instance functions,
            and only one thread can execute in any of a class's static functions.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.NoOptimization">
            <summary>
            The method is not optimized by the just-in-time (JIT) compiler or by native code generation (see Ngen.exe)
            when debugging possible code generation problems.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.PreserveSig">
            <summary>The method signature is exported exactly as declared.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining">
            <summary>The method should be inlined if possible.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization">
            <summary>The method contains code that should always be optimized by the just-in-time (JIT) compiler.</summary>
            <remarks><para>
            Use this attribute if running an unoptimized version of the method has undesirable effects,
            for instance causing too much overhead or extra memory allocation.
            </para><para>
            Methods with this attribute may not have optimal code generation.
            They bypass the first tier of Tiered Compilation and therefore can't benefit from optimizations that rely on
            tiering, for example, Dynamic PGO or optimizations based on initialized classes.
            </para></remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.InternalCall">
            <summary>
            The call is internal, that is, it calls a method that's implemented within the common language runtime.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RuntimeHelpers">
            <summary>
            Provides a set of static methods and properties that provide support for compilers. This class cannot be inherited.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
            <summary>Gets the byte offset, from the start of the <see cref="T:System.String"/> to the first character.</summary>
            <remarks><para>
            Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.
            Compilers should pin the string against movement by the garbage collector before use. Note that common language
            runtime strings are immutable; that is, their contents can be read but not changed.
            </para></remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray``1(``0[],System.Range)">
            <summary>Slices the specified array using the specified range.</summary>
            <typeparam name="T">The type of elements in the array.</typeparam>
            <param name="array">The array to slice.</param>
            <param name="range">
            An object that determines the portion of <paramref name="array"/> to include in the slice.
            </param>
            <returns>The subarray defined by <paramref name="range"/>.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.ITuple">
            <summary>This interface is required for types that want to be indexed into by dynamic patterns.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Length">
            <summary>The number of positions in this data structure.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)">
            <summary>Get the element at position <paramref name="index"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleElementNamesAttribute">
            <summary>
            Indicates that the use of <see cref="T:System.ValueTuple" /> on a member is meant to be treated as a tuple with element names.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute" /> class.
            </summary>
            <param name="transformNames">
            Specifies, in a pre-order depth-first traversal of a type's
            construction, which <see cref="T:System.ValueTuple" /> occurrences are
            meant to carry element names.
            </param>
            <remarks><para>
            This constructor is meant to be used on types that contain an
            instantiation of <see cref="T:System.ValueTuple" /> that contains
            element names.  For instance, if <c>C</c> is a generic type with
            two type parameters, then a use of the constructed type <c>C{<see cref="T:System.ValueTuple`2" />,
            <see cref="T:System.ValueTuple`3" /></c> might be intended to
            treat the first type argument as a tuple with element names and the
            second as a tuple without element names. In which case, the
            appropriate attribute specification should use a
            <paramref name="transformNames"/> value of <c>{ "name1", "name2", null, null,
            null }</c>.
            </para></remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames">
            <summary>
            Specifies, in a pre-order depth-first traversal of a type's
            construction, which <see cref="T:System.ValueTuple" /> elements are
            meant to carry element names.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.op_Implicit(System.String[])~System.Runtime.CompilerServices.TupleElementNamesAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of TupleElementNamesAttribute by using the constructor
            <see cref="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.#ctor(System.String[])"/>.
            </summary>
            <param name="transformNames">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of TupleElementNamesAttribute by passing the parameter <paramref name="transformNames"/> to the constructor
            <see cref="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.#ctor(System.String[])"/>.
            </returns>
        </member>
        <member name="T:System.Action`5">
            <summary>Encapsulates a method that has four parameters and does not return a value.</summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:System.Action`6">
            <summary>Encapsulates a method that has four parameters and does not return a value.</summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
        </member>
        <member name="T:System.Func`6">
            <summary>
            Encapsulates a method that has no parameters and returns a value of
            the type specified by the <typeparamref name="TResult"/> parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:System.Func`7">
            <summary>
            Encapsulates a method that has no parameters and returns a value of
            the type specified by the <typeparamref name="TResult"/> parameter.
            </summary>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.GeneratedRegexAttribute">
            <summary>
            Instructs the System.Text.RegularExpressions source generator to
            generate an implementation of the specified regular expression.
            </summary>
            <remarks>
            <para>
            The generator associated with this attribute only supports C#. It only supplies an implementation when applied
            to static, partial, parameterless, non-generic methods that are typed to return <see cref="T:System.Text.RegularExpressions.Regex"/>.
            </para>
            <para>
            When the <see cref="T:System.Text.RegularExpressions.Regex"/> supports case-insensitive matches (either by passing
            <see cref="F:System.Text.RegularExpressions.RegexOptions.IgnoreCase"/> or using the inline <c>(?i)</c> switch in the pattern) the regex engines
            will use an internal casing table to transform the passed in pattern into an equivalent case-sensitive one.
            For example, given the pattern <c>abc</c>, the engines will transform it to the equivalent pattern
            <c>[Aa][Bb][Cc]</c>. The equivalences found in this internal casing table can change over time, for example in
            the case new characters are added to a new version of Unicode. When using the source generator, this
            transformation happens at compile time, which means the casing table used to find the equivalences will depend
            on the target framework at compile time. This differs from the rest of the <see cref="T:System.Text.RegularExpressions.Regex"/> engines, which
            perform this transformation at run-time, meaning they will always use casing table for the current runtime.
            </para></remarks>
        </member>
        <member name="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.GeneratedRegexAttribute"/> class with the specified pattern.
            </summary>
            <param name="pattern">The regular expression pattern to match.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.GeneratedRegexAttribute"/>
            class with the specified pattern and options.
            </summary>
            <param name="pattern">The regular expression pattern to match.</param>
            <param name="options">
            A bitwise combination of the enumeration values that modify the regular expression.
            </param>
        </member>
        <member name="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.GeneratedRegexAttribute"/>
            class with the specified pattern and options.
            </summary>
            <param name="pattern">The regular expression pattern to match.</param>
            <param name="options">
            A bitwise combination of the enumeration values that modify the regular expression.
            </param>
            <param name="cultureName">
            The name of a culture to be used for case sensitive comparisons.
            <paramref name="cultureName"/> is not case-sensitive.
            </param>
            <remarks><para>
            For a list of predefined culture names on Windows systems, see the Language tag column in the
            list of language/region names supported by
            <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c">
            Windows
            </a>.
            Culture names follow the standard defined by <a href="https://tools.ietf.org/html/bcp47">BCP 47</a>.
            In addition, starting with Windows 10, <paramref name="cultureName"/> can be any valid BCP-47 language tag.
            </para><para>
            If <paramref name="cultureName"/> is <see cref="F:System.String.Empty"/>, the invariant culture will be used.
            </para></remarks>
        </member>
        <member name="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.GeneratedRegexAttribute"/>
            class with the specified pattern, options, and timeout.
            </summary>
            <param name="pattern">The regular expression pattern to match.</param>
            <param name="options">
            A bitwise combination of the enumeration values that modify the regular expression.
            </param>
            <param name="matchTimeoutMilliseconds">
            A time-out interval (milliseconds), or <see cref="F:System.Threading.Timeout.Infinite"/>
            to indicate that the method should not time out.
            </param>
        </member>
        <member name="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.GeneratedRegexAttribute"/>
            class with the specified pattern, options, and timeout.
            </summary>
            <param name="pattern">The regular expression pattern to match.</param>
            <param name="options">
            A bitwise combination of the enumeration values that modify the regular expression.
            </param>
            <param name="matchTimeoutMilliseconds">
            A time-out interval (milliseconds), or <see cref="F:System.Threading.Timeout.Infinite"/>
            to indicate that the method should not time out.</param>
            <param name="cultureName">
            The name of a culture to be used for case sensitive comparisons.
            <paramref name="cultureName"/> is not case-sensitive.
            </param>
            <remarks><para>
            For a list of predefined culture names on Windows systems, see the Language tag column in the
            list of language/region names supported by
            <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c">
            Windows
            </a>.
            Culture names follow the standard defined by <a href="https://tools.ietf.org/html/bcp47">BCP 47</a>.
            In addition, starting with Windows 10, <paramref name="cultureName"/> can be any valid BCP-47 language tag.
            </para><para>
            If <paramref name="cultureName"/> is <see cref="F:System.String.Empty"/>, the invariant culture will be used.
            </para></remarks>
        </member>
        <member name="P:System.Text.RegularExpressions.GeneratedRegexAttribute.MatchTimeoutMilliseconds">
            <summary>
            Gets a time-out interval (milliseconds), or <see cref="F:System.Threading.Timeout.Infinite"/>
            to indicate that the method should not time out.
            </summary>
        </member>
        <member name="P:System.Text.RegularExpressions.GeneratedRegexAttribute.CultureName">
            <summary>Gets the name of the culture to be used for case sensitive comparisons.</summary>
        </member>
        <member name="P:System.Text.RegularExpressions.GeneratedRegexAttribute.Pattern">
            <summary>Gets the regular expression pattern to match.</summary>
        </member>
        <member name="P:System.Text.RegularExpressions.GeneratedRegexAttribute.Options">
            <summary>Gets a bitwise combination of the enumeration values that modify the regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.GeneratedRegexAttribute.op_Implicit(System.String)~System.Text.RegularExpressions.GeneratedRegexAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of GeneratedRegexAttribute by using the constructor
            <see cref="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String)"/>.
            </summary>
            <param name="pattern">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of GeneratedRegexAttribute by passing the parameter <paramref name="pattern"/> to the constructor
            <see cref="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="M:System.Text.RegularExpressions.GeneratedRegexAttribute.op_Implicit(System.ValueTuple{System.String,System.Text.RegularExpressions.RegexOptions})~System.Text.RegularExpressions.GeneratedRegexAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of GeneratedRegexAttribute by using the constructor
            <see cref="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of GeneratedRegexAttribute by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)"/>.
            </returns>
        </member>
        <member name="M:System.Text.RegularExpressions.GeneratedRegexAttribute.op_Implicit(System.ValueTuple{System.String,System.Text.RegularExpressions.RegexOptions,System.String})~System.Text.RegularExpressions.GeneratedRegexAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of GeneratedRegexAttribute by using the constructor
            <see cref="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.String)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of GeneratedRegexAttribute by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.String)"/>.
            </returns>
        </member>
        <member name="M:System.Text.RegularExpressions.GeneratedRegexAttribute.op_Implicit(System.ValueTuple{System.String,System.Text.RegularExpressions.RegexOptions,System.Int32})~System.Text.RegularExpressions.GeneratedRegexAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of GeneratedRegexAttribute by using the constructor
            <see cref="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.Int32)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of GeneratedRegexAttribute by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.Int32)"/>.
            </returns>
        </member>
        <member name="M:System.Text.RegularExpressions.GeneratedRegexAttribute.op_Implicit(System.ValueTuple{System.String,System.Text.RegularExpressions.RegexOptions,System.Int32,System.String})~System.Text.RegularExpressions.GeneratedRegexAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of GeneratedRegexAttribute by using the constructor
            <see cref="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.Int32,System.String)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of GeneratedRegexAttribute by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:System.Text.RegularExpressions.GeneratedRegexAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.Int32,System.String)"/>.
            </returns>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks><para>
            Index is used by the C# compiler to support the new index syntax.
            </para><code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code></remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks><para>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means
            pointing at beyond last element.
            </para></remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)" />
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <inheritdoc />
        </member>
        <member name="M:System.Index.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">
            The length of the collection that the Index will be used with. length has to be a positive value.
            </param>
            <remarks><para>
            For performance reasons, we don't validate the input length parameter and the returned offset value against
            negative values. We don't validate either the returned offset is greater than the input length.
            It is expected that Index be used with collections which always have non-negative length/count.
            If the returned offset is negative and then used to index a collection will get out of range exception which
            will be same affect as the validation.
            </para></remarks>
        </member>
        <member name="M:System.Index.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Index.op_Implicit(System.ValueTuple{System.Int32,System.Boolean})~System.Index">
            <summary>
            Implicitly converts the parameter by creating the new instance of Index by using the constructor
            <see cref="M:System.Index.#ctor(System.Int32,System.Boolean)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Index by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:System.Index.#ctor(System.Int32,System.Boolean)"/>.
            </returns>
        </member>
        <member name="T:System.Int32TryFormatPolyfill">
            <summary>Provides the polyfill to <c>int.TryFormat</c>.</summary>
        </member>
        <member name="M:System.Int32TryFormatPolyfill.TryFormat(System.Int32,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Tries to format the value of the current integer number instance into the provided span of characters.
            </summary>
            <param name="value">The instance.</param>
            <param name="destination">
            The span in which to write this instance's value formatted as a span of characters.
            </param>
            <param name="charsWritten">
            When this method returns, contains the number of characters that were written in <paramref name="destination"/>.
            </param>
            <param name="format">
            A span containing the characters that represent a standard or custom format
            string that defines the acceptable format for <paramref name="destination"/>.
            </param>
            <param name="provider">
            An optional object that supplies culture-specific formatting information for <paramref name="destination"/>.
            </param>
            <exception cref="T:System.NotSupportedException">The parameter <paramref name="format"/> isn't empty.</exception>
            <returns><see langword="true"/> if the formatting was successful; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:System.MemoryExtensions">
            <summary>Extension methods for <see cref="T:System.Span`1"/>, Memory{T}, and friends.</summary>
        </member>
        <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences are equal by comparing the
            elements using <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
            <typeparam name="T">The type of span.</typeparam>
            <param name="span">The first span.</param>
            <param name="other">The other span.</param>
            <returns>The value determining whether two sequences are equal.</returns>
        </member>
        <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its first occurrence.
            If not found, returns -1. Values are compared using <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
            <typeparam name="T">The type of span and value.</typeparam>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its first occurrence.
            If not found, returns -1. Values are compared using <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
            <typeparam name="T">The type of span and value.</typeparam>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
            <inheritdoc cref="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)"/>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})"/>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its last occurrence.
            If not found, returns -1. Values are compared using <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
            <typeparam name="T">The type of span and value.</typeparam>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
            <inheritdoc cref="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)"/>
        </member>
        <member name="T:System.Numerics.BitOperations">
            <summary>
            Utility methods for intrinsic bit-twiddling operations.
            The methods use hardware intrinsics when available on the underlying platform,
            otherwise they use optimized software fallbacks.
            </summary>
        </member>
        <member name="M:System.Numerics.BitOperations.IsPow2(System.Int32)">
            <summary>Evaluate whether a given integral value is a power of 2.</summary>
            <param name="value">The value.</param>
            <returns>
            <see langword="true"/> if the <paramref name="value"/> is a power of 2; <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:System.Numerics.BitOperations.IsPow2(System.UInt32)">
            <inheritdoc cref="M:System.Numerics.BitOperations.IsPow2(System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperations.IsPow2(System.Int64)">
            <inheritdoc cref="M:System.Numerics.BitOperations.IsPow2(System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperations.IsPow2(System.UInt64)">
            <inheritdoc cref="M:System.Numerics.BitOperations.IsPow2(System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperations.IsPow2(System.IntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperations.IsPow2(System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperations.IsPow2(System.UIntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperations.IsPow2(System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperations.PopCount(System.UIntPtr)">
            <summary>Returns the population count (number of bits set) of a mask.</summary>
            <remarks><para>Similar in behavior to the x86 instruction POPCNT.</para></remarks>
            <param name="value">The value.</param>
            <returns>The population count of the mask.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.PopCount(System.UInt32)">
            <summary>Returns the population count (number of bits set) of an unsigned 32-integer mask.</summary>
            <remarks><para>Similar in behavior to the x86 instruction POPCNT.</para></remarks>
            <param name="value">The value.</param>
            <returns>The population count of the mask.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.PopCount(System.UInt64)">
            <summary>Returns the population count (number of bits set) of an unsigned 64-integer mask.</summary>
            <remarks><para>Similar in behavior to the x86 instruction POPCNT.</para></remarks>
            <param name="value">The value.</param>
            <returns>The population count of the mask.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RoundUpToPowerOf2(System.UInt32)">
            <summary>Round the given integral value up to a power of 2.</summary>
            <remarks><para>
            The fallback implementation is based on
            <a href="https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2">
            Bit Twiddling Hacks by Sean Eron Anderson
            </a>.
            </para></remarks>
            <param name="value">The value.</param>
            <returns>
            The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
            If <paramref name="value"/> is 0 or the result overflows, returns 0.
            </returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RoundUpToPowerOf2(System.UInt64)">
            <inheritdoc cref="M:System.Numerics.BitOperations.RoundUpToPowerOf2(System.UInt32)"/>
        </member>
        <member name="M:System.Numerics.BitOperations.RoundUpToPowerOf2(System.UIntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperations.RoundUpToPowerOf2(System.UInt32)"/>
        </member>
        <member name="T:System.RandomGetItems">
            <summary>The backport of GetItems methods for <see cref="T:System.Random"/>.</summary>
        </member>
        <member name="M:System.RandomGetItems.GetItems``1(System.Random,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Fills the elements of a specified span with items chosen at random from the provided set of choices.
            </summary>
            <remarks><para>
            The method uses <see cref="M:System.Random.Next(System.Int32)"/> to select items randomly from <paramref name="choices"/>
            by index and populate <paramref name="destination"/>.
            </para></remarks>
            <typeparam name="T">The type of span.</typeparam>
            <param name="that">The instance of <see cref="T:System.Random"/>.</param>
            <param name="choices">The items to use to populate the span.</param>
            <param name="destination">The span to be filled with items.</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="choices"/> is empty.</exception>
        </member>
        <member name="M:System.RandomGetItems.GetItems``1(System.Random,``0[],System.Int32)">
            <summary>Creates an array populated with items chosen at random from the provided set of choices.</summary>
            <remarks><para>
            The method uses <see cref="M:System.Random.Next(System.Int32)"/> to select items randomly from <paramref name="choices"/>
            by index. This is used to populate a newly-created array.
            </para></remarks>
            <typeparam name="T">The type of array.</typeparam>
            <param name="that">The instance of <see cref="T:System.Random"/>.</param>
            <param name="choices">The items to use to populate the array.</param>
            <param name="length">The length of array to return.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="length"/> is not zero or a positive number.
            </exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="choices"/> is empty.</exception>
            <returns>An array populated with random items.</returns>
        </member>
        <member name="M:System.RandomGetItems.GetItems``1(System.Random,System.ReadOnlySpan{``0},System.Int32)">
            <summary>Creates an array populated with items chosen at random from the provided set of choices.</summary>
            <remarks><para>
            The method uses <see cref="M:System.Random.Next(System.Int32)"/> to select items randomly from <paramref name="choices"/>
            by index. This is used to populate a newly-created array.
            </para></remarks>
            <typeparam name="T">The type of array.</typeparam>
            <param name="that">The instance of <see cref="T:System.Random"/>.</param>
            <param name="choices">The items to use to populate the array.</param>
            <param name="length">The length of array to return.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="length"/> is not zero or a positive number.
            </exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="choices"/> is empty.</exception>
            <returns>An array populated with random items.</returns>
        </member>
        <member name="T:System.RandomShuffle">
            <summary>The backport of Shuffle methods for <see cref="T:System.Random"/>.</summary>
        </member>
        <member name="M:System.RandomShuffle.Shuffle``1(System.Random,``0[])">
            <summary>Performs an in-place shuffle of an array.</summary>
            <remarks><para>
            This method uses <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> to choose values for shuffling.
            This method is an O(n) operation.
            </para></remarks>
            <typeparam name="T">The type of array.</typeparam>
            <param name="that">The instance of <see cref="T:System.Random"/>.</param>
            <param name="values">The array to shuffle.</param>
        </member>
        <member name="M:System.RandomShuffle.Shuffle``1(System.Random,System.Span{``0})">
            <summary>Performs an in-place shuffle of a span.</summary>
            <typeparam name="T">The type of span.</typeparam>
            <param name="that">The instance of <see cref="T:System.Random"/>.</param>
            <param name="values">The span to shuffle.</param>
            <remarks><para>
            This method uses <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> to choose values for shuffling.
            This method is an O(n) operation.
            </para></remarks>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks><para>
            Range is used by the C# compiler to support the range syntax.
            </para><code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code></remarks>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <inheritdoc />
        </member>
        <member name="M:System.Range.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Range.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Range.op_Implicit(System.ValueTuple{System.Index,System.Index})~System.Range">
            <summary>
            Implicitly converts the parameter by creating the new instance of Range by using the constructor
            <see cref="M:System.Range.#ctor(System.Index,System.Index)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Range by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:System.Range.#ctor(System.Index,System.Index)"/>.
            </returns>
        </member>
        <member name="T:System.Reflection.CustomAttributeExtensions">
            <summary>Contains static methods for retrieving custom attributes.</summary>
        </member>
        <member name="T:System.Span`1">
            <summary>Provides a type-safe and memory-safe representation of a contiguous region of arbitrary memory.</summary>
            <remarks><para>This type delegates the responsibility of pinning the pointer to the consumer.</para></remarks>
            <typeparam name="T">The type of items in the <see cref="T:System.Span`1"/>.</typeparam>
        </member>
        <member name="M:System.Span`1.#ctor(System.Void*,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Span`1"/> struct from a specified number of
            <typeparamref name="T"/> elements starting at a specified memory address.
            </summary>
            <param name="pointer">A pointer to the starting address of a specified number of T elements in memory.</param>
            <param name="length">The length of the buffer.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> is negative.</exception>
        </member>
        <member name="P:System.Span`1.Item(System.Int32)">
            <summary>Gets the element at the specified zero-based index.</summary>
            <param name="index">The zero-based index of the element.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is less than zero or is greater than or equal to <see cref="P:System.Span`1.Length"/>.
            </exception>
        </member>
        <member name="P:System.Span`1.Empty">
            <summary>Gets an empty <see cref="T:System.Span`1"/> object.</summary>
        </member>
        <member name="P:System.Span`1.IsEmpty">
            <summary>Gets a value indicating whether the current <see cref="T:System.Span`1"/> is empty.</summary>
        </member>
        <member name="P:System.Span`1.Length">
            <summary>Gets the length of the current span.</summary>
        </member>
        <member name="P:System.Span`1.Pointer">
            <summary>Gets the pointer representing the first element in the buffer.</summary>
            <remarks><para>
            This property does not normally exist, and is used as a workaround polyfill for <c>GetPinnableReference</c>.
            When using this property, ensure you have the appropriate preprocessors for using a fixed expression instead.
            </para><para>
            Due to a specific runtime issue, this property cannot be generic, as this causes some JITs
            (notably .NET Framework) to be upset from its metadata and refuse to load. It is therefore expected of the
            caller to cast the returned pointer every time if needed.
            </para></remarks>
        </member>
        <member name="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})">
            <summary>Returns a value that indicates whether two <see cref="T:System.Span`1"/> objects are equal.</summary>
            <remarks><para>
            Two <see cref="T:System.Span`1"/> objects are equal if they have the same length and the corresponding elements of
            <paramref name="left"/> and <paramref name="right"/> point to the same memory. Note that the test for equality
            does <i>not</i> attempt to determine whether the contents are equal.
            </para></remarks>
            <param name="left">The first span to compare.</param>
            <param name="right">The second span to compare.</param>
            <returns>
            <see langword="true"/> if the two <see cref="T:System.Span`1"/> objects are equal; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})">
            <summary>Returns a value that indicates whether two <see cref="T:System.Span`1"/> objects are not equal.</summary>
            <remarks><para>
            Two <see cref="T:System.Span`1"/> objects are equal if they have the same length and the corresponding elements of
            <paramref name="left"/> and <paramref name="right"/> point to the same memory.
            </para></remarks>
            <param name="left">The first span to compare.</param>
            <param name="right">The second span to compare.</param>
            <returns>
            <see langword="true"/> if the two <see cref="T:System.Span`1"/> objects are not equal;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}">
            <summary>Defines an implicit conversion of a <see cref="T:System.Span`1"/> to a <see cref="T:System.ReadOnlySpan`1"/>.</summary>
            <param name="span">The object to convert to a <see cref="T:System.ReadOnlySpan`1"/>.</param>
            <returns>A read-only span that corresponds to the current instance.</returns>
        </member>
        <member name="M:System.Span`1.Clear">
            <summary>Clears the contents of this <see cref="T:System.Span`1"/> object.</summary>
            <remarks><para>
            The <see cref="M:System.Span`1.Clear"/> method sets the items in the <see cref="T:System.Span`1"/> object to their default values.
            It does not remove items from the <see cref="T:System.Span`1"/>.
            </para></remarks>
        </member>
        <member name="M:System.Span`1.CopyTo(System.Span{`0})">
            <summary>Copies the contents of this <see cref="T:System.Span`1"/> into a destination <see cref="T:System.Span`1"/>.</summary>
            <param name="destination">The destination <see cref="T:System.Span`1"/> object.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="destination"/> is shorter than the source <see cref="T:System.Span`1"/>.
            </exception>
        </member>
        <member name="M:System.Span`1.CopyTo(System.Collections.Generic.IList{`0})">
            <summary>Copies the contents of this <see cref="T:System.Span`1"/> into a destination <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <param name="destination">The destination <see cref="T:System.Collections.Generic.IList`1"/> object.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="destination"/> is shorter than the source <see cref="T:System.Span`1"/>.
            </exception>
        </member>
        <member name="M:System.Span`1.Fill(`0)">
            <summary>Fills the elements of this span with a specified value.</summary>
            <param name="value">The value to assign to each element of the span.</param>
        </member>
        <member name="M:System.Span`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Span`1.TryCopyTo(System.Span{`0})">
            <summary>
            Attempts to copy the current <see cref="T:System.Span`1"/> to a destination <see cref="T:System.Span`1"/>
            and returns a value that indicates whether the copy operation succeeded.
            </summary>
            <remarks><para>
            This method copies all of <c>source</c> to <paramref name="destination"/> even if
            <c>source</c> and <paramref name="destination"/> overlap.
            If <paramref name="destination"/> is shorter than the source <see cref="T:System.Span`1"/>, this method returns
            <see langword="false"/>, and no data is written to <paramref name="destination"/>.
            </para></remarks>
            <param name="destination">The target of the copy operation.</param>
            <returns><see langword="true"/> if the copy operation succeeded; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:System.Span`1.TryCopyTo(System.Collections.Generic.IList{`0})">
            <inheritdoc cref="M:System.Span`1.TryCopyTo(System.Span{`0})"/>
        </member>
        <member name="M:System.Span`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Span`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Span`1.GetEnumerator">
            <summary>Returns an enumerator of this <see cref="T:System.Span`1"/>.</summary>
            <returns>An enumerator for this span.</returns>
        </member>
        <member name="M:System.Span`1.Slice(System.Int32)">
            <summary>Forms a slice out of the current span that begins at a specified index.</summary>
            <param name="start">The index at which to begin the slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="start"/> is less than zero or greater than <see cref="P:System.Span`1.Length"/>.
            </exception>
            <returns>
            A span that consists of all elements of the current span from <paramref name="start"/> to the end of the span.
            </returns>
        </member>
        <member name="M:System.Span`1.Slice(System.Int32,System.Int32)">
            <summary>Creates the slice of this buffer.</summary>
            <param name="start">The start of the slice from this buffer.</param>
            <param name="length">The length of the slice from this buffer.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">An out-of-range buffer is created.</exception>
            <returns>The <see cref="T:System.Span`1"/> which is a slice of this buffer.</returns>
        </member>
        <member name="M:System.Span`1.ToArray">
            <summary>Copies the contents of this span into a new array.</summary>
            <remarks><para>
            This method performs a heap allocation and therefore should be avoided if possible.
            Heap allocations are expected in APIs that work with arrays.
            Using such APIs is unavoidable if an alternative API overhead that takes a <see cref="T:System.Span`1"/> does not exist.
            </para></remarks>
            <returns>An array containing the data in the current span.</returns>
        </member>
        <member name="T:System.Span`1.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:System.Span`1"/>.</summary>
        </member>
        <member name="M:System.Span`1.Enumerator.#ctor(System.Span{`0})">
            <summary>Initializes a new instance of the <see cref="T:System.Span`1.Enumerator"/> struct.</summary>
            <param name="span">The buffer to peek through.</param>
        </member>
        <member name="P:System.Span`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current" />
        </member>
        <member name="M:System.Span`1.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="M:System.Span`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the collection.</summary>
            <returns>
            <see langword="true"/> if the enumerator was successfully advanced to the next element;
            <see langword="false"/> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:System.Span`1.Enumerator.op_Implicit(System.Span{`0})~System.Span{`0}.Enumerator">
            <summary>
            Implicitly converts the parameter by creating the new instance of Enumerator by using the constructor
            <see cref="M:System.Span`1.Enumerator.#ctor(System.Span{`0})"/>.
            </summary>
            <param name="span">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Enumerator by passing the parameter <paramref name="span"/> to the constructor
            <see cref="M:System.Span`1.Enumerator.#ctor(System.Span{`0})"/>.
            </returns>
        </member>
        <member name="T:System.ReadOnlySpan`1">
            <summary>Provides a type-safe and memory-safe representation of a contiguous region of arbitrary memory.</summary>
            <remarks><para>This type delegates the responsibility of pinning the pointer to the consumer.</para></remarks>
            <typeparam name="T">The type of items in the <see cref="T:System.ReadOnlySpan`1"/>.</typeparam>
        </member>
        <member name="M:System.ReadOnlySpan`1.#ctor(System.Void*,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ReadOnlySpan`1"/> struct from a specified number of
            <typeparamref name="T"/> elements starting at a specified memory address.
            </summary>
            <param name="pointer">A pointer to the starting address of a specified number of T elements in memory.</param>
            <param name="length">The length of the buffer.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> is negative.</exception>
        </member>
        <member name="P:System.ReadOnlySpan`1.Item(System.Int32)">
            <summary>Gets the element at the specified zero-based index.</summary>
            <param name="index">The zero-based index of the element.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is less than zero or is greater than or equal to <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </exception>
        </member>
        <member name="P:System.ReadOnlySpan`1.Empty">
            <summary>Gets an empty <see cref="T:System.ReadOnlySpan`1"/> object.</summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.IsEmpty">
            <summary>Gets a value indicating whether the current <see cref="T:System.ReadOnlySpan`1"/> is empty.</summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Length">
            <summary>Gets the length of the current span.</summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Pointer">
            <summary>Gets the pointer representing the first element in the buffer.</summary>
            <remarks><para>
            This property does not normally exist, and is used as a workaround polyfill for <c>GetPinnableReference</c>.
            When using this property, ensure you have the appropriate preprocessors for using a fixed expression instead.
            </para><para>
            Due to a specific runtime issue, this property cannot be generic, as this causes some JITs
            (notably .NET Framework) to be upset from its metadata and refuse to load. It is therefore expected of the
            caller to cast the returned pointer every time if needed.
            </para></remarks>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Equality(System.ReadOnlySpan{`0},System.ReadOnlySpan{`0})">
            <summary>Returns a value that indicates whether two <see cref="T:System.ReadOnlySpan`1"/> objects are equal.</summary>
            <remarks><para>
            Two <see cref="T:System.ReadOnlySpan`1"/> objects are equal if they have the same length and the corresponding elements
            of <paramref name="left"/> and <paramref name="right"/> point to the same memory. Note that the test for
            equality does <i>not</i> attempt to determine whether the contents are equal.
            </para></remarks>
            <param name="left">The first span to compare.</param>
            <param name="right">The second span to compare.</param>
            <returns>
            <see langword="true"/> if the two <see cref="T:System.ReadOnlySpan`1"/> objects are equal;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Inequality(System.ReadOnlySpan{`0},System.ReadOnlySpan{`0})">
            <summary>
            Returns a value that indicates whether two <see cref="T:System.ReadOnlySpan`1"/> objects are not equal.
            </summary>
            <remarks><para>
            Two <see cref="T:System.ReadOnlySpan`1"/> objects are equal if they have the same length and the corresponding elements
            of <paramref name="left"/> and <paramref name="right"/> point to the same memory.
            </para></remarks>
            <param name="left">The first span to compare.</param>
            <param name="right">The second span to compare.</param>
            <returns>
            <see langword="true"/> if the two <see cref="T:System.ReadOnlySpan`1"/> objects are not equal;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.ReadOnlySpan`1.CopyTo(System.Span{`0})">
            <summary>
            Copies the contents of this <see cref="T:System.ReadOnlySpan`1"/> into a destination <see cref="T:System.Span`1"/>.
            </summary>
            <param name="destination">The destination <see cref="T:System.Span`1"/> object.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="destination"/> is shorter than the source <see cref="T:System.ReadOnlySpan`1"/>.
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.CopyTo(System.Collections.Generic.IList{`0})">
            <summary>Copies the contents of this <see cref="T:System.ReadOnlySpan`1"/> into a destination <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <param name="destination">The destination <see cref="T:System.Collections.Generic.IList`1"/> object.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="destination"/> is shorter than the source <see cref="T:System.ReadOnlySpan`1"/>.
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.ReadOnlySpan`1.TryCopyTo(System.Span{`0})">
            <summary>
            Attempts to copy the current <see cref="T:System.ReadOnlySpan`1"/> to a destination <see cref="T:System.Span`1"/>
            and returns a value that indicates whether the copy operation succeeded.
            </summary>
            <remarks><para>
            This method copies all of <c>source</c> to <paramref name="destination"/> even if
            <c>source</c> and <paramref name="destination"/> overlap.
            If <paramref name="destination"/> is shorter than the source <see cref="T:System.ReadOnlySpan`1"/>, this method returns
            <see langword="false"/>, and no data is written to <paramref name="destination"/>.
            </para></remarks>
            <param name="destination">The target of the copy operation.</param>
            <returns><see langword="true"/> if the copy operation succeeded; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:System.ReadOnlySpan`1.TryCopyTo(System.Collections.Generic.IList{`0})">
            <inheritdoc cref="M:System.ReadOnlySpan`1.TryCopyTo(System.Span{`0})"/>
        </member>
        <member name="M:System.ReadOnlySpan`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.ReadOnlySpan`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.ReadOnlySpan`1.GetEnumerator">
            <summary>Returns an enumerator of this <see cref="T:System.ReadOnlySpan`1"/>.</summary>
            <returns>An enumerator for this span.</returns>
        </member>
        <member name="M:System.ReadOnlySpan`1.Slice(System.Int32)">
            <summary>Forms a slice out of the current span that begins at a specified index.</summary>
            <param name="start">The index at which to begin the slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="start"/> is less than zero or greater than <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </exception>
            <returns>
            A span that consists of all elements of the current span from <paramref name="start"/> to the end of the span.
            </returns>
        </member>
        <member name="M:System.ReadOnlySpan`1.Slice(System.Int32,System.Int32)">
            <summary>Creates the slice of this buffer.</summary>
            <param name="start">The start of the slice from this buffer.</param>
            <param name="length">The length of the slice from this buffer.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">An out-of-range buffer is created.</exception>
            <returns>The <see cref="T:System.ReadOnlySpan`1"/> which is a slice of this buffer.</returns>
        </member>
        <member name="M:System.ReadOnlySpan`1.ToArray">
            <summary>Copies the contents of this span into a new array.</summary>
            <remarks><para>
            This method performs a heap allocation and therefore should be avoided if possible.
            Heap allocations are expected in APIs that work with arrays.
            Using such APIs is unavoidable if an alternative API overhead
            that takes a <see cref="T:System.ReadOnlySpan`1"/> does not exist.
            </para></remarks>
            <returns>An array containing the data in the current span.</returns>
        </member>
        <member name="T:System.ReadOnlySpan`1.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:System.Span`1"/>.</summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Enumerator.#ctor(System.ReadOnlySpan{`0})">
            <summary>Initializes a new instance of the <see cref="T:System.ReadOnlySpan`1.Enumerator"/> struct.</summary>
            <param name="span">The buffer to peek through.</param>
        </member>
        <member name="P:System.ReadOnlySpan`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current" />
        </member>
        <member name="M:System.ReadOnlySpan`1.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the collection.</summary>
            <returns>
            <see langword="true"/> if the enumerator was successfully advanced to the next element;
            <see langword="false"/> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="M:System.ReadOnlySpan`1.Enumerator.op_Implicit(System.ReadOnlySpan{`0})~System.ReadOnlySpan{`0}.Enumerator">
            <summary>
            Implicitly converts the parameter by creating the new instance of Enumerator by using the constructor
            <see cref="M:System.ReadOnlySpan`1.Enumerator.#ctor(System.ReadOnlySpan{`0})"/>.
            </summary>
            <param name="span">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Enumerator by passing the parameter <paramref name="span"/> to the constructor
            <see cref="M:System.ReadOnlySpan`1.Enumerator.#ctor(System.ReadOnlySpan{`0})"/>.
            </returns>
        </member>
        <member name="T:System.SpanDebugView`1">
            <summary>Represents a debug view to this span.</summary>
            <typeparam name="T">The type of element in the span.</typeparam>
        </member>
        <member name="M:System.SpanDebugView`1.#ctor(System.Span{`0})">
            <summary>Initializes a new instance of the <see cref="T:System.SpanDebugView`1"/> class.</summary>
            <param name="span">The span to collect.</param>
        </member>
        <member name="M:System.SpanDebugView`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>Initializes a new instance of the <see cref="T:System.SpanDebugView`1"/> class.</summary>
            <param name="span">The span to collect.</param>
        </member>
        <member name="P:System.SpanDebugView`1.Items">
            <summary>Gets the items of this span.</summary>
        </member>
        <member name="T:System.SpanHelpers">
            <summary>Unsafe functions to determine equality of buffers.</summary>
        </member>
        <member name="M:System.SpanHelpers.SequenceEqual``1(``0*,``0*,System.Int32)">
            <summary>Determines whether both pointers to buffers contain the same content.</summary>
            <typeparam name="T">The type of buffer.</typeparam>
            <param name="first">The first pointer to compare.</param>
            <param name="second">The second pointer to compare.</param>
            <param name="length">The length of both <paramref name="first"/> and <paramref name="second"/>.</param>
            <returns>
            The value <see langword="true"/> when both sequences have the same content, otherwise; <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.SpanHelpers.IndexOf``1(``0*,System.Int32,``0*,System.Int32)">
            <summary>Gets the index of where the smaller buffer matches the contents of the larger buffer.</summary>
            <typeparam name="T">The type of buffer.</typeparam>
            <param name="searchSpace">The larger buffer to compare from.</param>
            <param name="searchSpaceLength">The larger buffer's length.</param>
            <param name="value">The smaller buffer to compare against.</param>
            <param name="valueLength">The smaller buffer's length.</param>
            <returns>
            The index in which <paramref name="searchSpace"/> has the same content as <paramref name="value"/>.
            </returns>
        </member>
        <member name="M:System.SpanHelpers.IndexOf``1(``0*,``0,System.Int32)">
            <summary>Gets the index of where the item exists in the buffer.</summary>
            <typeparam name="T">The type of buffer.</typeparam>
            <param name="searchSpace">The buffer to compare from.</param>
            <param name="value">The item to compare to.</param>
            <param name="length">The buffer's length.</param>
            <returns>The index in which <paramref name="searchSpace"/> has <paramref name="value"/>.</returns>
        </member>
        <member name="M:System.SpanHelpers.IndexOfAny``1(``0*,System.Int32,``0*,System.Int32)">
            <summary>Gets the index of where the any of the items exist in the buffer.</summary>
            <typeparam name="T">The type of buffer.</typeparam>
            <param name="searchSpace">The buffer to compare from.</param>
            <param name="searchSpaceLength">The buffer's length.</param>
            <param name="value">The items to compare to.</param>
            <param name="valueLength">The items' length.</param>
            <returns>The index in which <paramref name="searchSpace"/> has any of <paramref name="value"/>.</returns>
        </member>
        <member name="T:System.TypeGetEnumUnderlyingTypePolyfill">
            <summary>Provides the polyfill to <c>Type.GetEnumUnderlyingType</c>.</summary>
        </member>
        <member name="M:System.TypeGetEnumUnderlyingTypePolyfill.GetEnumUnderlyingType(System.Type)">
            <summary>Returns the underlying type of the specified enumeration.</summary>
            <remarks><para>
            The <see cref="T:System.Enum"/> structure enables values to be represented as named constants.
            The data type of the enumeration's values is known as its underlying type. For example, the underlying type
            of the <see cref="T:System.DayOfWeek"/> enumeration, which consists of constants that represent each day of the week
            (<see cref="F:System.DayOfWeek.Monday"/>, <see cref="F:System.DayOfWeek.Tuesday"/>, and so on), is <see cref="T:System.Int32"/>.
            </para></remarks>
            <param name="enumType">The enumeration whose underlying type will be retrieved.</param>
            <exception cref="T:System.ArgumentException"><paramref name="enumType"/> is not an <see cref="T:System.Enum"/>.</exception>
            <returns>The underlying type of <paramref name="enumType"/>.</returns>
        </member>
        <member name="T:System.KeyValuePairDeconstructors">
            <summary>Allows a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> to be deconstructed, much like a tuple.</summary>
        </member>
        <member name="M:System.KeyValuePairDeconstructors.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>Deconstructs a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> into its components.</summary>
            <typeparam name="TKey">The key generic in the <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</typeparam>
            <typeparam name="TValue">The value generic in the <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</typeparam>
            <param name="kvp">The key value pair to deconstruct.</param>
            <param name="key">The key value to get assigned as the key value pair's key.</param>
            <param name="value">The key value to get assigned as the key value pair's value.</param>
        </member>
        <member name="T:System.IValueTupleInternal">
            <summary>
            Helper so we can call some tuple methods recursively without knowing the underlying types.
            </summary>
        </member>
        <member name="T:System.ValueTuple">
            <summary>
            The ValueTuple types (from arity 0 to 8) comprise the runtime implementation that underlies tuples in C# and struct tuples in F#.
            Aside from created via language syntax, they are most easily created via the ValueTuple.Create factory methods.
            The System.ValueTuple types differ from the System.Tuple types in that:
            - they are structs rather than classes,
            - they are mutable rather than readonly, and
            - their members (such as Item1, Item2, etc) are fields rather than properties.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is a <see cref="T:System.ValueTuple"/>.</returns>
        </member>
        <member name="M:System.ValueTuple.Equals(System.ValueTuple)">
            <summary>Returns a value indicating whether this instance is equal to a specified value.</summary>
            <param name="other">An instance to compare to this instance.</param>
            <returns>true if <paramref name="other"/> has the same value as this instance; otherwise, false.</returns>
        </member>
        <member name="M:System.ValueTuple.CompareTo(System.ValueTuple)">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>()</c>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Create">
            <summary>Creates a new struct 0-tuple.</summary>
            <returns>A 0-tuple.</returns>
        </member>
        <member name="M:System.ValueTuple.Create``1(``0)">
            <summary>Creates a new struct 1-tuple, or singleton.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <returns>A 1-tuple (singleton) whose value is (item1).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``2(``0,``1)">
            <summary>Creates a new struct 2-tuple, or pair.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <returns>A 2-tuple (pair) whose value is (item1, item2).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``3(``0,``1,``2)">
            <summary>Creates a new struct 3-tuple, or triple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <returns>A 3-tuple (triple) whose value is (item1, item2, item3).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``4(``0,``1,``2,``3)">
            <summary>Creates a new struct 4-tuple, or quadruple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <returns>A 4-tuple (quadruple) whose value is (item1, item2, item3, item4).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``5(``0,``1,``2,``3,``4)">
            <summary>Creates a new struct 5-tuple, or quintuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <returns>A 5-tuple (quintuple) whose value is (item1, item2, item3, item4, item5).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>Creates a new struct 6-tuple, or sextuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <returns>A 6-tuple (sextuple) whose value is (item1, item2, item3, item4, item5, item6).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>Creates a new struct 7-tuple, or septuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <returns>A 7-tuple (septuple) whose value is (item1, item2, item3, item4, item5, item6, item7).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Creates a new struct 8-tuple, or octuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <typeparam name="T8">The type of the eighth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <param name="item8">The value of the eighth component of the tuple.</param>
            <returns>An 8-tuple (octuple) whose value is (item1, item2, item3, item4, item5, item6, item7, item8).</returns>
        </member>
        <member name="T:System.ValueTuple`1">
            <summary>Represents a 1-tuple, or singleton, as a value type.</summary>
            <typeparam name="T1">The type of the tuple's only component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`1.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`1"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`1"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`1"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.ValueTuple{`0})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`1"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its field
            is equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.CompareTo(System.ValueTuple{`0})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`1.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`1.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`1"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1)</c>,
            where <see cref="F:System.ValueTuple`1.Item1"/> represents the value of <see cref="F:System.ValueTuple`1.Item1"/>. If the field is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`2">
            <summary>
            Represents a 2-tuple, or pair, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`2.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`2.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`2"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.Object)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified object.
             </summary>
             <param name="obj">The object to compare with this instance.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
             <list type="bullet">
                 <item><description>It is a <see cref="T:System.ValueTuple`2"/> value type.</description></item>
                 <item><description>Its components are of the same types as those of the current instance.</description></item>
                 <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.ValueTuple{`0,`1})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified <see cref="T:System.ValueTuple`2"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`2.CompareTo(System.ValueTuple{`0,`1})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`2.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`2.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`2"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2)</c>,
            where <see cref="F:System.ValueTuple`2.Item1"/> and <see cref="F:System.ValueTuple`2.Item2"/> represent the values of the <see cref="F:System.ValueTuple`2.Item1"/>
            and <see cref="F:System.ValueTuple`2.Item2"/> fields. If either field value is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`3">
            <summary>
            Represents a 3-tuple, or triple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`3.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's third component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`3"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`3"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.ValueTuple{`0,`1,`2})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`3"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.CompareTo(System.ValueTuple{`0,`1,`2})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`3.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`3.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`3"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`4">
            <summary>
            Represents a 4-tuple, or quadruple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`4.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's fourth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`4"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`4"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.ValueTuple{`0,`1,`2,`3})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`4"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.CompareTo(System.ValueTuple{`0,`1,`2,`3})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`4.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`4.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`4"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`5">
            <summary>
            Represents a 5-tuple, or quintuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`5.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fifth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`5"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`5"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`5"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`5.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`5.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`5"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`6">
            <summary>
            Represents a 6-tuple, or sixtuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`6.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's sixth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`6"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`6"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`6"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`6.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`6.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`6"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`7">
            <summary>
            Represents a 7-tuple, or sentuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`7.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's seventh component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`7"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`7"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`7"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`7.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`7.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`7"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`8">
            <summary>
            Represents an 8-tuple, or octuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
            <typeparam name="TRest">The type of the tuple's eighth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`8.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's seventh component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Rest">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's eighth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`8"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
            <param name="rest">The value of the tuple's eight component.</param>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`8"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`8"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`8.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`8.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`8"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7, Rest)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:Emik.Morsels.Allocator">
            <summary>Provides the method to convert spans.</summary>
        </member>
        <member name="M:Emik.Morsels.Allocator.Raw``1(System.Span{``0})">
            <inheritdoc cref="!:Raw&lt;T&gt;(T)" />
        </member>
        <member name="M:Emik.Morsels.Allocator.Raw``3(Emik.Morsels.SplitSpan{``0,``1,``2})">
            <inheritdoc cref="!:Raw&lt;T&gt;(T)" />
        </member>
        <member name="M:Emik.Morsels.Allocator.Raw``1(System.ReadOnlySpan{``0})">
            <inheritdoc cref="!:Raw&lt;T&gt;(T)" />
        </member>
        <member name="T:Emik.Morsels.EachSpan">
            <summary>Efficient LINQ-like methods for <see cref="T:System.ReadOnlySpan`1"/> and siblings.</summary>
        </member>
        <member name="M:Emik.Morsels.EachSpan.BreakableFor``1(System.Span{``0},System.Func{``0,Emik.Morsels.ControlFlow})">
            <inheritdoc cref="M:Emik.Morsels.EachWithControlFlow.BreakableFor``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Emik.Morsels.ControlFlow})"/>
        </member>
        <member name="M:Emik.Morsels.EachSpan.BreakableFor``1(System.ReadOnlySpan{``0},System.Func{``0,Emik.Morsels.ControlFlow})">
            <inheritdoc cref="M:Emik.Morsels.EachWithControlFlow.BreakableFor``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Emik.Morsels.ControlFlow})"/>
        </member>
        <member name="M:Emik.Morsels.EachSpan.BreakableFor``1(System.Span{``0},System.Func{``0,System.Int32,Emik.Morsels.ControlFlow})">
            <inheritdoc cref="M:Emik.Morsels.EachWithControlFlow.BreakableFor``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Emik.Morsels.ControlFlow})"/>
        </member>
        <member name="M:Emik.Morsels.EachSpan.BreakableFor``1(System.ReadOnlySpan{``0},System.Func{``0,System.Int32,Emik.Morsels.ControlFlow})">
            <inheritdoc cref="M:Emik.Morsels.EachWithControlFlow.BreakableFor``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Emik.Morsels.ControlFlow})"/>
        </member>
        <member name="M:Emik.Morsels.EachSpan.For``1(System.Span{``0},System.Action{``0})">
            <inheritdoc cref="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})"/>
        </member>
        <member name="M:Emik.Morsels.EachSpan.For``1(System.ReadOnlySpan{``0},System.Action{``0})">
            <inheritdoc cref="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})"/>
        </member>
        <member name="M:Emik.Morsels.EachSpan.For``1(System.Span{``0},System.Action{``0,System.Int32})">
            <inheritdoc cref="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})"/>
        </member>
        <member name="M:Emik.Morsels.EachSpan.For``1(System.ReadOnlySpan{``0},System.Action{``0,System.Int32})">
            <inheritdoc cref="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})"/>
        </member>
        <member name="T:Emik.Morsels.Span">
            <summary>Defines methods for callbacks with spans. Methods here do not clear the allocated buffer.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
        </member>
        <member name="T:Emik.Morsels.Span.To`1">
            <summary>Provides reinterpret span methods.</summary>
            <typeparam name="TTo">The type to convert to.</typeparam>
        </member>
        <member name="T:Emik.Morsels.Span.To`1.Is`1">
            <summary>
            Encapsulates the functionality to determine if a conversion is supported between two types.
            </summary>
            <typeparam name="TFrom">The type to convert from.</typeparam>
        </member>
        <member name="P:Emik.Morsels.Span.To`1.Is`1.Supported">
            <summary>
            Gets a value indicating whether the conversion between types
            <typeparamref name="TFrom"/> and <c>TTo</c> in <see cref="T:Emik.Morsels.Span.To`1"/> is defined.
            </summary>
        </member>
        <member name="P:Emik.Morsels.Span.To`1.Is`1.Error">
            <summary>
            Gets the error that occurs when converting between types would cause undefined behavior.
            </summary>
        </member>
        <member name="P:Emik.Morsels.Span.To`1.Unmanagable">
            <summary>Gets a value indicating whether the type is unmanaged.</summary>
        </member>
        <member name="M:Emik.Morsels.Span.To`1.From``1(System.ReadOnlySpan{``0})">
            <summary>
            Converts a <see cref="T:System.ReadOnlySpan`1"/> of type <typeparamref name="TFrom"/>
            to a <see cref="T:System.ReadOnlySpan`1"/> of type <c>TTo</c> in <see cref="T:Emik.Morsels.Span.To`1"/>.
            </summary>
            <typeparam name="TFrom">The type to convert from.</typeparam>
            <param name="source">The <see cref="T:System.ReadOnlySpan`1"/> to convert from.</param>
            <exception cref="T:System.NotSupportedException">
            Thrown when <see cref="P:Emik.Morsels.Span.To`1.Is`1.Supported"/> is <see langword="false"/>.
            </exception>
            <returns>
            The reinterpretation of the parameter <paramref name="source"/> from its original type
            <typeparamref name="TFrom"/> to the destination type <c>TTo</c> in <see cref="T:Emik.Morsels.Span.To`1"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Span.To`1.From``1(System.Span{``0})">
            <summary>
            Converts a <see cref="T:System.Span`1"/> of type <typeparamref name="TFrom"/>
            to a <see cref="T:System.Span`1"/> of type <c>TTo</c> in <see cref="T:Emik.Morsels.Span.To`1"/>.
            </summary>
            <typeparam name="TFrom">The type to convert from.</typeparam>
            <param name="source">The <see cref="T:System.Span`1"/> to convert from.</param>
            <exception cref="T:System.NotSupportedException">Thrown when conversion between the types TFrom and TTo is not supported.</exception>
            <returns>
            The reinterpretation of the parameter <paramref name="source"/> from its original
            type <typeparamref name="TFrom"/> to the destination type <c>TTo</c> in <see cref="T:Emik.Morsels.Span.To`1"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Span.SpanAction`1">
            <summary>A callback for a span.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <param name="span">The allocated span.</param>
        </member>
        <member name="T:Emik.Morsels.Span.SpanAction`2">
            <summary>A callback for a span with a reference parameter.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <param name="span">The allocated span.</param>
            <param name="param">The parameter.</param>
        </member>
        <member name="T:Emik.Morsels.Span.SpanActionReadOnlySpan`2">
            <summary>A callback for a span with a reference parameter that is also a span, but immutable.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <typeparam name="TParam">The inner type of the immutable span parameter.</typeparam>
            <param name="span">The allocated span.</param>
            <param name="param">The span parameter.</param>
        </member>
        <member name="T:Emik.Morsels.Span.SpanActionSpan`2">
            <summary>A callback for a span with a reference parameter that is also a span.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <typeparam name="TParam">The inner type of the span parameter.</typeparam>
            <param name="span">The allocated span.</param>
            <param name="param">The span parameter.</param>
        </member>
        <member name="T:Emik.Morsels.Span.SpanFunc`2">
            <summary>A callback for a span with a return value.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="span">The allocated span.</param>
            <returns>The returned value of this delegate.</returns>
        </member>
        <member name="T:Emik.Morsels.Span.SpanFunc`3">
            <summary>A callback for a span with a reference parameter with a return value.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="span">The allocated span.</param>
            <param name="param">The parameter.</param>
            <returns>The returned value of this delegate.</returns>
        </member>
        <member name="T:Emik.Morsels.Span.SpanFuncReadOnlySpan`3">
            <summary>A callback for a span with a reference parameter that is also a span, with a return value.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <typeparam name="TParam">The inner type of the immutable span parameter.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="span">The allocated span.</param>
            <param name="param">The span parameter.</param>
            <returns>The returned value of this delegate.</returns>
        </member>
        <member name="T:Emik.Morsels.Span.SpanFuncSpan`3">
            <summary>
            A callback for a span with a reference parameter that is also a span, but immutable, with a return value.
            </summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <typeparam name="TParam">The inner type of the immutable span parameter.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="span">The allocated span.</param>
            <param name="param">The span parameter.</param>
            <returns>The returned value of this delegate.</returns>
        </member>
        <member name="F:Emik.Morsels.Span.StackallocSize">
            <summary>The maximum size for the number of bytes a stack allocation will occur in this class.</summary>
            <remarks><para>
            Stack allocating arrays is an incredibly powerful tool that gets rid of a lot of the overhead that comes from
            instantiating arrays normally. Notably, that all classes (such as <see cref="T:System.Array"/> or <see cref="T:System.Collections.Generic.List`1"/>)
            are heap allocated, and moreover are garbage collected. This can put a strain in methods that are called often.
            </para><para>
            However, there isn't as much stack memory available as there is heap, which can cause a DoS (Denial of Service)
            vulnerability if you aren't careful. The methods in <c>Span</c> will automatically switch to unmanaged heap
            allocation if the type argument and length create an array that exceeds 1kiB (1024 bytes).
            </para></remarks>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate(System.Int32,Emik.Morsels.Span.SpanAction{System.Byte})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <param name="length">The length of the buffer.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``1(System.Int32,Emik.Morsels.Span.SpanAction{``0})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``1(System.Int32,``0,Emik.Morsels.Span.SpanAction{System.Byte,``0})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``2(System.Int32,``1,Emik.Morsels.Span.SpanAction{``0,``1})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``1(System.Int32,System.ReadOnlySpan{``0},Emik.Morsels.Span.SpanActionReadOnlySpan{System.Byte,``0})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TParam">The type of the parameter within the span.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``2(System.Int32,System.ReadOnlySpan{``1},Emik.Morsels.Span.SpanActionReadOnlySpan{``0,``1})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <typeparam name="TParam">The type of the parameter within the span.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``1(System.Int32,System.Span{``0},Emik.Morsels.Span.SpanActionSpan{System.Byte,``0})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TParam">The type of the parameter within the span.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``2(System.Int32,System.Span{``1},Emik.Morsels.Span.SpanActionSpan{``0,``1})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <typeparam name="TParam">The type of the parameter within the span.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.OffsetOf``1(System.ReadOnlySpan{``0}@,System.ReadOnlySpan{``0}@)">
            <inheritdoc cref="!:IndexOf&lt;T&gt;(ReadOnlySpan&lt;T&gt;, ref T)"/>
        </member>
        <member name="M:Emik.Morsels.Span.OffsetOf``1(System.Span{``0}@,System.ReadOnlySpan{``0}@)">
            <inheritdoc cref="!:IndexOf&lt;T&gt;(ReadOnlySpan&lt;T&gt;, ref T)"/>
        </member>
        <member name="M:Emik.Morsels.Span.UnsafelySetNullishTo``1(``0@,System.Byte)">
            <summary>Sets the reference to the address within the null range.</summary>
            <remarks><para>
            This is a highly unsafe function. The runtime reserves the first 2kiB for null-behaving values, which means a
            valid reference will never be within this range. This allows reference types to be a disjoint union of a valid
            reference, and an 11-bit number. Be careful with the values returned by this function: <see langword="null"/>
            comparisons can <see langword="return"/> <see langword="false"/>, but will behave as such.
            </para></remarks>
            <typeparam name="T">The type of the nullable reference type.</typeparam>
            <param name="reference">
            The resulting reference that contains the address of the parameter <paramref name="address"/>.
            </param>
            <param name="address">The number to set.</param>
        </member>
        <member name="M:Emik.Morsels.Span.IsStack``1(System.Int32)">
            <summary>Determines if a given length and type should be stack-allocated.</summary>
            <remarks><para>
            See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.
            </para></remarks>
            <typeparam name="T">The type of array.</typeparam>
            <param name="length">The amount of items.</param>
            <returns>
            The value <see langword="true"/>, if it should be stack-allocated, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Span.InBytes``1(System.Int32)">
            <summary>Gets the byte length needed to allocate the current length, used in <see cref="M:Emik.Morsels.Span.IsStack``1(System.Int32)"/>.</summary>
            <typeparam name="T">The type of array.</typeparam>
            <param name="length">The amount of items.</param>
            <returns>
            The value <see langword="true"/>, if it should be stack-allocated, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Span.ToAddress(System.Object)">
            <summary>Returns the memory address of a given reference object.</summary>
            <remarks><para>The value is not pinned; do not read values from this location.</para></remarks>
            <param name="reference">The reference <see cref="T:System.Object"/> for which to get the address.</param>
            <returns>The memory address of the reference object.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Ref``1(``0@)">
            <summary>Creates a new <see cref="T:System.Span`1"/> of length 1 around the specified reference.</summary>
            <typeparam name="T">The type of <paramref name="reference"/>.</typeparam>
            <param name="reference">A reference to data.</param>
            <returns>The created span over the parameter <paramref name="reference"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Ref``2(``0@)">
            <summary>Creates a new reinterpreted <see cref="T:System.Span`1"/> over the specified reference.</summary>
            <typeparam name="TFrom">The source type.</typeparam>
            <typeparam name="TTo">The destination type.</typeparam>
            <param name="reference">A reference to data.</param>
            <returns>The created span over the parameter <paramref name="reference"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``1(System.Int32,Emik.Morsels.Span.SpanFunc{System.Byte,``0})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``2(System.Int32,Emik.Morsels.Span.SpanFunc{``0,``1})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``2(System.Int32,``0,Emik.Morsels.Span.SpanFunc{System.Byte,``0,``1})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``3(System.Int32,``1,Emik.Morsels.Span.SpanFunc{``0,``1,``2})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``2(System.Int32,System.ReadOnlySpan{``0},Emik.Morsels.Span.SpanFuncReadOnlySpan{System.Byte,``0,``1})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TParam">The type of the parameter within the span.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``3(System.Int32,System.ReadOnlySpan{``1},Emik.Morsels.Span.SpanFuncReadOnlySpan{``0,``1,``2})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <typeparam name="TParam">The type of the parameter within the span.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``2(System.Int32,System.Span{``0},Emik.Morsels.Span.SpanFuncSpan{System.Byte,``0,``1})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TParam">The type of the parameter within the span.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``3(System.Int32,System.Span{``1},Emik.Morsels.Span.SpanFuncSpan{``0,``1,``2})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <typeparam name="TParam">The type of the parameter within the span.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.SpanIndexers">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.Deconstruct``1(System.Span{``0},``0@,System.Span{``0}@)">
            <summary>Separates the head from the tail of a <see cref="T:System.Span`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="span">The span to split.</param>
            <param name="head">The first element of the parameter <paramref name="span"/>.</param>
            <param name="tail">The rest of the parameter <paramref name="span"/>.</param>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.Deconstruct``1(System.ReadOnlySpan{``0},``0@,System.ReadOnlySpan{``0}@)">
            <summary>Separates the head from the tail of a <see cref="T:System.ReadOnlySpan`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="span">The span to split.</param>
            <param name="head">The first element of the parameter <paramref name="span"/>.</param>
            <param name="tail">The rest of the parameter <paramref name="span"/>.</param>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.IndexOf``1(System.ReadOnlySpan{``0},``0@)">
            <summary>Gets the index of an element of a given <see cref="T:System.Span`1"/> from its reference.</summary>
            <typeparam name="T">The type if items in the input <see cref="T:System.Span`1"/>.</typeparam>
            <param name="span">The input <see cref="T:System.Span`1"/> to calculate the index for.</param>
            <param name="value">The reference to the target item to get the index for.</param>
            <returns>The index of <paramref name="value"/> within <paramref name="span"/>, or <c>-1</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.IndexOf``1(System.Span{``0},``0@)">
            <inheritdoc cref="M:Emik.Morsels.SpanIndexers.IndexOf``1(System.ReadOnlySpan{``0},``0@)"/>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:Emik.Morsels.SpanIndexers.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})"/>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the first index of any of the specified values similar
            to calling IndexOf several times with the logical OR operator.
            </summary>
            <typeparam name="T">The type of the span and values.</typeparam>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
            <returns>The first index of the occurrence of any of the values in the span. If not found, returns -1.</returns>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.Nth``1(System.ReadOnlySpan{``0},System.Range)">
            <summary>Gets the specific slice from the span.</summary>
            <typeparam name="T">The type of item in the span.</typeparam>
            <param name="span">The <see cref="T:System.ReadOnlySpan`1"/> to get an item from.</param>
            <param name="range">The index to get.</param>
            <returns>A slice from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.Nth``1(System.Span{``0},System.Range)">
            <summary>Gets the specific slice from the span.</summary>
            <typeparam name="T">The type of item in the span.</typeparam>
            <param name="span">The <see cref="T:System.Span`1"/> to get an item from.</param>
            <param name="range">The index to get.</param>
            <returns>A slice from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.Nth``1(System.ReadOnlySpan{``0},System.Int32)">
            <summary>Gets a specific item from the span.</summary>
            <typeparam name="T">The type of item in the span.</typeparam>
            <param name="span">The <see cref="T:System.ReadOnlySpan`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.Nth``1(System.ReadOnlySpan{``0},System.Index)">
            <summary>Gets a specific item from the span.</summary>
            <typeparam name="T">The type of item in the span.</typeparam>
            <param name="span">The <see cref="T:System.ReadOnlySpan`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.NthLast``1(System.ReadOnlySpan{``0},System.Int32)">
            <summary>Gets a specific item from the span.</summary>
            <typeparam name="T">The type of item in the span.</typeparam>
            <param name="span">The <see cref="T:System.ReadOnlySpan`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.Nth``1(System.Span{``0},System.Int32)">
            <summary>Gets a specific item from the span.</summary>
            <typeparam name="T">The type of item in the span.</typeparam>
            <param name="span">The <see cref="T:System.Span`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.Nth``1(System.Span{``0},System.Index)">
            <summary>Gets a specific item from the span.</summary>
            <typeparam name="T">The type of item in the span.</typeparam>
            <param name="span">The <see cref="T:System.Span`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SpanIndexers.NthLast``1(System.Span{``0},System.Int32)">
            <summary>Gets a specific item from the span.</summary>
            <typeparam name="T">The type of item in the span.</typeparam>
            <param name="span">The <see cref="T:System.Span`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.SpanQueries">
            <summary>Efficient LINQ-like methods for <see cref="T:System.ReadOnlySpan`1"/> and siblings.</summary>
            <summary>Efficient LINQ-like methods for <see cref="T:System.ReadOnlySpan`1"/> and siblings.</summary>
            <summary>Efficient LINQ-like methods for <see cref="T:System.ReadOnlySpan`1"/> and siblings.</summary>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Aggregate``1(System.Span{``0},System.Func{``0,``0,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Aggregate``1(System.ReadOnlySpan{``0},System.Func{``0,``0,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Aggregate``2(System.Span{``0},``1,System.Func{``1,``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Aggregate``2(System.ReadOnlySpan{``0},``1,System.Func{``1,``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Aggregate``3(System.Span{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Aggregate``3(System.ReadOnlySpan{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.IsNumericPrimitive``1">
            <summary>Determines whether the type is a numeric primitive.</summary>
            <typeparam name="T">The type to test.</typeparam>
            <returns>Whether the type parameter <typeparamref name="T"/> is a primitive representing a number.</returns>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.All``1(System.Span{``0},System.Predicate{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.All``1(System.ReadOnlySpan{``0},System.Predicate{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Any``1(System.Span{``0},System.Predicate{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Any``1(System.ReadOnlySpan{``0},System.Predicate{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Select``1(System.Span{``0},System.Func{``0,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Select``1(System.Span{``0},System.Func{``0,System.Int32,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.SkipWhile``1(System.Span{``0},System.Predicate{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.SkipWhile``1(System.ReadOnlySpan{``0},System.Predicate{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.TakeWhile``1(System.Span{``0},System.Predicate{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.TakeWhile``1(System.ReadOnlySpan{``0},System.Predicate{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.SpanQueries.Where``1(System.Span{``0},System.Predicate{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="T:Emik.Morsels.SpanSimdQueries">
            <inheritdoc cref="T:Emik.Morsels.SpanSimdQueries"/>
        </member>
        <member name="M:Emik.Morsels.SpanSimdQueries.Max``1(System.Span{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Emik.Morsels.SpanSimdQueries.Max``1(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Emik.Morsels.SpanSimdQueries.Min``1(System.Span{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Emik.Morsels.SpanSimdQueries.Min``1(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Emik.Morsels.SpanSimdQueries.Max``2(System.Span{``0},System.Converter{``0,``1})">
            <inheritdoc cref="!:Enumerable.MaxBy&lt;TSource, TKey&gt;(IEnumerable&lt;TSource&gt;, Func&lt;TSource, TKey&gt;)"/>
        </member>
        <member name="M:Emik.Morsels.SpanSimdQueries.Max``2(System.ReadOnlySpan{``0},System.Converter{``0,``1})">
            <inheritdoc cref="!:Enumerable.MaxBy&lt;TSource, TKey&gt;(IEnumerable&lt;TSource&gt;, Func&lt;TSource, TKey&gt;)"/>
        </member>
        <member name="M:Emik.Morsels.SpanSimdQueries.Min``2(System.Span{``0},System.Converter{``0,``1})">
            <inheritdoc cref="!:Enumerable.MinBy&lt;TSource, TKey&gt;(IEnumerable&lt;TSource&gt;, Func&lt;TSource, TKey&gt;)"/>
        </member>
        <member name="M:Emik.Morsels.SpanSimdQueries.Min``2(System.ReadOnlySpan{``0},System.Converter{``0,``1})">
            <inheritdoc cref="!:Enumerable.MinBy&lt;TSource, TKey&gt;(IEnumerable&lt;TSource&gt;, Func&lt;TSource, TKey&gt;)"/>
        </member>
        <member name="T:Emik.Morsels.SplitSpanFactory">
            <summary>Methods to split spans into multiple spans.</summary>
        </member>
        <member name="T:Emik.Morsels.SplitSpanFactory.MatchAll">
            <summary>The type that indicates to match all elements.</summary>
        </member>
        <member name="T:Emik.Morsels.SplitSpanFactory.MatchAny">
            <summary>The type that indicates to match any element.</summary>
        </member>
        <member name="T:Emik.Morsels.SplitSpanFactory.MatchOne">
            <summary>The type that indicates to match exactly one element.</summary>
        </member>
        <member name="M:Emik.Morsels.SplitSpanFactory.SplitAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Splits a span by the specified separator.</summary>
            <typeparam name="T">The type of element from the span.</typeparam>
            <param name="span">The span to split.</param>
            <param name="separator">The separator.</param>
            <returns>The enumerable object that references the parameter <paramref name="span"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpanFactory.SplitAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:Emik.Morsels.SplitSpanFactory.SplitAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})"/>
        </member>
        <member name="M:Emik.Morsels.SplitSpanFactory.SplitAll``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>Splits a span by the specified separator.</summary>
            <typeparam name="T">The type of element from the span.</typeparam>
            <param name="span">The span to split.</param>
            <param name="separator">The separator.</param>
            <returns>The enumerable object that references the parameter <paramref name="span"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpanFactory.SplitAll``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:Emik.Morsels.SplitSpanFactory.SplitAll``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})"/>
        </member>
        <member name="T:Emik.Morsels.SplitSpan`3">
            <summary>Represents a split entry.</summary>
            <typeparam name="TBody">The type of element from the span.</typeparam>
            <typeparam name="TSeparator">The type of separator.</typeparam>
            <typeparam name="TStrategy">The strategy for splitting elements.</typeparam>
            <param name="body">The line to split.</param>
            <param name="separator">The separator.</param>
            <inheritdoc cref="T:Emik.Morsels.SplitSpan`3"/>
            <inheritdoc cref="T:Emik.Morsels.SplitSpan`3"/>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.#ctor(System.ReadOnlySpan{`0},System.ReadOnlySpan{`1})">
            <summary>Represents a split entry.</summary>
            <typeparam name="TBody">The type of element from the span.</typeparam>
            <typeparam name="TSeparator">The type of separator.</typeparam>
            <typeparam name="TStrategy">The strategy for splitting elements.</typeparam>
            <param name="body">The line to split.</param>
            <param name="separator">The separator.</param>
        </member>
        <member name="T:Emik.Morsels.SplitSpan`3.Accumulator`1">
            <summary>Represents the accumulator function for the enumeration of this type.</summary>
            <typeparam name="TAccumulator">The type of the accumulator value.</typeparam>
            <param name="accumulator">The accumulator.</param>
            <param name="next">The next slice from the enumeration.</param>
            <returns>The final accumulator value.</returns>
        </member>
        <member name="T:Emik.Morsels.SplitSpan`3.RefAccumulator`1">
            <inheritdoc cref="T:Emik.Morsels.SplitSpan`3.Accumulator`1"/>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.#ctor(System.ReadOnlySpan{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SplitSpan`3"/> struct.</summary>
            <param name="body">The line to split.</param>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.Error">
            <summary>Gets the error thrown by this type.</summary>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.Body">
            <summary>Gets the line to split.</summary>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.First">
            <summary>Gets the first element.</summary>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.Last">
            <summary>Gets the last element.</summary>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.Separator">
            <summary>Gets the separator.</summary>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.Single">
            <summary>Gets the single element.</summary>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.Item(System.Int32)">
            <summary>Gets the specified index.</summary>
            <param name="index">The index to get.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameter <paramref name="index"/> is negative.</exception>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.Item(System.Index)">
            <summary>Gets the specified index.</summary>
            <param name="index">The index to get.</param>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.op_Equality(Emik.Morsels.SplitSpan{`0,`1,`2}@,Emik.Morsels.SplitSpan{`0,`1,`2}@)">
            <summary>Determines whether both splits are equal.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether both splits are equal.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.op_Inequality(Emik.Morsels.SplitSpan{`0,`1,`2}@,Emik.Morsels.SplitSpan{`0,`1,`2}@)">
            <summary>Determines whether both splits are not equal.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether both splits are not equal.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Deconstruct(System.ReadOnlySpan{`0}@,Emik.Morsels.SplitSpan{`0,`1,`2}@)">
            <summary>Separates the head from the tail of this <see cref="T:Emik.Morsels.SplitSpan`3"/>.</summary>
            <param name="head">The first element of this enumeration.</param>
            <param name="tail">The rest of this enumeration.</param>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ConcatEqual``2(Emik.Morsels.SplitSpan{`0,``0,``1}@)">
            <summary>Determines whether both splits are eventually equal when concatenating all slices.</summary>
            <typeparam name="TOtherSeparator">The type of separator for the other side.</typeparam>
            <typeparam name="TOtherStrategy">The strategy for splitting for the other side.</typeparam>
            <param name="other">The other side.</param>
            <returns>
            The value <paramref langword="true"/> if both sequences are equal, otherwise; <paramref langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Equals``1(Emik.Morsels.SplitSpan{`0,`1,``0}@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)" />
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.SequenceEqual``2(Emik.Morsels.SplitSpan{`0,``0,``1}@)">
            <summary>Determines whether both splits are equal.</summary>
            <typeparam name="TOtherSeparator">The type of separator for the right-hand side.</typeparam>
            <typeparam name="TOtherStrategy">The strategy for splitting elements for the right-hand side.</typeparam>
            <param name="other">The side to compare to.</param>
            <returns>
            The value <paramref langword="true"/> if both sequences are equal, otherwise; <paramref langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Count">
            <summary>Computes the length.</summary>
            <returns>The length.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ToString(System.ReadOnlySpan{`0})">
            <summary>
            Converts the elements of the collection to a <see cref="T:System.String"/> representation,
            using the specified divider between elements.
            </summary>
            <param name="divider">The divider to insert between elements.</param>
            <returns>A <see cref="T:System.String"/> representation of the collection.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ToString(System.ReadOnlySpan{`0}@)">
            <inheritdoc cref="M:Emik.Morsels.SplitSpan`3.ToString(System.ReadOnlySpan{`0})"/>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ToStringArray">
            <summary>Copies the values to a new <see cref="T:System.String"/> <see cref="T:System.Array"/>.</summary>
            <returns>The <see cref="T:System.String"/> <see cref="T:System.Array"/> containing the copied values of this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Aggregate``1(``0,Emik.Morsels.SplitSpan{`0,`1,`2}.Accumulator{``0})">
            <summary>Gets the accumulated result of a set of callbacks where each element is passed in.</summary>
            <typeparam name="TAccumulator">The type of the accumulator value.</typeparam>
            <param name="seed">The accumulator.</param>
            <param name="func">An accumulator function to be invoked on each element.</param>
            <returns>The accumulated result of <paramref name="seed"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Aggregate``1(``0,Emik.Morsels.SplitSpan{`0,`1,`2}.RefAccumulator{``0})">
            <inheritdoc cref="M:Emik.Morsels.SplitSpan`3.Aggregate``1(``0,Emik.Morsels.SplitSpan{`0,`1,`2}.Accumulator{``0})"/>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ToArray">
            <summary>Copies the values to a new flattened array.</summary>
            <returns>The array containing the copied values of this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ToArray(System.ReadOnlySpan{`0})">
            <summary>Copies the values to a new flattened array.</summary>
            <param name="divider">The separator between each element.</param>
            <returns>The array containing the copied values of this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ToArray(System.ReadOnlySpan{`0}@)">
            <inheritdoc cref="M:Emik.Morsels.SplitSpan`3.ToArray(System.ReadOnlySpan{`0})"/>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ToArrays">
            <summary>Copies the values to a new nested array.</summary>
            <returns>The nested array containing the copied values of this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.GetEnumerator">
            <inheritdoc cref="M:System.Collections.IEnumerable.GetEnumerator"/>
        </member>
        <member name="T:Emik.Morsels.SplitSpan`3.Enumerator">
            <summary>
            Represents the enumeration object that views <see cref="T:Emik.Morsels.SplitSpan`3"/>.
            </summary>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Enumerator.#ctor(System.ReadOnlySpan{`0},System.ReadOnlySpan{`1})">
            <summary>
            Represents the enumeration object that views <see cref="T:Emik.Morsels.SplitSpan`3"/>.
            </summary>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Enumerator.#ctor(System.ReadOnlySpan{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SplitSpan`3.Enumerator"/> struct.</summary>
            <param name="body">The body.</param>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Enumerator.#ctor(Emik.Morsels.SplitSpan{`0,`1,`2})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SplitSpan`3.Enumerator"/> struct.</summary>
            <param name="split">The enumerable to enumerate.</param>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.Enumerator.Body">
            <inheritdoc cref="P:Emik.Morsels.SplitSpan`3.Body"/>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.Enumerator.Separator">
            <inheritdoc cref="P:Emik.Morsels.SplitSpan`3.Separator"/>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Enumerator.Move(System.ReadOnlySpan{`1}@,System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0}@)">
            <summary>Performs one step of an enumeration over the provided spans.</summary>
            <param name="sep">The separator span.</param>
            <param name="body">The span that contains the current state of the enumeration.</param>
            <param name="current">The current span.</param>
            <returns>
            <see langword="true"/> if a step was able to be performed successfully;
            <see langword="false"/> if the end of the collection is reached.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Enumerator.EqualityMoveNext``2(Emik.Morsels.SplitSpan{`0,``0,``1}.Enumerator@,System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0}@,System.Boolean@)">
            <summary>
            Checks if two sequences of type <see name="TBody"/> are equal while iterating through the next element.
            </summary>
            <typeparam name="TOtherSeparator">The type of separator used in the other sequence.</typeparam>
            <typeparam name="TOtherStrategy">The strategy used for splitting the other sequence.</typeparam>
            <param name="other">The enumerator for the other sequence.</param>
            <param name="reader">The <see cref="T:System.ReadOnlySpan`1"/> representing this sequence.</param>
            <param name="otherReader">The <see cref="T:System.ReadOnlySpan`1"/> representing the other sequence.</param>
            <param name="ret">
            Output parameter indicating if the sequences are equal.
            Note that this value is undefined if <see langword="false"/> is returned.
            </param>
            <returns>
            The value <see langword="true"/> if enumeration should be stopped; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Enumerator.op_Implicit(System.ReadOnlySpan{`0})~Emik.Morsels.SplitSpan{`0,`1,`2}.Enumerator">
            <summary>
            Implicitly converts the parameter by creating the new instance of Enumerator by using the constructor
            <see cref="M:Emik.Morsels.SplitSpan`3.Enumerator.#ctor(System.ReadOnlySpan{`0})"/>.
            </summary>
            <param name="body">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Enumerator by passing the parameter <paramref name="body"/> to the constructor
            <see cref="M:Emik.Morsels.SplitSpan`3.Enumerator.#ctor(System.ReadOnlySpan{`0})"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.Enumerator.op_Implicit(Emik.Morsels.SplitSpan{`0,`1,`2})~Emik.Morsels.SplitSpan{`0,`1,`2}.Enumerator">
            <summary>
            Implicitly converts the parameter by creating the new instance of Enumerator by using the constructor
            <see cref="M:Emik.Morsels.SplitSpan`3.Enumerator.#ctor(Emik.Morsels.SplitSpan{`0,`1,`2})"/>.
            </summary>
            <param name="split">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Enumerator by passing the parameter <paramref name="split"/> to the constructor
            <see cref="M:Emik.Morsels.SplitSpan`3.Enumerator.#ctor(Emik.Morsels.SplitSpan{`0,`1,`2})"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.GetReversedEnumerator">
            <inheritdoc cref="M:System.Collections.IEnumerable.GetEnumerator"/>
        </member>
        <member name="T:Emik.Morsels.SplitSpan`3.ReversedEnumerator">
            <summary>
            Represents the enumeration object that views <see cref="T:Emik.Morsels.SplitSpan`3"/>.
            </summary>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.#ctor(System.ReadOnlySpan{`0},System.ReadOnlySpan{`1})">
            <summary>
            Represents the enumeration object that views <see cref="T:Emik.Morsels.SplitSpan`3"/>.
            </summary>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.#ctor(System.ReadOnlySpan{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SplitSpan`3.ReversedEnumerator"/> struct.</summary>
            <param name="body">The body.</param>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.#ctor(Emik.Morsels.SplitSpan{`0,`1,`2})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SplitSpan`3.ReversedEnumerator"/> struct.</summary>
            <param name="split">The enumerable to enumerate.</param>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.ReversedEnumerator.Body">
            <inheritdoc cref="P:Emik.Morsels.SplitSpan`3.Body"/>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.ReversedEnumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:Emik.Morsels.SplitSpan`3.ReversedEnumerator.Separator">
            <inheritdoc cref="P:Emik.Morsels.SplitSpan`3.Separator"/>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.MoveNext(System.ReadOnlySpan{`1}@,System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0}@)">
            <summary>Performs one step of an enumeration over the provided spans.</summary>
            <param name="sep">The separator span.</param>
            <param name="body">The span that contains the current state of the enumeration.</param>
            <param name="current">The current span.</param>
            <returns>
            <see langword="true"/> if a step was able to be performed successfully;
            <see langword="false"/> if the end of the collection is reached.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.op_Implicit(System.ReadOnlySpan{`0})~Emik.Morsels.SplitSpan{`0,`1,`2}.ReversedEnumerator">
            <summary>
            Implicitly converts the parameter by creating the new instance of ReversedEnumerator by using the constructor
            <see cref="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.#ctor(System.ReadOnlySpan{`0})"/>.
            </summary>
            <param name="body">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of ReversedEnumerator by passing the parameter <paramref name="body"/> to the constructor
            <see cref="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.#ctor(System.ReadOnlySpan{`0})"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.op_Implicit(Emik.Morsels.SplitSpan{`0,`1,`2})~Emik.Morsels.SplitSpan{`0,`1,`2}.ReversedEnumerator">
            <summary>
            Implicitly converts the parameter by creating the new instance of ReversedEnumerator by using the constructor
            <see cref="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.#ctor(Emik.Morsels.SplitSpan{`0,`1,`2})"/>.
            </summary>
            <param name="split">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of ReversedEnumerator by passing the parameter <paramref name="split"/> to the constructor
            <see cref="M:Emik.Morsels.SplitSpan`3.ReversedEnumerator.#ctor(Emik.Morsels.SplitSpan{`0,`1,`2})"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitSpan`3.op_Implicit(System.ReadOnlySpan{`0})~Emik.Morsels.SplitSpan{`0,`1,`2}">
            <summary>
            Implicitly converts the parameter by creating the new instance of SplitSpan{TBody, TSeparator, TStrategy} by using the constructor
            <see cref="M:Emik.Morsels.SplitSpan`3.#ctor(System.ReadOnlySpan{`0})"/>.
            </summary>
            <param name="body">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of SplitSpan{TBody, TSeparator, TStrategy} by passing the parameter <paramref name="body"/> to the constructor
            <see cref="M:Emik.Morsels.SplitSpan`3.#ctor(System.ReadOnlySpan{`0})"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Two`1">
            <summary>
            Represents two inlined elements, equivalent to <see cref="T:System.ValueTuple`2"/>,
            but the memory layout is guaranteed to be sequential, and both elements are of the same type.
            </summary>
            <remarks><para>
            The name of this type may or may not derive from a specific algebralien from a show...
            </para></remarks>
            <typeparam name="T">The type of item to store.</typeparam>
            <param name="left">The first item.</param>
            <param name="right">The second item.</param>
        </member>
        <member name="M:Emik.Morsels.Two`1.#ctor(`0,`0)">
            <summary>
            Represents two inlined elements, equivalent to <see cref="T:System.ValueTuple`2"/>,
            but the memory layout is guaranteed to be sequential, and both elements are of the same type.
            </summary>
            <remarks><para>
            The name of this type may or may not derive from a specific algebralien from a show...
            </para></remarks>
            <typeparam name="T">The type of item to store.</typeparam>
            <param name="left">The first item.</param>
            <param name="right">The second item.</param>
        </member>
        <member name="F:Emik.Morsels.Two`1.First">
            <summary>The stored items.</summary>
        </member>
        <member name="F:Emik.Morsels.Two`1.Second">
            <summary>The stored items.</summary>
        </member>
        <member name="P:Emik.Morsels.Two`1.Item(System.Boolean)">
            <summary>Applies the indexer and returns the instance according to the value.</summary>
            <param name="back">Whether or not to return <see cref="F:Emik.Morsels.Two`1.Second"/>.</param>
        </member>
        <member name="P:Emik.Morsels.Two`1.Tuple">
            <inheritdoc cref="M:Emik.Morsels.Two`1.op_Implicit(Emik.Morsels.Two{`0})~System.ValueTuple{`0,`0}"/>
        </member>
        <member name="M:Emik.Morsels.Two`1.Deconstruct(`0@,`0@)">
            <summary>Deconstructs this instance into the two inlined elements.</summary>
            <param name="first">The first item.</param>
            <param name="second">The second item.</param>
        </member>
        <member name="M:Emik.Morsels.Two`1.op_Equality(Emik.Morsels.Two{`0},Emik.Morsels.Two{`0})">
            <summary>Determines whether both instances contain the same two values.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether both instances have the same two values.</returns>
        </member>
        <member name="M:Emik.Morsels.Two`1.op_Inequality(Emik.Morsels.Two{`0},Emik.Morsels.Two{`0})">
            <summary>Determines whether both instances contain different values.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether both instances have different values.</returns>
        </member>
        <member name="M:Emik.Morsels.Two`1.op_LessThan(Emik.Morsels.Two{`0},Emik.Morsels.Two{`0})">
            <summary>Determines whether the left instance is less than the right.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether the left instance is less than the right.</returns>
        </member>
        <member name="M:Emik.Morsels.Two`1.op_LessThanOrEqual(Emik.Morsels.Two{`0},Emik.Morsels.Two{`0})">
            <summary>Determines whether the left instance is equal to or less than the right.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether the left instance is equal to or less than the right.</returns>
        </member>
        <member name="M:Emik.Morsels.Two`1.op_GreaterThan(Emik.Morsels.Two{`0},Emik.Morsels.Two{`0})">
            <summary>Determines whether the left instance is greater than the right.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether the left instance is greater than the right.</returns>
        </member>
        <member name="M:Emik.Morsels.Two`1.op_GreaterThanOrEqual(Emik.Morsels.Two{`0},Emik.Morsels.Two{`0})">
            <summary>Determines whether the left instance is equal to or greater than the right.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether the left instance is equal to or greater than the right.</returns>
        </member>
        <member name="M:Emik.Morsels.Two`1.op_Implicit(Emik.Morsels.Two{`0})~System.ValueTuple{`0,`0}">
            <summary>Implicitly converts the <see cref="T:Emik.Morsels.Two`1"/> into the <see cref="T:System.ValueTuple`2"/>.</summary>
            <param name="two">The <see cref="T:Emik.Morsels.Two`1"/> to convert.</param>
            <returns>The equivalent tuple layout of the parameter <paramref name="two"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Two`1.op_Implicit(System.ValueTuple{`0,`0})~Emik.Morsels.Two{`0}">
            <summary>Implicitly converts the <see cref="T:System.ValueTuple`2"/> into the <see cref="T:Emik.Morsels.Two`1"/>.</summary>
            <param name="tuple">The <see cref="T:System.ValueTuple`2"/> to convert.</param>
            <returns>The equivalent sequential layout of the parameter <paramref name="tuple"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Two`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Emik.Morsels.Two`1.Equals(Emik.Morsels.Two{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Two`1.CompareTo(Emik.Morsels.Two{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Two`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.CircularFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.CircularList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.CircularFactory.ToCircularLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.CircularList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.CircularList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.CircularList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.CircularList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where elements are treated as circular;
            indices wrap around and will therefore never be out of range.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where elements are treated as circular;
            indices wrap around and will therefore never be out of range.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.ClippedFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.ClippedList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.ClippedFactory.ToClippedLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.ClippedList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.ClippedList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.ClippedList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.ClippedList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where indices are always clamped and therefore never be out of range.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where indices are always clamped and therefore never be out of range.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.GuardedFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.GuardedList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.GuardedFactory.ToGuardedLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.GuardedList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.GuardedList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.GuardedList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.GuardedList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where applying an index will always result in an optional value;
            an out of range value will always give the <see langword="default"/> value.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where applying an index will always result in an optional value;
            an out of range value will always give the <see langword="default"/> value.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Add(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Clear">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Clear"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.System#Collections#Generic#ICollection{T}#Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.IndexOf(`0)">
            <inheritdoc cref="M:System.Collections.Generic.IList`1.IndexOf(`0)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.MatrixFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Matrix`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.MatrixFactory.AsMatrix``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:Emik.Morsels.Matrix`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
            <param name="iterator">The collection to turn into a <see cref="T:Emik.Morsels.Matrix`1"/>.</param>
            <param name="countPerList">The length per count.</param>
            <returns>A <see cref="T:Emik.Morsels.Matrix`1"/> that wraps the parameter <paramref name="iterator"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.MatrixFactory.AsMatrix``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:Emik.Morsels.Matrix`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
            <param name="iterator">The collection to turn into a <see cref="T:Emik.Morsels.Matrix`1"/>.</param>
            <param name="countPerList">The length per count.</param>
            <returns>A <see cref="T:Emik.Morsels.Matrix`1"/> that wraps the parameter <paramref name="iterator"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Matrix`1">
            <summary>Maps a 1-dimensional collection as 2-dimensional.</summary>
            <typeparam name="T">The type of item within the list.</typeparam>
        </member>
        <member name="T:Emik.Morsels.Matrix`1.Slice">
            <summary>Represents a slice of a matrix.</summary>
            <param name="matrix">The matrix to reference.</param>
            <param name="ordinal">The first index of the matrix.</param>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.#ctor(Emik.Morsels.Matrix{`0},System.Int32)">
            <summary>Represents a slice of a matrix.</summary>
            <param name="matrix">The matrix to reference.</param>
            <param name="ordinal">The first index of the matrix.</param>
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Slice.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Slice.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Slice.Count">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.#ctor(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Matrix`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
            <param name="countPerList">The length per count.</param>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.#ctor(System.Collections.Generic.IList{`0},System.Func{System.Int32})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Matrix`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
            <param name="countPerList">The length per count.</param>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.#ctor(System.Func{System.Collections.Generic.IList{`0}},System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Matrix`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
            <param name="countPerList">The length per count.</param>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.#ctor(System.Func{System.Collections.Generic.IList{`0}},System.Func{System.Int32})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Matrix`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
            <param name="countPerList">The length per count.</param>
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Item(System.Int32,System.Int32)">
            <summary>Performs the index operation on the <see cref="T:Emik.Morsels.Matrix`1"/>.</summary>
            <param name="x">The <c>x</c> position, which is the list to take.</param>
            <param name="y">The <c>y</c> position, which is the element from the list to take.</param>
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Morsels.Matrix`1.CountPerList">
            <summary>Gets the amount of items per list.</summary>
        </member>
        <member name="P:Emik.Morsels.Matrix`1.List">
            <summary>Gets the encapsulated list.</summary>
        </member>
        <member name="P:Emik.Morsels.Matrix`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Add(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Contains(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.CopyTo(System.Collections.Generic.IList{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Insert(System.Int32,System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Remove(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.IndexOf(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.op_Implicit(System.ValueTuple{System.Collections.Generic.IList{`0},System.Int32})~Emik.Morsels.Matrix{`0}">
            <summary>
            Implicitly converts the parameter by creating the new instance of Matrix{T} by using the constructor
            <see cref="M:Emik.Morsels.Matrix`1.#ctor(System.Collections.Generic.IList{`0},System.Int32)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Matrix{T} by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Matrix`1.#ctor(System.Collections.Generic.IList{`0},System.Int32)"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.op_Implicit(System.ValueTuple{System.Collections.Generic.IList{`0},System.Func{System.Int32}})~Emik.Morsels.Matrix{`0}">
            <summary>
            Implicitly converts the parameter by creating the new instance of Matrix{T} by using the constructor
            <see cref="M:Emik.Morsels.Matrix`1.#ctor(System.Collections.Generic.IList{`0},System.Func{System.Int32})"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Matrix{T} by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Matrix`1.#ctor(System.Collections.Generic.IList{`0},System.Func{System.Int32})"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.op_Implicit(System.ValueTuple{System.Func{System.Collections.Generic.IList{`0}},System.Int32})~Emik.Morsels.Matrix{`0}">
            <summary>
            Implicitly converts the parameter by creating the new instance of Matrix{T} by using the constructor
            <see cref="M:Emik.Morsels.Matrix`1.#ctor(System.Func{System.Collections.Generic.IList{`0}},System.Int32)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Matrix{T} by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Matrix`1.#ctor(System.Func{System.Collections.Generic.IList{`0}},System.Int32)"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.op_Implicit(System.ValueTuple{System.Func{System.Collections.Generic.IList{`0}},System.Func{System.Int32}})~Emik.Morsels.Matrix{`0}">
            <summary>
            Implicitly converts the parameter by creating the new instance of Matrix{T} by using the constructor
            <see cref="M:Emik.Morsels.Matrix`1.#ctor(System.Func{System.Collections.Generic.IList{`0}},System.Func{System.Int32})"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Matrix{T} by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Matrix`1.#ctor(System.Func{System.Collections.Generic.IList{`0}},System.Func{System.Int32})"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Bits`1">
            <inheritdoc cref="T:Emik.Morsels.Bits`1"/>
            <summary>Provides the enumeration of individual bits from the given <typeparamref name="T"/>.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
            <param name="bits">The item to use.</param>
            <inheritdoc cref="T:Emik.Morsels.Bits`1"/>
            <inheritdoc cref="T:Emik.Morsels.Bits`1"/>
        </member>
        <member name="P:Emik.Morsels.Bits`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Morsels.Bits`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Morsels.Bits`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="M:Emik.Morsels.Bits`1.#ctor(`0)">
            <summary>Provides the enumeration of individual bits from the given <typeparamref name="T"/>.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
            <param name="bits">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Bits`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/>
        </member>
        <member name="P:Emik.Morsels.Bits`1.Current">
            <summary>Gets the item to use.</summary>
        </member>
        <member name="M:Emik.Morsels.Bits`1.op_Implicit(Emik.Morsels.Bits{`0}.Enumerator)~Emik.Morsels.Bits{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Bits`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.op_Implicit(`0)~Emik.Morsels.Bits{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Bits`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.op_Implicit(Emik.Morsels.Bits{`0})~Emik.Morsels.Bits{`0}.Enumerator">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Bits`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Bits`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.op_Implicit(Emik.Morsels.Bits{`0})~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Bits`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Bits`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#ISet{T}#ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#ISet{T}#IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#ISet{T}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#ISet{T}#UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#ISet{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.GetEnumerator">
            <summary>
            Returns itself. Used to tell the compiler that it can be used in a <see langword="foreach"/> loop.
            </summary>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.Coerce``1">
            <summary>Reinterprets the bits in <see cref="P:Emik.Morsels.Bits`1.Current"/> as <typeparamref name="TResult"/>.</summary>
            <remarks><para>
            If the type <typeparamref name="TResult"/> is smaller than <typeparamref name="T"/>,
            the result is truncated to the left. Otherwise, if the type <typeparamref name="TResult"/>
            is larger than <typeparamref name="T"/>, the result is zero-padded to the left.
            </para>
            <example>
            <para>Visual description of how the coercion works:</para>
            <code lang="C#"><![CDATA[
            var bits = ((ushort)0b0101_0110).AsBits(); // 0b0000_1111_0101_0110
            var padding = bits.Coerce<int>(); // 0b0000_0000_0000_0000_0000_1111_0101_0110
            var truncation = bits.Coerce<byte>(); // 0b0101_0110
            ]]></code></example></remarks>
            <typeparam name="TResult">The type to reinterpret the bits as.</typeparam>
            <returns>The result of reinterpreting <see cref="P:Emik.Morsels.Bits`1.Current"/> as <typeparamref name="TResult"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.CoerceLeft``1">
            <summary>Reinterprets the bits in <see cref="P:Emik.Morsels.Bits`1.Current"/> as <typeparamref name="TResult"/>.</summary>
            <remarks><para>
            If the type <typeparamref name="TResult"/> is smaller than <typeparamref name="T"/>,
            the result is truncated to the right. Otherwise, if the type <typeparamref name="TResult"/>
            is larger than <typeparamref name="T"/>, the result is zero-padded to the right.
            </para>
            <example>
            <para>Visual description of how the coercion works:</para>
            <code lang="C#"><![CDATA[
            var bits = ((ushort)0b0101_0110).AsBits(); // 0b0000_1111_0101_0110
            var padding = bits.Coerce<int>(); // 0b0000_1111_0101_0110_0000_0000_0000_0000
            var truncation = bits.Coerce<byte>(); // 0b0000_1111
            ]]></code></example></remarks>
            <typeparam name="TResult">The type to reinterpret the bits as.</typeparam>
            <returns>The result of reinterpreting <see cref="P:Emik.Morsels.Bits`1.Current"/> as <typeparamref name="TResult"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Bits`1.Enumerator">
            <summary>An enumerator over <see cref="T:Emik.Morsels.Bits`1"/>.</summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Enumerator.#ctor(`0)">
            <summary>An enumerator over <see cref="T:Emik.Morsels.Bits`1"/>.</summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Bits`1.Enumerator.Mask">
            <summary>Gets the current mask.</summary>
        </member>
        <member name="P:Emik.Morsels.Bits`1.Enumerator.Index">
            <summary>Gets the current index.</summary>
        </member>
        <member name="P:Emik.Morsels.Bits`1.Enumerator.AsBits">
            <summary>Gets the reconstruction of the original enumerable that can create this instance.</summary>
        </member>
        <member name="P:Emik.Morsels.Bits`1.Enumerator.AsValue">
            <summary>Gets the underlying value that is being enumerated.</summary>
        </member>
        <member name="P:Emik.Morsels.Bits`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Bits`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.Enumerator.op_Implicit(`0)~Emik.Morsels.Bits{`0}.Enumerator">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Bits`1.Enumerator"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Enumerator.op_Implicit(Emik.Morsels.Bits{`0}.Enumerator)~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Bits`1.Enumerator.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Bits`1.Enumerator.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Enumerator.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.Enumerator.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Bits`1.Enumerator.ToRemainingString">
            <summary>Enumerates over the remaining elements to give a <see cref="T:System.String"/> result.</summary>
            <returns>The <see cref="T:System.String"/> result of this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.And(`0@,`0@)">
            <summary>Computes the Bitwise-AND computation, writing it to the second argument.</summary>
            <param name="read">The <typeparamref name="T"/> to read from.</param>
            <param name="write">The <typeparamref name="T"/> to write to.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.AndNot(`0@,`0@)">
            <summary>Computes the Bitwise-AND-NOT computation, writing it to the second argument.</summary>
            <param name="read">The <typeparamref name="T"/> to read from.</param>
            <param name="write">The <typeparamref name="T"/> to write to.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Not(`0@)">
            <summary>Computes the Bitwise-NOT computation, writing it to the first argument.</summary>
            <param name="reference">The <typeparamref name="T"/> to read and write from.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Or(`0@,`0@)">
            <summary>Computes the Bitwise-OR computation, writing it to the second argument.</summary>
            <param name="read">The <typeparamref name="T"/> to read from.</param>
            <param name="write">The <typeparamref name="T"/> to write to.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Xor(`0@,`0@)">
            <summary>Computes the Bitwise-XOR computation, writing it to the second argument.</summary>
            <param name="read">The <typeparamref name="T"/> to read from.</param>
            <param name="write">The <typeparamref name="T"/> to write to.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Eq(`0@,`0@)">
            <summary>Determines whether both references of <typeparamref name="T"/> contain the same bits.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>
            The value <see langword="true"/> if the parameters <paramref name="left"/> and <paramref name="right"/>
            point to values with the same bits as each other; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.EqZero(`0@)">
            <summary>Determines whether both references of <typeparamref name="T"/> contain the same bits.</summary>
            <param name="reference">The reference to determine if it is zeroed.</param>
            <returns>
            The value <see langword="true"/> if the parameter <paramref name="reference"/>
            points to a value with all zeros; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.And(`0*,`0*)">
            <summary>Computes the Bitwise-AND computation, writing it to the second argument.</summary>
            <remarks><para>This method assumes the pointers are fixed.</para></remarks>
            <param name="read">The <typeparamref name="T"/> to read from.</param>
            <param name="write">The <typeparamref name="T"/> to write to.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.AndNot(`0*,`0*)">
            <summary>Computes the Bitwise-AND-NOT computation, writing it to the second argument.</summary>
            <remarks><para>This method assumes the pointers are fixed.</para></remarks>
            <param name="read">The <typeparamref name="T"/> to read from.</param>
            <param name="write">The <typeparamref name="T"/> to write to.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Not(`0*)">
            <summary>Computes the Bitwise-NOT computation, writing it to the second argument.</summary>
            <remarks><para>This method assumes the pointers are fixed.</para></remarks>
            <param name="ptr">The <typeparamref name="T"/> to read and write from.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Or(`0*,`0*)">
            <summary>Computes the Bitwise-OR computation, writing it to the second argument.</summary>
            <remarks><para>This method assumes the pointers are fixed.</para></remarks>
            <param name="read">The <typeparamref name="T"/> to read from.</param>
            <param name="write">The <typeparamref name="T"/> to write to.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Xor(`0*,`0*)">
            <summary>Computes the Bitwise-XOR computation, writing it to the second argument.</summary>
            <remarks><para>This method assumes the pointers are fixed.</para></remarks>
            <param name="read">The <typeparamref name="T"/> to read from.</param>
            <param name="write">The <typeparamref name="T"/> to write to.</param>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Eq(`0*,`0*)">
            <summary>Determines whether both pointers of <typeparamref name="T"/> contain the same bits.</summary>
            <remarks><para>This method assumes the pointers are fixed.</para></remarks>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>
            The value <see langword="true"/> if the parameters <paramref name="left"/> and <paramref name="right"/>
            point to values with the same bits as each other; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.EqZero(`0*)">
            <summary>Determines whether the pointer of <typeparamref name="T"/> contains all zeros.</summary>
            <remarks><para>This method assumes the pointers are fixed.</para></remarks>
            <param name="ptr">The pointer to determine if it is zeroed.</param>
            <returns>
            The value <see langword="true"/> if the parameter <paramref name="ptr"/>
            points to a value with all zeros; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Clamp(`0*,`0*,`0*)">
            <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
            <param name="number">The bits to clamp.</param>
            <param name="min">The minimum accepted value.</param>
            <param name="max">The maximum accepted value.</param>
            <returns>
            The parameter <paramref name="number"/> if its bits are greater or equal to the parameter
            <paramref name="min"/>, and lesser or equal to the parameter <paramref name="number"/>; otherwise,
            <paramref name="min"/> if the parameter <paramref name="number"/> is lesser than
            <paramref name="min"/>; otherwise, <paramref name="max"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Max(`0*,`0*)">
            <summary>Returns the pointer that contains the greater bits.</summary>
            <remarks><para>This method assumes the pointers are fixed.</para></remarks>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>
            The parameter <paramref name="left"/> if its bits are greater or equal to the
            parameter <paramref name="right"/>; otherwise, <paramref name="right"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Min(`0*,`0*)">
            <summary>Returns the pointer that contains the lesser bits.</summary>
            <remarks><para>This method assumes the pointers are fixed.</para></remarks>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>
            The parameter <paramref name="left"/> if its bits are lesser or equal to the
            parameter <paramref name="right"/>; otherwise, <paramref name="right"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.IsSingle(`0@)">
            <summary>Determines whether the item has only a single bit.</summary>
            <param name="item">The element to test.</param>
            <returns>
            The value <see langword="true"/> if the parameter <paramref name="item"/>
            has a single bit set; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Bits`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.Bits`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Bits`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Bits`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Bits`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Bits`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Bits`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="T:Emik.Morsels.BitsFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Bits`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.BitsFactory.AsBits``1(``0)">
            <summary>Creates the <see cref="T:Emik.Morsels.Bits`1"/> from the item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The <see cref="T:Emik.Morsels.Bits`1"/> instance with the parameter <paramref name="source"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.BitsFactory.BitwiseAnd``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Computes the Bitwise-AND of the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.BitsFactory.BitwiseAndNot``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Computes the Bitwise-AND-NOT of the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.BitsFactory.BitwiseOr``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Computes the Bitwise-OR of the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.BitsFactory.BitwiseXor``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Computes the Bitwise-XOR of the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.OnceFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Once`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.OnceFactory.Yield``1(``0,System.Boolean)">
            <summary>Creates a <see cref="T:Emik.Morsels.Once`1"/> from an item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <param name="condition">The condition that must be true for <paramref name="source"/> to be used.</param>
            <returns>The <see cref="T:Emik.Morsels.Once`1"/> instance that can be yielded once.</returns>
        </member>
        <member name="M:Emik.Morsels.OnceFactory.Yield``1(``0,System.Func{System.Boolean})">
            <summary>Creates a <see cref="T:Emik.Morsels.Once`1"/> from an item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <param name="condition">The condition that must be true for <paramref name="source"/> to be used.</param>
            <returns>The <see cref="T:Emik.Morsels.Once`1"/> instance that can be yielded once.</returns>
        </member>
        <member name="M:Emik.Morsels.OnceFactory.Yield``1(``0,System.Predicate{``0})">
            <summary>Creates a <see cref="T:Emik.Morsels.Once`1"/> from an item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <param name="condition">The condition that must be true for <paramref name="source"/> to be used.</param>
            <returns>The <see cref="T:Emik.Morsels.Once`1"/> instance that can be yielded once.</returns>
        </member>
        <member name="M:Emik.Morsels.OnceFactory.YieldValued``1(``0)">
            <summary>Creates a <see cref="T:Emik.Morsels.Once`1"/> from an item if it isn't null.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The <see cref="T:Emik.Morsels.Once`1"/> instance that can be yielded once.</returns>
        </member>
        <member name="M:Emik.Morsels.OnceFactory.YieldValued``1(System.Nullable{``0})">
            <summary>Creates a <see cref="T:Emik.Morsels.Once`1"/> from an item if it isn't null.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The <see cref="T:Emik.Morsels.Once`1"/> instance that can be yielded once.</returns>
        </member>
        <member name="T:Emik.Morsels.Once`1">
            <summary>A factory for creating iterator types that yields an item once.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
            <param name="value">The item to use.</param>
        </member>
        <member name="M:Emik.Morsels.Once`1.#ctor(`0)">
            <summary>A factory for creating iterator types that yields an item once.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.HasValue">
            <summary>Gets a value indicating whether this is a default value.</summary>
        </member>
        <member name="P:Emik.Morsels.Once`1.Current">
            <summary>Gets the item to use.</summary>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IReadOnlyList{T}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.Once`1.op_Implicit(Emik.Morsels.Once{`0}.Enumerator)~Emik.Morsels.Once{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Once`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.op_Implicit(`0)~Emik.Morsels.Once{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Once`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.op_Implicit(Emik.Morsels.Once{`0})~Emik.Morsels.Once{`0}.Enumerator">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Once`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Once`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.op_Implicit(Emik.Morsels.Once{`0})~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Once`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Once`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.Once`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.GetEnumerator">
            <summary>
            Returns itself. Used to tell the compiler that it can be used in a <see langword="foreach"/> loop.
            </summary>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Once`1.Enumerator">
            <summary>An enumerator over <see cref="T:Emik.Morsels.Once`1"/>.</summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.#ctor(`0)">
            <summary>An enumerator over <see cref="T:Emik.Morsels.Once`1"/>.</summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Once`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Once`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.op_Implicit(`0)~Emik.Morsels.Once{`0}.Enumerator">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.op_Implicit(Emik.Morsels.Once{`0}.Enumerator)~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Once`1.Enumerator.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Once`1.Enumerator.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.ReadOnlyFactory">
            <summary>Extension methods that act as factories for read-only lists.</summary>
        </member>
        <member name="M:Emik.Morsels.ReadOnlyFactory.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to a read-only list.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a read-only list.</param>
            <returns>A read-only list of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.ReadOnlyList`1">
            <summary>Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> and make all mutating methods a no-op.</summary>
            <typeparam name="T">The type of element in the list.</typeparam>
            <param name="list">The list to encapsulate.</param>
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> and make all mutating methods a no-op.</summary>
            <typeparam name="T">The type of element in the list.</typeparam>
            <param name="list">The list to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)" />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.YesFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Yes`1"/>.</summary>
        </member>
        <member name="P:Emik.Morsels.YesFactory.Fallback">
            <summary>Gets the fallback for when an enumeration returns <see langword="null"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.YesFactory.Forever``1(``0)">
            <summary>Creates a <see cref="T:Emik.Morsels.Yes`1"/> from an item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The <see cref="T:Emik.Morsels.Yes`1"/> instance that can be yielded forever.</returns>
        </member>
        <member name="T:Emik.Morsels.Yes`1">
            <summary>A factory for creating iterator types that yield the same item forever.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
            <param name="value">The item to use.</param>
        </member>
        <member name="M:Emik.Morsels.Yes`1.#ctor(`0)">
            <summary>A factory for creating iterator types that yield the same item forever.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Yes`1.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Yes`1.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.op_Implicit(`0)~Emik.Morsels.Yes{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.op_Implicit(Emik.Morsels.Yes{`0})~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Yes`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Yes`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.GetEnumerator">
            <summary>Returns itself.</summary>
            <remarks><para>Used to allow <see langword="foreach"/> to be used on <see cref="T:Emik.Morsels.Yes`1"/>.</para></remarks>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerator#Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerator#MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.NullableItems">
            <summary>Extension methods for improving nullability awareness for enumerables.</summary>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeEmptyNullable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="iterable">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="iterable"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="iterable">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="iterable"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="iterator">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="iterator"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemNotNull``1(System.Collections.Generic.IList{``0})">
            <summary>Returns the list if all items are non-null.</summary>
            <typeparam name="T">The type of list.</typeparam>
            <param name="list">The list to filter.</param>
            <returns>
            The parameter <paramref name="list"/> if all items are non-<see langword="null"/>,
            otherwise <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="collection">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="collection"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="list">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="list"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlySet{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="set">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="set"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="T:Emik.Morsels.RandomizedGetters">
            <summary>Extension methods for randomized getters.</summary>
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>Shuffles a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <param name="selector">The indices to swap with, when left unspecified, uses <see cref="M:Emik.Morsels.RandomizedGetters.Rand"/>.</param>
            <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.Shuffle``1(System.Span{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <inheritdoc cref="M:Emik.Morsels.RandomizedGetters.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})" />
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.PickRandom``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>Shuffles a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <param name="selector">The indices to swap with, when left unspecified, uses <see cref="M:Emik.Morsels.RandomizedGetters.Rand"/>.</param>
            <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.PickRandom``1(System.Span{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <inheritdoc cref="M:Emik.Morsels.RandomizedGetters.PickRandom``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})" />
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.PickRandom``1(System.ReadOnlySpan{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <inheritdoc cref="M:Emik.Morsels.RandomizedGetters.PickRandom``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})" />
        </member>
        <member name="T:Emik.Morsels.Similarity">
            <summary>Provides methods for determining similarity between two sequences.</summary>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro(System.String,System.String)">
            <summary>Calculates the Jaro similarity between two strings.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Func{System.Char,System.Char,System.Boolean})">
            <summary>Calculates the Jaro similarity between two strings.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})">
            <summary>Calculates the Jaro similarity between two strings.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik(System.String,System.String)">
            <summary>Calculates the Jaro-Emik similarity between two strings.</summary>
            <remarks><para>Like <see cref="M:Emik.Morsels.Similarity.Jaro(System.String,System.String)"/>, but with a bias to common sub-slices.</para></remarks>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik(System.String,System.String,System.Func{System.Char,System.Char,System.Boolean})">
            <summary>Calculates the Jaro-Emik similarity between two strings.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Func{System.Char,System.Char,System.Boolean})"/>, but with a bias to common sub-slices.
            </para></remarks>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})">
            <summary>Calculates the Jaro-Emik similarity between two strings.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})"/>, but with a bias to common sub-slices.
            </para></remarks>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler(System.String,System.String)">
            <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
            <remarks><para>Like <see cref="M:Emik.Morsels.Similarity.Jaro(System.String,System.String)"/>, but with a bias to common prefixes.</para></remarks>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler(System.String,System.String,System.Func{System.Char,System.Char,System.Boolean})">
            <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Func{System.Char,System.Char,System.Boolean})"/>, but with a bias to common prefixes.
            </para></remarks>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})">
            <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})"/>, but with a bias to common prefixes.
            </para></remarks>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Calculates the Jaro similarity between two sequences.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Calculates the Jaro similarity between two sequences.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro similarity between two sequences.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})"/>, but with a bias to common sub-slices.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean})"/>, but with a bias to common sub-slices.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})"/>, but with a bias to common sub-slices.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})"/>, but with a bias to common prefixes.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean})"/>, but with a bias to common prefixes.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})"/>, but with a bias to common prefixes.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro similarity between two sequences.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``1(System.Span{``0},System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro similarity between two sequences.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Calculates the Jaro similarity between two sequences.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``1(System.Span{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Calculates the Jaro similarity between two sequences.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})"/>,
            but with a bias to common sub-slices.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik``1(System.Span{``0},System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.Span{``0},System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})"/>,
            but with a bias to common sub-slices.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,System.Boolean})"/>,
            but with a bias to common sub-slices.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik``1(System.Span{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.Span{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,System.Boolean})"/>,
            but with a bias to common sub-slices.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})"/>,
            but with a bias to common prefixes.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``1(System.Span{``0},System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.Span{``0},System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})"/>,
            but with a bias to common prefixes.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,System.Boolean})"/>,
            but with a bias to common prefixes.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``1(System.Span{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``1(System.Span{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,System.Boolean})"/>,
            but with a bias to common prefixes.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``2(``0,``0,System.Func{``0,System.Int32},System.Func{``0,System.Int32,``1},System.Func{``1,``1,System.Boolean})">
            <summary>Calculates the Jaro similarity between two sequences.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <typeparam name="TItem">The type of item within the sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="counter">The function that gets the count.</param>
            <param name="indexer">The function that acts as an indexer.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``2(``0,``0,System.Int32,System.Int32,System.Func{``0,System.Int32,``1},System.Func{``1,``1,System.Boolean})">
            <summary>Calculates the Jaro similarity between two instances.</summary>
            <typeparam name="T">The type of instance.</typeparam>
            <typeparam name="TItem">The type of item within the instance.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="leftLength">The left-hand side's length.</param>
            <param name="rightLength">The right-hand side's length.</param>
            <param name="indexer">The function that acts as an indexer.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik``2(``0,``0,System.Func{``0,System.Int32},System.Func{``0,System.Int32,``1},System.Func{``1,``1,System.Boolean})">
            <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``2(``0,``0,System.Func{``0,System.Int32},System.Func{``0,System.Int32,``1},System.Func{``1,``1,System.Boolean})"/>,
            but with a bias to common sub-slices.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <typeparam name="TItem">The type of item within the sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="counter">The function that gets the count.</param>
            <param name="indexer">The function that acts as an indexer.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroEmik``2(``0,``0,System.Int32,System.Int32,System.Func{``0,System.Int32,``1},System.Func{``1,``1,System.Boolean})">
            <summary>Calculates the Jaro-Emik similarity between two instances.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``2(``0,``0,System.Int32,System.Int32,System.Func{``0,System.Int32,``1},System.Func{``1,``1,System.Boolean})"/>,
            but with a bias to common sub-slices.
            </para></remarks>
            <typeparam name="T">The type of instance.</typeparam>
            <typeparam name="TItem">The type of item within the instance.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="leftLength">The left-hand side's length.</param>
            <param name="rightLength">The right-hand side's length.</param>
            <param name="indexer">The function that acts as an indexer.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``2(``0,``0,System.Func{``0,System.Int32},System.Func{``0,System.Int32,``1},System.Func{``1,``1,System.Boolean})">
            <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``2(``0,``0,System.Func{``0,System.Int32},System.Func{``0,System.Int32,``1},System.Func{``1,``1,System.Boolean})"/>,
            but with a bias to common prefixes.
            </para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <typeparam name="TItem">The type of item within the sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="counter">The function that gets the count.</param>
            <param name="indexer">The function that acts as an indexer.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``2(``0,``0,System.Int32,System.Int32,System.Func{``0,System.Int32,``1},System.Func{``1,``1,System.Boolean})">
            <summary>Calculates the Jaro-Winkler similarity between two instances.</summary>
            <remarks><para>
            Like <see cref="M:Emik.Morsels.Similarity.Jaro``2(``0,``0,System.Int32,System.Int32,System.Func{``0,System.Int32,``1},System.Func{``1,``1,System.Boolean})"/>,
            but with a bias to common prefixes.
            </para></remarks>
            <typeparam name="T">The type of instance.</typeparam>
            <typeparam name="TItem">The type of item within the instance.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="leftLength">The left-hand side's length.</param>
            <param name="rightLength">The right-hand side's length.</param>
            <param name="indexer">The function that acts as an indexer.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="T:Emik.Morsels.Similarity.Fat`1">
            <summary>Represents a pointer with a length.</summary>
        </member>
        <member name="M:Emik.Morsels.Similarity.Fat`1.#ctor(System.Void*,System.Int32)">
            <summary>Represents a pointer with a length.</summary>
        </member>
        <member name="P:Emik.Morsels.Similarity.Fat`1.Item(System.Int32)">
            <summary>Takes the element corresponding to the passed in index. A bounds check is performed.</summary>
            <param name="i">The index to take.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The parameter <paramref name="i"/> is outside the range.
            </exception>
        </member>
        <member name="P:Emik.Morsels.Similarity.Fat`1.Length">
            <summary>Gets the length.</summary>
        </member>
        <member name="T:Emik.Morsels.Headless">
            <summary>Provides the deconstruction to extract the head and tail of a collection.</summary>
        </member>
        <member name="M:Emik.Morsels.Headless.Deconstruct``1(System.Collections.Generic.IList{``0},``0@,System.Collections.Generic.IList{``0}@)">
            <summary>Separates the head from the tail of an <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="collection">The enumerable to split.</param>
            <param name="head">The first element of the parameter <paramref name="collection"/>.</param>
            <param name="tail">The rest of the parameter <paramref name="collection"/>.</param>
        </member>
        <member name="M:Emik.Morsels.Headless.Tail``1(System.Collections.Generic.IList{``0})">
            <summary>Gets the tail of the <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="collection">The collection to extract the tail from.</param>
            <returns>
            The encapsulation of the parameter <paramref name="collection"/> that prevents the head from being accessed.
            </returns>
        </member>
        <member name="T:Emik.Morsels.HeadlessList`1">
            <summary>Represents a list with no head.</summary>
            <typeparam name="T">The type of list to encapsulate.</typeparam>
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Represents a list with no head.</summary>
            <typeparam name="T">The type of list to encapsulate.</typeparam>
        </member>
        <member name="P:Emik.Morsels.HeadlessList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)" />
        </member>
        <member name="P:Emik.Morsels.HeadlessList`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.HeadlessList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.HeadlessList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.SmallFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.SmallList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.SmallFactory.AsSmallList``1(``0)">
            <inheritdoc cref="M:Emik.Morsels.SmallList`1.op_Implicit(`0)~Emik.Morsels.SmallList{`0}"/>
        </member>
        <member name="M:Emik.Morsels.SmallFactory.AsSmallList``2(System.ValueTuple{``0,``1})">
            <inheritdoc cref="M:Emik.Morsels.SmallList`1.op_Implicit(System.ValueTuple{`0,`0})~Emik.Morsels.SmallList{`0}"/>
        </member>
        <member name="M:Emik.Morsels.SmallFactory.AsSmallList``3(System.ValueTuple{``0,``1,``2})">
            <inheritdoc cref="M:Emik.Morsels.SmallList`1.op_Implicit(System.ValueTuple{`0,`0,`0})~Emik.Morsels.SmallList{`0}"/>
        </member>
        <member name="M:Emik.Morsels.SmallFactory.AsUninitSmallList``1(System.Int32)">
            <inheritdoc cref="M:Emik.Morsels.SmallList`1.Uninit(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.SmallFactory.AsZeroedSmallList``1(System.Int32)">
            <inheritdoc cref="M:Emik.Morsels.SmallList`1.Zeroed(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.SmallFactory.ToSmallList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Collects the enumerable; allocating the heaped list lazily.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.SmallList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.SmallList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallFactory.ToSmallList``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>Mutates the enumerator; allocating the heaped list lazily.</summary>
            <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
            <param name="iterator">The collection to turn into a <see cref="T:Emik.Morsels.SmallList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.SmallList`1"/> of <paramref name="iterator"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.SmallList">
            <summary>Factory methods for creating inlined <see cref="T:Emik.Morsels.SmallList`1"/> instances.</summary>
        </member>
        <member name="F:Emik.Morsels.SmallList.InlinedLength">
            <summary>Number of items to keep inline for <see cref="T:Emik.Morsels.SmallList`1"/>.</summary>
            <remarks><para>
            And Saint Attila raised the <see cref="T:Emik.Morsels.SmallList`1"/> up on high, saying, "O Lord, bless this Thy
            <see cref="T:Emik.Morsels.SmallList`1"/> that, with it, Thou mayest blow Thine allocation costs to tiny bits in Thy mercy.".
            </para><para>
            And the Lord did grin, and the people did feast upon the lambs and sloths and carp and anchovies and orangutans
            and breakfast cereals and fruit bats and large chu...
            </para><para>
            And the Lord spake, saying, "First shalt thou recreate the
            <a href="https://crates.io/crates/smallvec"><c>smallvec</c></a> crate. Then, shalt thou keep three inline. No
            more. No less. Three shalt be the number thou shalt keep inline, and the number to keep inline shalt be three.
            Four shalt thou not keep inline, nor either keep inline thou two, excepting that thou then proceed to three.
            Five is right out. Once the number three,  being the third number, be reached, then, lobbest thou thy
            <see cref="T:Emik.Morsels.SmallList`1"/> towards thy heap, who, being slow and cache-naughty in My sight, shall snuff it.".
            </para><para>
            <a href="https://github.com/rhaiscript/rhai/blob/ca18cdd7f47f8ae8bd6e2b7a950ad4815d62f026/src/lib.rs#L373">
            (Adapted from Rhai)
            </a></para></remarks>
        </member>
        <member name="M:Emik.Morsels.SmallList.Create``1">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with no elements.</summary>
            <typeparam name="T">The type of element in the <see cref="T:Emik.Morsels.SmallList`1"/>.</typeparam>
            <returns>The created <see cref="T:Emik.Morsels.SmallList`1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList.Create``1(``0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with 1 element.</summary>
            <typeparam name="T">The type of element in the <see cref="T:Emik.Morsels.SmallList`1"/>.</typeparam>
            <param name="first">The first element.</param>
            <returns>The created <see cref="T:Emik.Morsels.SmallList`1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList.Create``1(``0,``0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with 2 elements.</summary>
            <typeparam name="T">The type of element in the <see cref="T:Emik.Morsels.SmallList`1"/>.</typeparam>
            <param name="first">The first element.</param>
            <param name="second">The second element.</param>
            <returns>The created <see cref="T:Emik.Morsels.SmallList`1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList.Create``1(``0,``0,``0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with 3 elements.</summary>
            <typeparam name="T">The type of element in the <see cref="T:Emik.Morsels.SmallList`1"/>.</typeparam>
            <param name="first">The first element.</param>
            <param name="second">The second element.</param>
            <param name="third">The third element.</param>
            <returns>The created <see cref="T:Emik.Morsels.SmallList`1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList.Create``1(``0,``0,``0,``0[])">
            <summary>Creates a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with arbitrary elements.</summary>
            <typeparam name="T">The type of element in the <see cref="T:Emik.Morsels.SmallList`1"/>.</typeparam>
            <param name="first">The first element.</param>
            <param name="second">The second element.</param>
            <param name="third">The third element.</param>
            <param name="rest">The rest of the elements.</param>
            <returns>The created <see cref="T:Emik.Morsels.SmallList`1"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.SmallList`1">
            <summary>Inlines 3 elements before falling back on the heap with an expandable <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <typeparam name="T">The element type.</typeparam>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with no elements.</summary>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct.
            Collects the enumerable; allocating the heaped list lazily.
            </summary>
            <param name="enumerable">The enumerable to collect.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct.
            Mutates the enumerator; allocating the heaped list lazily.
            </summary>
            <param name="enumerator">The enumerator to mutate.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.#ctor(`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with 1 element.</summary>
            <param name="first">The first element.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.#ctor(`0,`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with 2 elements.</summary>
            <param name="first">The first element.</param>
            <param name="second">The second element.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.#ctor(`0,`0,`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with 3 elements.</summary>
            <param name="first">The first element.</param>
            <param name="second">The second element.</param>
            <param name="third">The third element.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.#ctor(`0,`0,`0,System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with arbitrary elements.</summary>
            <param name="first">The first element.</param>
            <param name="second">The second element.</param>
            <param name="third">The third element.</param>
            <param name="rest">The rest of the elements.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.#ctor(`0,`0,`0,`0[])">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1"/> struct with arbitrary elements.</summary>
            <param name="first">The first element.</param>
            <param name="second">The second element.</param>
            <param name="third">The third element.</param>
            <param name="rest">The rest of the elements.</param>
        </member>
        <member name="P:Emik.Morsels.SmallList`1.Empty">
            <summary>Gets the empty list.</summary>
        </member>
        <member name="P:Emik.Morsels.SmallList`1.IsEmpty">
            <summary>Gets a value indicating whether determines whether the collection is empty.</summary>
        </member>
        <member name="P:Emik.Morsels.SmallList`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.SmallList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.SmallList`1.HeadCount">
            <summary>Gets the number of head elements used.</summary>
        </member>
        <member name="P:Emik.Morsels.SmallList`1.Cloned">
            <summary>Gets the deep clone of this instance.</summary>
        </member>
        <member name="P:Emik.Morsels.SmallList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)" />
        </member>
        <member name="P:Emik.Morsels.SmallList`1.First">
            <summary>Gets or sets the first element.</summary>
        </member>
        <member name="P:Emik.Morsels.SmallList`1.Second">
            <summary>Gets or sets the second element.</summary>
        </member>
        <member name="P:Emik.Morsels.SmallList`1.Third">
            <summary>Gets or sets the third element.</summary>
        </member>
        <member name="P:Emik.Morsels.SmallList`1.Rest">
            <summary>Gets the rest of the elements.</summary>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.op_Equality(Emik.Morsels.SmallList{`0},Emik.Morsels.SmallList{`0})">
            <summary>Determines whether both sequence are equal.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether both sequences are equal.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.op_Inequality(Emik.Morsels.SmallList{`0},Emik.Morsels.SmallList{`0})">
            <summary>Determines whether both sequence are not equal.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether both sequences are not equal.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.op_Implicit(`0)~Emik.Morsels.SmallList{`0}">
            <summary>Creates the collection with 1 item in it.</summary>
            <param name="value">The single item to use.</param>
            <returns>The collection with 1 item.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.op_Implicit(System.ValueTuple{`0,`0})~Emik.Morsels.SmallList{`0}">
            <summary>Creates the collection with 2 items in it.</summary>
            <param name="tuple">The tuple containing 2 items to destructure and use.</param>
            <returns>The collection with 2 items.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.op_Implicit(System.ValueTuple{`0,`0,`0})~Emik.Morsels.SmallList{`0}">
            <summary>Creates the collection with 3 items in it.</summary>
            <param name="tuple">The tuple containing 3 items to destructure and use.</param>
            <returns>The collection with 3 items.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.op_Implicit(System.ValueTuple{`0,`0,`0,System.Collections.Generic.IList{`0}})~Emik.Morsels.SmallList{`0}">
            <summary>Creates the collection with 3 or more items in it.</summary>
            <param name="tuple">The tuple containing 3 or more items to destructure and use.</param>
            <returns>The collection with 3 or more items.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Uninit(System.Int32)">
            <summary>Skips initialization of inlined elements.</summary>
            <param name="length">The length of the <see cref="T:Emik.Morsels.SmallList`1"/>.</param>
            <returns>The <see cref="T:Emik.Morsels.SmallList`1"/> of length <paramref name="length"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Zeroed(System.Int32)">
            <summary>Skips initialization of unreachable inlined elements.</summary>
            <param name="length">The length of the <see cref="T:Emik.Morsels.SmallList`1"/>.</param>
            <returns>The <see cref="T:Emik.Morsels.SmallList`1"/> of length <paramref name="length"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>Adds the elements of the specified collection to the end of the <see cref="T:Emik.Morsels.SmallList`1"/>.</summary>
            <param name="collection">
            The collection whose elements should be added to the end of the <see cref="T:Emik.Morsels.SmallList`1"/>.
            </param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.CopyTo(Emik.Morsels.SmallList{`0}@)">
            <summary>Copies all values onto the destination.</summary>
            <param name="list">The destination.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The parameter <paramref name="list"/> has less elements than itself.
            </exception>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Deconstruct(System.ValueTuple{`0,`0,`0}@,System.Collections.Generic.IList{`0}@)">
            <summary>Deconstructs this instance with its properties.</summary>
            <param name="head">The first three elements.</param>
            <param name="tail">The remaining elements.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Deconstruct(`0@,`0@,`0@)">
            <summary>Deconstructs this instance with the 3 first elements.</summary>
            <param name="first">The first element.</param>
            <param name="second">The second element.</param>
            <param name="third">The third element.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Deconstruct(`0@,`0@,`0@,System.Collections.Generic.IList{`0}@)">
            <summary>Deconstructs this instance with its properties.</summary>
            <param name="first">The first element.</param>
            <param name="second">The second element.</param>
            <param name="third">The third element.</param>
            <param name="rest">The remaining elements.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.HeadSpan(Emik.Morsels.Span.SpanAction{`0})">
            <summary>Creates the temporary span to be passed into the function.</summary>
            <param name="del">The function to use.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.HeadSpan``1(``0,Emik.Morsels.Span.SpanAction{`0,``0})">
            <summary>Creates the temporary span to be passed into the function.</summary>
            <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
            <param name="param">The reference parameter to pass into the function.</param>
            <param name="del">The function to use.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.HeadSpan``1(System.ReadOnlySpan{``0},Emik.Morsels.Span.SpanActionReadOnlySpan{`0,``0})">
            <summary>Creates the temporary span to be passed into the function.</summary>
            <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
            <param name="param">The reference parameter to pass into the function.</param>
            <param name="del">The function to use.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.HeadSpan``1(System.Span{``0},Emik.Morsels.Span.SpanActionSpan{`0,``0})">
            <summary>Creates the temporary span to be passed into the function.</summary>
            <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
            <param name="param">The reference parameter to pass into the function.</param>
            <param name="del">The function to use.</param>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Contains(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Determines whether the item exists in the collection.</summary>
            <param name="item">The item to check.</param>
            <param name="comparer">The comparer to use.</param>
            <returns>The value determining whether the parameter <paramref name="item"/> exists in the collection.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Equals(Emik.Morsels.SmallList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.GetReversedEnumerator">
            <summary>Gets the enumeration object that returns the values in reversed order.</summary>
            <returns>The backwards enumerator.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Slice(System.Int32)">
            <summary>Forms a slice out of the current list that begins at a specified index.</summary>
            <param name="start">The index at which to begin the slice.</param>
            <returns>
            A list that consists of all elements of the current list from <paramref name="start"/> to the end of the span.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Slice(System.Int32,System.Int32)">
            <summary>Forms a slice out of the current list starting at a specified index for a specified length.</summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice.</param>
            <returns>
            A span that consists of <paramref name="length"/> elements from
            the current span starting at <paramref name="start"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.FirstOrDefault(System.Predicate{`0})">
            <summary>Gets the first element of the list that optionally matches the <see cref="T:System.Predicate`1"/>.</summary>
            <param name="predicate">The predicate to use as a filter.</param>
            <returns>The first element of the list that matches the parameter <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.LastOrDefault(System.Predicate{`0})">
            <summary>Gets the last element of the list that optionally matches the <see cref="T:System.Predicate`1"/>.</summary>
            <param name="predicate">The predicate to use as a filter.</param>
            <returns>The last element of the list that matches the parameter <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.HeadSpan``1(Emik.Morsels.Span.SpanFunc{`0,``0})">
            <summary>Creates the temporary span to be passed into the function.</summary>
            <typeparam name="TResult">The resulting type of the function.</typeparam>
            <param name="del">The function to use.</param>
            <returns>The result of the parameter <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.HeadSpan``2(``0,Emik.Morsels.Span.SpanFunc{`0,``0,``1})">
            <summary>Creates the temporary span to be passed into the function.</summary>
            <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
            <typeparam name="TResult">The resulting type of the function.</typeparam>
            <param name="param">The reference parameter to pass into the function.</param>
            <param name="del">The function to use.</param>
            <returns>The result of the parameter <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.HeadSpan``2(System.ReadOnlySpan{``0},Emik.Morsels.Span.SpanFuncReadOnlySpan{`0,``0,``1})">
            <summary>Creates the temporary span to be passed into the function.</summary>
            <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
            <typeparam name="TResult">The resulting type of the function.</typeparam>
            <param name="param">The reference parameter to pass into the function.</param>
            <param name="del">The function to use.</param>
            <returns>The result of the parameter <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.HeadSpan``2(System.Span{``0},Emik.Morsels.Span.SpanFuncSpan{`0,``0,``1})">
            <summary>Creates the temporary span to be passed into the function.</summary>
            <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
            <typeparam name="TResult">The resulting type of the function.</typeparam>
            <param name="param">The reference parameter to pass into the function.</param>
            <param name="del">The function to use.</param>
            <returns>The result of the parameter <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#GetTypeCode">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToBoolean(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToByte(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToChar(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToDateTime(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToDecimal(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToDouble(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToInt16(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToInt32(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToInt64(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToSByte(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToSingle(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToString(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToUInt16(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToUInt32(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#IConvertible#ToUInt64(System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.SmallList`1.Enumerator">
            <summary>An enumerator over <see cref="T:Emik.Morsels.SmallList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Enumerator.#ctor(Emik.Morsels.SmallList{`0},System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.SmallList`1.Enumerator"/> struct.</summary>
            <param name="list">The <see cref="T:Emik.Morsels.SmallList`1"/> to enumerate over.</param>
            <param name="isReversed">Determines whether to go backwards.</param>
        </member>
        <member name="P:Emik.Morsels.SmallList`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.SmallList`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.SmallList`1.op_Implicit(System.ValueTuple{`0,`0,`0,`0[]})~Emik.Morsels.SmallList{`0}">
            <summary>
            Implicitly converts the parameter by creating the new instance of SmallList{T} by using the constructor
            <see cref="M:Emik.Morsels.SmallList`1.#ctor(`0,`0,`0,`0[])"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of SmallList{T} by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.SmallList`1.#ctor(`0,`0,`0,`0[])"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.SplitFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Split`1"/>.</summary>
        </member>
        <member name="P:Emik.Morsels.SplitFactory.Booleans">
            <summary>Gets all booleans, in the order defined by <see cref="T:Emik.Morsels.Split`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.SplitFactory.SplitAt``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>Splits an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in two based on a number.</summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <param name="source">The collection to split.</param>
            <param name="count">The number of elements in the first half.</param>
            <returns>
            A <see cref="T:Emik.Morsels.Split`1"/> instance that contains 2 enumerables containing the two halves of the underlying
            collection. The first half is as long as the parameter <paramref name="count"/> or shorter.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitFactory.SplitWhen``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})">
            <summary>Splits an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in two based on a method provided.</summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <param name="source">The collection to split.</param>
            <param name="predicate">The method that decides where the item ends up.</param>
            <returns>
            A <see cref="T:Emik.Morsels.Split`1"/> instance that contains 2 enumerables containing the two halves of the underlying
            collection. The first half lasts until the first element that returned <see langword="true"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitFactory.SplitBy``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Splits an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in two based on a method provided.</summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <param name="source">The collection to split.</param>
            <param name="predicate">The method that decides where the item ends up.</param>
            <returns>
            A <see cref="T:Emik.Morsels.Split`1"/> instance that contains 2 lists containing the elements that returned
            <see langword="true"/> and <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitFactory.SmallSplitBy``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Splits an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in two based on a method provided.</summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <param name="source">The collection to split.</param>
            <param name="predicate">The method that decides where the item ends up.</param>
            <returns>
            A <see cref="T:Emik.Morsels.Split`1"/> instance that contains 2 lists containing the elements that returned
            <see langword="true"/> and <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Split`1">
            <summary>Represents a fixed collection of 2 items.</summary>
            <typeparam name="T">The type of item in the collection.</typeparam>
            <param name="truthy">The value representing a <see langword="true"/> value.</param>
            <param name="falsy">The value representing a <see langword="false"/> value.</param>
        </member>
        <member name="M:Emik.Morsels.Split`1.#ctor(`0,`0)">
            <summary>Represents a fixed collection of 2 items.</summary>
            <typeparam name="T">The type of item in the collection.</typeparam>
            <param name="truthy">The value representing a <see langword="true"/> value.</param>
            <param name="falsy">The value representing a <see langword="false"/> value.</param>
        </member>
        <member name="M:Emik.Morsels.Split`1.#ctor(`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Split`1"/> class.</summary>
            <param name="value">The value representing both values.</param>
        </member>
        <member name="P:Emik.Morsels.Split`1.Array">
            <summary>Gets <see cref="P:Emik.Morsels.Split`1.Truthy"/> and <see cref="P:Emik.Morsels.Split`1.Falsy"/> within an array, in that order.</summary>
        </member>
        <member name="P:Emik.Morsels.Split`1.Falsy">
            <summary>Gets or sets the value representing a <see langword="false"/> value.</summary>
        </member>
        <member name="P:Emik.Morsels.Split`1.Truthy">
            <summary>Gets or sets the value representing a <see langword="true"/> value.</summary>
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.Values">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#Keys">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.ArrayPair">
            <inheritdoc cref="P:Emik.Morsels.Split`1.Array"/>
        </member>
        <member name="P:Emik.Morsels.Split`1.Item(System.Boolean)">
            <inheritdoc cref="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyCollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#Keys">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#Values">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Clear" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Add(System.Boolean,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Add(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.CopyTo(System.Collections.Generic.KeyValuePair{System.Boolean,`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Contains(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.TryGetValue(System.Boolean,`0@)">
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Clear">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Clear" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Remove(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#Remove(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#ContainsKey(System.Boolean)">
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#ContainsKey(System.Boolean)">
            <inheritdoc cref="M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.Deconstruct(`0@,`0@)">
            <summary>Deconstructs a <see cref="T:Emik.Morsels.Split`1"/> into its components.</summary>
            <param name="t">The value to get assigned as <see cref="P:Emik.Morsels.Split`1.Truthy"/>.</param>
            <param name="f">The value to get assigned as <see cref="P:Emik.Morsels.Split`1.Falsy"/>.</param>
        </member>
        <member name="M:Emik.Morsels.Split`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.op_Implicit(System.ValueTuple{`0,`0})~Emik.Morsels.Split{`0}">
            <summary>
            Implicitly converts the parameter by creating the new instance of Split{T} by using the constructor
            <see cref="M:Emik.Morsels.Split`1.#ctor(`0,`0)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Split{T} by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Split`1.#ctor(`0,`0)"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Conditionals">
            <summary>Extension methods for nullable types and booleans.</summary>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsAnd``1(``0,System.Predicate{``0})">
            <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="predicate">The predicate to determine the return value.</param>
            <returns>
            The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
            and returned <see langword="true"/> from the predicate; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsAnd``1(System.Nullable{``0},System.Predicate{``0})">
            <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="predicate">The predicate to determine the return value.</param>
            <returns>
            The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
            and returned <see langword="true"/> from the predicate; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsFalse(System.Boolean,System.String)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="that">The value that must be <see langword="false"/>.</param>
            <param name="exThat">Filled by the compiler, the expression to assert.</param>
            <returns>The parameter <paramref name="that"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsNull``1(``0)">
            <summary>Determines whether the value is null or not.</summary>
            <typeparam name="T">The type of value to check.</typeparam>
            <param name="value">The value to check.</param>
            <returns>
            The value <see langword="true"/> if the parameter <paramref name="value"/>
            is <see langword="null"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsTrue(System.Boolean,System.String)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="that">The value that must be <see langword="true"/>.</param>
            <param name="exThat">Filled by the compiler, the expression to assert.</param>
            <returns>The parameter <paramref name="that"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then(System.Boolean,System.Action,System.Action)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="value">The value to check.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <param name="ifFalse">The value to invoke when <see langword="false"/>.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then``1(System.Boolean,``0)">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is eagerly evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="onTrue">The value to return when <see langword="true"/>.</param>
            <returns>
            The value <paramref name="onTrue"/> if <paramref name="value"/>
            is <see langword="true"/>; otherwise, <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then``1(System.Boolean,System.Func{``0})">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is lazily evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <returns>
            The value returned from <paramref name="ifTrue"/> if <paramref name="value"/>
            is <see langword="true"/>; otherwise, <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Filter``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Filters an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to only non-null values.</summary>
            <typeparam name="T">The type of value to filter.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to filter.</param>
            <returns>A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> with strictly non-null values.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Filter``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>Filters an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to only non-null values.</summary>
            <typeparam name="T">The type of value to filter.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to filter.</param>
            <returns>A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> with strictly non-null values.</returns>
        </member>
        <member name="T:Emik.Morsels.Assert">
            <summary>Defines the base class for an assertion, where a function is expected to return true.</summary>
            <param name="that">The condition that must be true.</param>
            <param name="message">The message to display when <paramref name="that"/> is false.</param>
            <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
            <inheritdoc cref="T:Emik.Morsels.Assert"/>
            <inheritdoc cref="T:Emik.Morsels.Assert"/>
            <inheritdoc cref="T:Emik.Morsels.Assert"/>
            <inheritdoc cref="T:Emik.Morsels.Assert"/>
        </member>
        <member name="M:Emik.Morsels.Assert.#ctor(System.Boolean,System.String,System.String)">
            <summary>Defines the base class for an assertion, where a function is expected to return true.</summary>
            <param name="that">The condition that must be true.</param>
            <param name="message">The message to display when <paramref name="that"/> is false.</param>
            <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
        </member>
        <member name="M:Emik.Morsels.Assert.#ctor(System.Func{System.Boolean},System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Assert"/> class.</summary>
            <param name="that">The condition that must be true.</param>
            <param name="message">The message to display when <paramref name="that"/> is false.</param>
            <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
        </member>
        <member name="P:Emik.Morsels.Assert.Length">
            <summary>Gets the amount of available assertions.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Runner">
            <summary>
            Gets the enumeration responsible for running every <see cref="T:Emik.Morsels.Assert"/> instance
            defined in the current <see cref="T:System.Reflection.Assembly"/>, and returning every instance of a failed assert.
            </summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Message">
            <summary>Gets the message of the assertion if it failed, or null.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Name">
            <summary>Gets the name of the assertion.</summary>
        </member>
        <member name="M:Emik.Morsels.Assert.Any(System.Collections.IEnumerable)">
            <summary>Assertion that the enumerable must contain an item.</summary>
            <param name="x">The enumerable that must contain an item.</param>
            <returns>Whether the parameter <paramref name="x"/> contains an item.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Empty(System.Collections.IEnumerable)">
            <summary>Assertion that the enumerable must be empty.</summary>
            <param name="x">The enumerable that must be empty.</param>
            <returns>Whether the parameter <paramref name="x"/> is empty.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.EmptyOrNull(System.Collections.IEnumerable)">
            <summary>Assertion that the enumerable must be null or empty.</summary>
            <param name="x">The enumerable that must be null or empty.</param>
            <returns>Whether the parameter <paramref name="x"/> is null or empty.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Update(System.Delegate,System.Func{System.Boolean},System.String@,System.Converter{Emik.Morsels.Assert.FormatAttribute,System.String})">
            <summary>Updates the value of the referenced parameter if the provided assertion fails.</summary>
            <param name="exposure">The exposed <see cref="T:System.Delegate"/> used to get metadata from.</param>
            <param name="that">The condition that must be true.</param>
            <param name="message">The message to update.</param>
            <param name="formatter">The factory of the message.</param>
            <returns>The returned value when calling the parameter <paramref name="that"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.SequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Assertion that both parameters must contain the same items.</summary>
            <typeparam name="T">The type of items to compare.</typeparam>
            <param name="x">The left-hand side.</param>
            <param name="y">The right-hand side.</param>
            <returns>Whether the parameters <paramref name="x"/> and <paramref name="y"/> have the same items.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.EqualTo``1(``0,``0)">
            <summary>Assertion that both parameters must be equal.</summary>
            <typeparam name="T">The type of values to compare.</typeparam>
            <param name="x">The left-hand side.</param>
            <param name="y">The right-hand side.</param>
            <returns>Whether the parameters <paramref name="x"/> and <paramref name="y"/> are the same.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.GreaterThan``1(``0,``0)">
            <summary>Assertion that the left-hand side must be greater than the right-hand side.</summary>
            <typeparam name="T">The type of values to compare.</typeparam>
            <param name="x">The left-hand side.</param>
            <param name="y">The right-hand side.</param>
            <returns>Whether the parameter <paramref name="x"/> is greater than <paramref name="y"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.GreaterThanOrEqualTo``1(``0,``0)">
            <summary>Assertion that the left-hand side must be greater than or equal to the right-hand side.</summary>
            <typeparam name="T">The type of values to compare.</typeparam>
            <param name="x">The left-hand side.</param>
            <param name="y">The right-hand side.</param>
            <returns>Whether the parameter <paramref name="x"/> is greater than or equal to <paramref name="y"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.LessThan``1(``0,``0)">
            <summary>Assertion that the left-hand side must be less than the right-hand side.</summary>
            <typeparam name="T">The type of values to compare.</typeparam>
            <param name="x">The left-hand side.</param>
            <param name="y">The right-hand side.</param>
            <returns>Whether the parameter <paramref name="x"/> is less than <paramref name="y"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.LessThanOrEqualTo``1(``0,``0)">
            <summary>Assertion that the left-hand side must be less than or equal to the right-hand side.</summary>
            <typeparam name="T">The type of values to compare.</typeparam>
            <param name="x">The left-hand side.</param>
            <param name="y">The right-hand side.</param>
            <returns>Whether the parameter <paramref name="x"/> is less than or equal to <paramref name="y"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.NotNull(System.Object)">
            <summary>Assertion that the enumerable must not be null.</summary>
            <param name="x">The value that must not be null.</param>
            <returns>Whether the parameter <paramref name="x"/> is not null.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.NotNull``1(``0)">
            <summary>Assertion that the enumerable must not be null.</summary>
            <typeparam name="T">The type of value to do the null check on.</typeparam>
            <param name="x">The value that must not be null.</param>
            <returns>Whether the parameter <paramref name="x"/> is not null.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Null(System.Object)">
            <summary>Assertion that the enumerable must be null.</summary>
            <param name="x">The value that must be null.</param>
            <returns>Whether the parameter <paramref name="x"/> is null.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Null``1(``0)">
            <summary>Assertion that the enumerable must be null.</summary>
            <typeparam name="T">The type of value to do the null check on.</typeparam>
            <param name="x">The value that must be null.</param>
            <returns>Whether the parameter <paramref name="x"/> is null.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.UnequalTo``1(``0,``0)">
            <summary>Assertion that both parameters must not be equal.</summary>
            <typeparam name="T">The type of values to compare.</typeparam>
            <param name="x">The left-hand side.</param>
            <param name="y">The right-hand side.</param>
            <returns>Whether the parameters <paramref name="x"/> and <paramref name="y"/> are not the same.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Compare``1(``0,``0)">
            <summary>Compares the two instances. This method is used for any comparing assertion methods.</summary>
            <typeparam name="T">The type of values to compare.</typeparam>
            <param name="x">The left-hand side.</param>
            <param name="y">The right-hand side.</param>
            <returns>The resulting value from comparing parameters <paramref name="x"/> and <paramref name="y"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.RoughlyEqualTo(System.Single)">
            <summary>Creates the assertion that two items must be equal to each other within an error of margin.</summary>
            <param name="margin">The lossy value to which both instances are considered equal.</param>
            <returns>The assertion that determines equality of two items within a margin of error.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.RoughlyEqualTo(System.Double)">
            <inheritdoc cref="M:Emik.Morsels.Assert.RoughlyEqualTo(System.Single)"/>
        </member>
        <member name="M:Emik.Morsels.Assert.RoughlyEqualTo(System.Decimal)">
            <inheritdoc cref="M:Emik.Morsels.Assert.RoughlyEqualTo(System.Single)"/>
        </member>
        <member name="M:Emik.Morsels.Assert.AllMessages">
            <summary>Executes every assertion and gets all of the assertions that failed.</summary>
            <returns>All assertions that failed.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.InRangeOf(System.Range)">
            <summary>Creates the assertion that the value must be within a certain range.</summary>
            <param name="range">The range of values to accept. The range is considered to be inclusive on both ends.</param>
            <returns>The assertion that determines whether a value is within the specific range.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.InRangeOf``1(``0,``0)">
            <summary>Creates the assertion that the value must be within a certain range.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="low">The inclusive lower boundary.</param>
            <param name="high">The inclusive higher boundary.</param>
            <returns>The assertion that determines whether a value is within the specific range.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Structured``1(``0[])">
            <summary>Creates the assertion that the parameter must contain specific items.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="items">The items that will be eventually compared to.</param>
            <returns>The assertion that determines whether a value contains the pre-determined items.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Params``1(``0[])">
            <summary>Returns the parameter.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="items">The items that will be returned directly.</param>
            <returns>The parameter <paramref name="items"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert.IsAssertable(System.Type)">
            <summary>
            Determines whether the type implements <see cref="T:Emik.Morsels.Assert"/> and can be instantiated.
            </summary>
            <param name="type">The type to check.</param>
            <returns>Whether the type implements <see cref="T:Emik.Morsels.Assert"/> and can be instantiated.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.ParameterlessConstructor(System.Type)">
            <summary>Gets the parameterless constructor, ignoring possible exceptions thrown.</summary>
            <param name="type">The type to get the parameterless exception from.</param>
            <returns>
            The <see cref="T:System.Reflection.ConstructorInfo"/> containing no parameters from the parameter <paramref name="type"/>,
            if one exists.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Assert.FormatAttribute">
            <summary>Represents the way an assertion be formatted.</summary>
            <param name="template">The template that is formatted and shown when the declaring member fails.</param>
        </member>
        <member name="M:Emik.Morsels.Assert.FormatAttribute.#ctor(System.String)">
            <summary>Represents the way an assertion be formatted.</summary>
            <param name="template">The template that is formatted and shown when the declaring member fails.</param>
        </member>
        <member name="F:Emik.Morsels.Assert.FormatAttribute.Assertion">
            <summary>The value that is substituted for the function body of the assertion.</summary>
        </member>
        <member name="F:Emik.Morsels.Assert.FormatAttribute.XFactory">
            <summary>The value that is substituted for the function body of the first parameter's factory.</summary>
        </member>
        <member name="F:Emik.Morsels.Assert.FormatAttribute.XValue">
            <summary>The value that is substituted for first parameter.</summary>
        </member>
        <member name="F:Emik.Morsels.Assert.FormatAttribute.YFactory">
            <summary>The value that is substituted for the function body of the second parameter's factory.</summary>
        </member>
        <member name="F:Emik.Morsels.Assert.FormatAttribute.YValue">
            <summary>The value that is substituted for second parameter.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.FormatAttribute.Default">
            <summary>Gets the default formatter.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.FormatAttribute.Item(System.String)">
            <summary>Returns the formatted <see cref="P:Emik.Morsels.Assert.FormatAttribute.Template"/> by inserting the parameter.</summary>
            <param name="assertion">The value to replace <see cref="F:Emik.Morsels.Assert.FormatAttribute.Assertion"/> with.</param>
        </member>
        <member name="P:Emik.Morsels.Assert.FormatAttribute.Item(System.String,System.String,System.Object)">
            <summary>Returns the formatted <see cref="P:Emik.Morsels.Assert.FormatAttribute.Template"/> by inserting the parameters.</summary>
            <param name="assertion">The value to replace <see cref="F:Emik.Morsels.Assert.FormatAttribute.Assertion"/> with.</param>
            <param name="xFactory">The value to replace <see cref="F:Emik.Morsels.Assert.FormatAttribute.XFactory"/> with.</param>
            <param name="xValue">The value to replace <see cref="F:Emik.Morsels.Assert.FormatAttribute.XValue"/> with.</param>
        </member>
        <member name="P:Emik.Morsels.Assert.FormatAttribute.Item(System.String,System.String,System.Object,System.String,System.Object)">
            <summary>Returns the formatted <see cref="P:Emik.Morsels.Assert.FormatAttribute.Template"/> by inserting the parameters.</summary>
            <param name="assertion">The value to replace <see cref="F:Emik.Morsels.Assert.FormatAttribute.Assertion"/> with.</param>
            <param name="xFactory">The value to replace <see cref="F:Emik.Morsels.Assert.FormatAttribute.XFactory"/> with.</param>
            <param name="xValue">The value to replace <see cref="F:Emik.Morsels.Assert.FormatAttribute.XValue"/> with.</param>
            <param name="yFactory">The value to replace <see cref="F:Emik.Morsels.Assert.FormatAttribute.YFactory"/> with.</param>
            <param name="yValue">The value to replace <see cref="F:Emik.Morsels.Assert.FormatAttribute.YValue"/> with.</param>
        </member>
        <member name="P:Emik.Morsels.Assert.FormatAttribute.Template">
            <summary>Gets the template, before any substitution occurs.</summary>
        </member>
        <member name="M:Emik.Morsels.Assert.FormatAttribute.op_Implicit(System.String)~Emik.Morsels.Assert.FormatAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of FormatAttribute by using the constructor
            <see cref="M:Emik.Morsels.Assert.FormatAttribute.#ctor(System.String)"/>.
            </summary>
            <param name="template">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of FormatAttribute by passing the parameter <paramref name="template"/> to the constructor
            <see cref="M:Emik.Morsels.Assert.FormatAttribute.#ctor(System.String)"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Assert.Result">
            <summary>Represents the result of running an assertion.</summary>
        </member>
        <member name="M:Emik.Morsels.Assert.Result.#ctor(System.Type)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Assert.Result"/> struct.</summary>
            <param name="setup">The setup to store.</param>
        </member>
        <member name="M:Emik.Morsels.Assert.Result.#ctor(Emik.Morsels.Assert,System.Type)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Assert.Result"/> struct.</summary>
            <param name="assertion">The assertion to store.</param>
            <param name="setup">The setup to store.</param>
        </member>
        <member name="M:Emik.Morsels.Assert.Result.#ctor(System.Exception,System.Type)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Assert.Result"/> struct.</summary>
            <param name="error">The error to store.</param>
            <param name="setup">The setup to store.</param>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.Failed">
            <summary>Gets a value indicating whether <see cref="P:Emik.Morsels.Assert.Result.Assertion"/> has failed.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.HasError">
            <summary>Gets a value indicating whether <see cref="P:Emik.Morsels.Assert.Result.Error"/> is set.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.HasExecuted">
            <summary>Gets a value indicating whether this <see cref="T:Emik.Morsels.Assert.Result"/> has executed.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.Instantiated">
            <summary>Gets a value indicating whether <see cref="P:Emik.Morsels.Assert.Result.Assertion"/> was successfully instantiated.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.IsDefault">
            <summary>Gets a value indicating whether this <see cref="T:Emik.Morsels.Assert.Result"/> is the default instance.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.Succeeded">
            <summary>Gets a value indicating whether <see cref="P:Emik.Morsels.Assert.Result.Assertion"/> has succeeded.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.Message">
            <summary>Gets the message of the assertion.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.Name">
            <summary>Gets the name of the assertion type.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.Assertion">
            <summary>Gets the assertion that ran.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.Error">
            <summary>Gets the error that was thrown while instantiating <see cref="P:Emik.Morsels.Assert.Result.Assertion"/>.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.Default">
            <summary>Gets the default instance.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.Setup">
            <summary>Gets the type that was attempted to be instantiated.</summary>
        </member>
        <member name="P:Emik.Morsels.Assert.Result.Fail">
            <summary>Gets the fail message.</summary>
            <returns>The fail message.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Result.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert.Result.Run">
            <summary>Executes the assertion and returns the new <see cref="T:Emik.Morsels.Assert.Result"/>.</summary>
            <returns>The new instance of <see cref="T:Emik.Morsels.Assert.Result"/> that contains the assertion results.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Result.op_Implicit(System.Type)~Emik.Morsels.Assert.Result">
            <summary>
            Implicitly converts the parameter by creating the new instance of Result by using the constructor
            <see cref="M:Emik.Morsels.Assert.Result.#ctor(System.Type)"/>.
            </summary>
            <param name="setup">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Result by passing the parameter <paramref name="setup"/> to the constructor
            <see cref="M:Emik.Morsels.Assert.Result.#ctor(System.Type)"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Result.op_Implicit(System.ValueTuple{Emik.Morsels.Assert,System.Type})~Emik.Morsels.Assert.Result">
            <summary>
            Implicitly converts the parameter by creating the new instance of Result by using the constructor
            <see cref="M:Emik.Morsels.Assert.Result.#ctor(Emik.Morsels.Assert,System.Type)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Result by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Assert.Result.#ctor(Emik.Morsels.Assert,System.Type)"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Result.op_Implicit(System.ValueTuple{System.Exception,System.Type})~Emik.Morsels.Assert.Result">
            <summary>
            Implicitly converts the parameter by creating the new instance of Result by using the constructor
            <see cref="M:Emik.Morsels.Assert.Result.#ctor(System.Exception,System.Type)"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Result by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Assert.Result.#ctor(System.Exception,System.Type)"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Assert.Throws">
            <summary>Defines the base class for an assertion, where the type must throw.</summary>
        </member>
        <member name="M:Emik.Morsels.Assert.Throws.#ctor(System.Action,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert.Throws.#ctor(System.Func{System.Object},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Assert.Throws`1">
            <summary>
            Defines the base class for an assertion, where the type must throw <typeparamref name="TException"/>.
            </summary>
            <typeparam name="TException">The type of exception to expect to be thrown.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Assert.Throws`1.#ctor(System.Action,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.Assert.Throws`1"/> class.
            </summary>
            <param name="that">The condition that must throw <typeparamref name="TException"/>.</param>
            <param name="message">The message to display when <paramref name="that"/> is false.</param>
            <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
        </member>
        <member name="M:Emik.Morsels.Assert.Throws`1.#ctor(System.Func{System.Object},System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert.Throws`1.#ctor(System.Action,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert.Throws`1.Try(System.Action,System.String@,System.String)">
            <summary>Invokes the callback, expecting <typeparamref name="TException"/> to be thrown.</summary>
            <param name="that">The condition that must throw <typeparamref name="TException"/>.</param>
            <param name="message">The message to display when <paramref name="that"/> is false.</param>
            <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
            <returns>
            Whether <typeparamref name="TException"/> is thrown by the parameter <paramref name="that"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Throws`1.Format(System.String,System.Exception)">
            <summary>Creates the formatted error message.</summary>
            <param name="thatEx">The context of where the error came from.</param>
            <param name="e">The caught exception, if one exists.</param>
            <returns>The formatted error message.</returns>
        </member>
        <member name="M:Emik.Morsels.Assert.Throws`1.Format(System.Exception)">
            <summary>Formats the exception.</summary>
            <param name="e">The caught exception, if one exists.</param>
            <returns>The formatted exception.</returns>
        </member>
        <member name="T:Emik.Morsels.AssertResultEnumerableOperations">
            <summary>
            Methods that provide functions for enumerations of <see cref="T:Emik.Morsels.Assert.Result"/> instances.
            </summary>
        </member>
        <member name="M:Emik.Morsels.AssertResultEnumerableOperations.RunAll(System.Collections.Generic.IEnumerator{Emik.Morsels.Assert.Result})">
            <summary>Eagerly executes all asserts of the passed in enumerator.</summary>
            <param name="enumerator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> to execute.</param>
            <returns>The collected result of all assertions.</returns>
        </member>
        <member name="M:Emik.Morsels.AssertResultEnumerableOperations.RunAll(System.Collections.Generic.IEnumerable{Emik.Morsels.Assert.Result})">
            <summary>Eagerly executes all asserts of the passed in enumerable.</summary>
            <param name="enumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to execute.</param>
            <returns>The collected result of all assertions.</returns>
        </member>
        <member name="T:Emik.Morsels.Assert`1">
            <inheritdoc cref="T:Emik.Morsels.Assert`1"/>
            <summary>Defines the base class for an assertion, where a value is expected to return true.</summary>
            <typeparam name="T">The type of value to assert with.</typeparam>
            <inheritdoc cref="T:Emik.Morsels.Assert`1"/>
            <inheritdoc cref="T:Emik.Morsels.Assert`1"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(`0,System.Predicate{`0},System.String,System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Assert`1"/> class.</summary>
            <param name="it">The context value.</param>
            <param name="that">The condition that must be true.</param>
            <param name="message">The message to display when <paramref name="that"/> is false.</param>
            <param name="itEx">The context of where <paramref name="it"/> came from.</param>
            <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Assert`1"/> class.</summary>
            <param name="x">The first context value.</param>
            <param name="y">The second context value.</param>
            <param name="that">The condition that must be true.</param>
            <param name="message">The message to display when <paramref name="that"/> is false.</param>
            <param name="xEx">The context of where <paramref name="x"/> came from.</param>
            <param name="yEx">The context of where <paramref name="y"/> came from.</param>
            <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Predicate{`0},`0,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,System.Predicate{`0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Func{`0},System.Predicate{`0},System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,System.Predicate{`0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Predicate{`0},System.Func{`0},System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,System.Predicate{`0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(`0,System.Func{`0,`0,System.Boolean},`0,System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Func{`0,`0,System.Boolean},`0,`0,System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(`0,System.Func{`0},System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Func{`0},`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Func{`0},System.Func{`0},System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Func{`0},System.Func{`0,`0,System.Boolean},System.Func{`0},System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Func{`0},System.Func{`0,`0,System.Boolean},`0,System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(`0,System.Func{`0,`0,System.Boolean},System.Func{`0},System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0},System.Func{`0},System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0},`0,System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.#ctor(System.Func{`0,`0,System.Boolean},`0,System.Func{`0},System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Assert`1.#ctor(`0,`0,System.Func{`0,`0,System.Boolean},System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.EqualTo(`0,`0)">
            <inheritdoc cref="M:Emik.Morsels.Assert.EqualTo``1(``0,``0)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.GreaterThan(`0,`0)">
            <inheritdoc cref="M:Emik.Morsels.Assert.GreaterThan``1(``0,``0)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.GreaterThanOrEqualTo(`0,`0)">
            <inheritdoc cref="M:Emik.Morsels.Assert.GreaterThanOrEqualTo``1(``0,``0)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.LessThan(`0,`0)">
            <inheritdoc cref="M:Emik.Morsels.Assert.LessThan``1(``0,``0)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.LessThanOrEqualTo(`0,`0)">
            <inheritdoc cref="M:Emik.Morsels.Assert.LessThanOrEqualTo``1(``0,``0)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.NotNull(`0)">
            <inheritdoc cref="M:Emik.Morsels.Assert.NotNull``1(``0)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.Null(`0)">
            <inheritdoc cref="M:Emik.Morsels.Assert.Null``1(``0)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.SequenceEqualTo(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:Emik.Morsels.Assert.SequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.UnequalTo(`0,`0)">
            <inheritdoc cref="M:Emik.Morsels.Assert.UnequalTo``1(``0,``0)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.Compare(`0,`0)">
            <inheritdoc cref="M:Emik.Morsels.Assert.Compare``1(``0,``0)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.InRangeOf(`0,`0)">
            <inheritdoc cref="M:Emik.Morsels.Assert.InRangeOf``1(``0,``0)"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.Structured(`0[])">
            <inheritdoc cref="M:Emik.Morsels.Assert.Structured``1(``0[])"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.Params(`0[])">
            <inheritdoc cref="M:Emik.Morsels.Assert.Params``1(``0[])"/>
        </member>
        <member name="T:Emik.Morsels.Assert`1.Throws">
            <summary>Defines the base class for an assertion, where the type must throw.</summary>
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws.#ctor(System.Action{`0},`0,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws.#ctor(System.Converter{`0,System.Object},`0,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws.#ctor(`0,System.Action{`0},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws.#ctor(`0,System.Converter{`0,System.Object},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws.#ctor(System.Action{`0},System.Func{`0},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws.#ctor(System.Converter{`0,System.Object},System.Func{`0},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws.#ctor(System.Func{`0},System.Action{`0},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws.#ctor(System.Func{`0},System.Converter{`0,System.Object},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Assert`1.Throws`1">
            <inheritdoc cref="T:Emik.Morsels.Assert.Throws`1"/>
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws`1.#ctor(System.Action{`0},`0,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws`1.#ctor(System.Converter{`0,System.Object},`0,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws`1.#ctor(`0,System.Action{`0},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws`1.#ctor(`0,System.Converter{`0,System.Object},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws`1.#ctor(System.Action{`0},System.Func{`0},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws`1.#ctor(System.Converter{`0,System.Object},System.Func{`0},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws`1.#ctor(System.Func{`0},System.Action{`0},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Assert`1.Throws`1.#ctor(System.Func{`0},System.Converter{`0,System.Object},System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Exit">
            <summary>Provides methods for exiting the program.</summary>
        </member>
        <member name="M:Emik.Morsels.Exit.Success(System.String)">
            <remarks><para>This method represents the exit code 0, indicating success.</para></remarks>
            <inheritdoc cref="M:Emik.Morsels.Exit.With(System.Byte,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.Failure(System.String)">
            <remarks><para>This method represents the exit code 1, indicating failure.</para></remarks>
            <inheritdoc cref="M:Emik.Morsels.Exit.With(System.Byte,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.Usage(System.String)">
            <remarks><para>This method represents the exit code 2, indicating invalid parameters.</para></remarks>
            <inheritdoc cref="M:Emik.Morsels.Exit.With(System.Byte,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.Success``1(System.String)">
            <typeparam name="T">Only used for type coercion.</typeparam>
            <inheritdoc cref="M:Emik.Morsels.Exit.Success(System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.Failure``1(System.String)">
            <typeparam name="T">Only used for type coercion.</typeparam>
            <inheritdoc cref="M:Emik.Morsels.Exit.Failure(System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.Usage``1(System.String)">
            <typeparam name="T">Only used for type coercion.</typeparam>
            <inheritdoc cref="M:Emik.Morsels.Exit.Usage(System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.With(System.Byte,System.String)">
            <summary>Terminates this process and returns the exit code to the operating system.</summary>
            <param name="message">The message to print into the standard output/error, if specified.</param>
            <exception cref="T:System.Security.SecurityException">
            The caller does not have sufficient security permission to perform this function.
            </exception>
            <returns>This method does not return. Specified to allow <see langword="throw"/> expressions.</returns>
        </member>
        <member name="T:Emik.Morsels.Peeks">
            <summary>Provides methods to use callbacks within a statement.</summary>
        </member>
        <member name="F:Emik.Morsels.Peeks.Clear">
            <summary>The escape sequence to clear the screen.</summary>
        </member>
        <member name="E:Emik.Morsels.Peeks.OnWrite">
            <summary>An event that is invoked every time <see cref="M:Emik.Morsels.Peeks.Write(System.String)"/> is called.</summary>
        </member>
        <member name="P:Emik.Morsels.Peeks.AllTypes">
            <summary>Gets all the types currently loaded.</summary>
        </member>
        <member name="M:Emik.Morsels.Peeks.Shout(System.String)">
            <summary>
            Invokes <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>, and <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)"/>.
            </summary>
            <remarks><para>
            This method exists to be able to hook both conditional methods in <see cref="E:Emik.Morsels.Peeks.OnWrite"/>,
            and to allow the consumer to be able to remove this method to the same <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.
            </para></remarks>
            <param name="message">The value to send a message.</param>
        </member>
        <member name="M:Emik.Morsels.Peeks.Write(System.String)">
            <summary>Quick and dirty debugging function, invokes <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.</summary>
            <param name="message">The value to send a message.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
        </member>
        <member name="M:Emik.Morsels.Peeks.Write``1(``0)">
            <summary>Quick and dirty debugging function, invokes <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to stringify.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
        </member>
        <member name="M:Emik.Morsels.Peeks.Debug``1(``0,System.Boolean,System.Boolean,System.Converter{``0,System.Object},System.Predicate{``0},System.Action{System.String},System.String,System.String,System.Int32,System.String)">
            <summary>Quick and dirty debugging function.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to stringify and return.</param>
            <param name="shouldPrettify">Determines whether to prettify the resulting <see cref="T:System.String"/>.</param>
            <param name="shouldLogExpression">Determines whether <paramref name="expression"/> is logged.</param>
            <param name="map">The map callback.</param>
            <param name="filter">The filter callback.</param>
            <param name="logger">The logging callback.</param>
            <param name="expression">Automatically filled by compilers; the source code of <paramref name="value"/>.</param>
            <param name="path">Automatically filled by compilers; the file's path where this method was called.</param>
            <param name="line">Automatically filled by compilers; the line number where this method was called.</param>
            <param name="member">Automatically filled by compilers; the member's name where this method was called.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Peeks.Debug``2(``0,System.Boolean,System.Boolean,System.Converter{``0,``1},System.Predicate{``0},System.Action{System.String},System.String,System.String,System.Int32,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Peeks.Debug``1(``0,System.Boolean,System.Boolean,System.Converter{``0,System.Object},System.Predicate{``0},System.Action{System.String},System.String,System.String,System.Int32,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Peeks.Debug``1(System.Span{``0}@,System.Boolean,System.Boolean,System.Converter{``0[],System.Object},System.Predicate{``0[]},System.Action{System.String},System.String,System.String,System.Int32,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Peeks.Debug``1(``0,System.Boolean,System.Boolean,System.Converter{``0,System.Object},System.Predicate{``0},System.Action{System.String},System.String,System.String,System.Int32,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Peeks.Debug``3(Emik.Morsels.SplitSpan{``0,``1,``2}@,System.Boolean,System.Boolean,System.Converter{``0[][],System.Object},System.Predicate{``0[][]},System.Action{System.String},System.String,System.String,System.Int32,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Peeks.Debug``1(``0,System.Boolean,System.Boolean,System.Converter{``0,System.Object},System.Predicate{``0},System.Action{System.String},System.String,System.String,System.Int32,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Peeks.Debug``1(System.ReadOnlySpan{``0},System.Boolean,System.Boolean,System.Converter{``0[],System.Object},System.Predicate{``0[]},System.Action{System.String},System.String,System.String,System.Int32,System.String)">
            <inheritdoc cref="M:Emik.Morsels.Peeks.Debug``1(``0,System.Boolean,System.Boolean,System.Converter{``0,System.Object},System.Predicate{``0},System.Action{System.String},System.String,System.String,System.Int32,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Peeks.Peek``1(``0,System.Action{``0})">
            <summary>Executes an <see cref="T:System.Action`1"/>, and returns the argument.</summary>
            <typeparam name="T">The type of value and action parameter.</typeparam>
            <param name="value">The value to pass into the callback.</param>
            <param name="action">The callback to perform.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Peeks.Then``2(``0,System.Converter{``0,``1})">
            <summary>Executes the function, and returns the result.</summary>
            <typeparam name="T">The type of value and input parameter.</typeparam>
            <typeparam name="TResult">The type of output and return value.</typeparam>
            <param name="value">The value to pass into the callback.</param>
            <param name="converter">The callback to perform.</param>
            <returns>The return value of <paramref name="converter"/> after passing in <paramref name="value"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Unforgiving">
            <summary>Provides a reference for an <c>UnreachableException</c>.</summary>
        </member>
        <member name="P:Emik.Morsels.Unforgiving.CannotBeEmpty">
            <summary>Gets the <see cref="T:System.Exception"/> that a collection cannot be empty.</summary>
        </member>
        <member name="P:Emik.Morsels.Unforgiving.Todo">
            <summary>Gets the <see cref="T:System.Exception"/> that represents unfinished logic.</summary>
        </member>
        <member name="P:Emik.Morsels.Unforgiving.Unreachable">
            <summary>Gets the <see cref="T:System.Exception"/> that represents an unreachable state.</summary>
        </member>
        <member name="T:Emik.Morsels.Attachments">
            <summary>Adds support for Append and Prepend in lower frameworks.</summary>
        </member>
        <member name="M:Emik.Morsels.Attachments.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Appends a value to the end of the sequence.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values.</param>
            <param name="element">The value to append to <paramref name="source"/>.</param>
            <returns>A new sequence that ends with <paramref name="element"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Attachments.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Prepends a value to the end of the sequence.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values.</param>
            <param name="element">The value to prepend to <paramref name="source"/>.</param>
            <returns>A new sequence that starts with <paramref name="element"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.CartesianProductFactories">
            <summary>Extension methods to create cartesian products.</summary>
        </member>
        <member name="M:Emik.Morsels.CartesianProductFactories.CartesianProduct``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>Creates a cartesian product from two collections.</summary>
            <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
            <typeparam name="T1">The type of item in the first set.</typeparam>
            <typeparam name="T2">The type of item in the second set.</typeparam>
            <param name="first">The first set to create a cartesian product of.</param>
            <param name="second">The second set to create a cartesian product of.</param>
            <returns>
            The cartesian product of the parameter <paramref name="first"/> and <paramref name="second"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.CartesianProductFactories.CartesianProduct``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>Creates a cartesian product from three collections.</summary>
            <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
            <typeparam name="T1">The type of item in the first set.</typeparam>
            <typeparam name="T2">The type of item in the second set.</typeparam>
            <typeparam name="T3">The type of item in the third set.</typeparam>
            <param name="first">The first set to create a cartesian product of.</param>
            <param name="second">The second set to create a cartesian product of.</param>
            <param name="third">The third set to create a cartesian product of.</param>
            <returns>
            The cartesian product of the parameter <paramref name="first"/>,
            <paramref name="second"/>, and <paramref name="third"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.CartesianProductFactories.CartesianProduct``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})">
            <summary>Creates a cartesian product from four collections.</summary>
            <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
            <typeparam name="T1">The type of item in the first set.</typeparam>
            <typeparam name="T2">The type of item in the second set.</typeparam>
            <typeparam name="T3">The type of item in the third set.</typeparam>
            <typeparam name="T4">The type of item in the fourth set.</typeparam>
            <param name="first">The first set to create a cartesian product of.</param>
            <param name="second">The second set to create a cartesian product of.</param>
            <param name="third">The third set to create a cartesian product of.</param>
            <param name="fourth">The fourth set to create a cartesian product of.</param>
            <returns>
            The cartesian product of the parameter <paramref name="first"/>, <paramref name="second"/>,
            <paramref name="third"/>, and <paramref name="fourth"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.CartesianProductFactories.CartesianProduct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}[])">
            <summary>Creates a cartesian product from n-collections.</summary>
            <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
            <typeparam name="T">The type of item in the set.</typeparam>
            <param name="first">The first set to create a cartesian product of.</param>
            <param name="rest">The rest of the sets to create a cartesian product of.</param>
            <returns>
            The cartesian product of the parameter <paramref name="first"/>, and all of <paramref name="rest"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.CartesianProductFactories.CartesianProduct``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Creates a cartesian product from n-collections.</summary>
            <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
            <typeparam name="T">The type of item in the set.</typeparam>
            <param name="iterable">The sets to create a cartesian product of.</param>
            <returns>The cartesian product of all of the parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Choices">
            <summary>Provides methods to calculate various binomial coefficients.</summary>
        </member>
        <member name="M:Emik.Morsels.Choices.Choose(System.Int32,System.Int32)">
            <summary>Calculates the binomial coefficient (nCk) (N items, choose k).</summary>
            <remarks><para>
            Implementation based on <a href="https://stackoverflow.com/a/19125294/18052726">Moop's solution</a>.
            </para></remarks>
            <param name="n">The number of items.</param>
            <param name="k">The number to choose.</param>
            <returns>
            <math><mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>k</mi></mfrac><mo>)</mo></mrow></math>
            </returns>
        </member>
        <member name="M:Emik.Morsels.Choices.Choose(System.Int64,System.Int64)">
            <inheritdoc cref="M:Emik.Morsels.Choices.Choose(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.Choices.Choose``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Calculates the binomial coefficient (nCk) (N items, choose k).</summary>
            <typeparam name="T">The type of items to choose from.</typeparam>
            <param name="n">The items to choose from.</param>
            <param name="k">The amount of items to choose.</param>
            <returns>
            The <see cref="T:System.Collections.Generic.ICollection`1"/> of <see cref="T:System.Collections.Generic.IList`1"/> containing the binomial coefficients.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Choices`1">
            <summary>Provides methods to calculate various binomial coefficients.</summary>
            <typeparam name="T">The type of element.</typeparam>
            <param name="n">The collection to choose from.</param>
            <param name="k">The number to choose.</param>
        </member>
        <member name="M:Emik.Morsels.Choices`1.#ctor(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>Provides methods to calculate various binomial coefficients.</summary>
            <typeparam name="T">The type of element.</typeparam>
            <param name="n">The collection to choose from.</param>
            <param name="k">The number to choose.</param>
        </member>
        <member name="T:Emik.Morsels.Choices`1.Enumerator">
            <summary>Provides the enumerator for the <see cref="T:Emik.Morsels.Choices`1"/> struct.</summary>
            <param name="n">The collection to choose from.</param>
            <param name="k">The number to choose.</param>
        </member>
        <member name="M:Emik.Morsels.Choices`1.Enumerator.#ctor(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>Provides the enumerator for the <see cref="T:Emik.Morsels.Choices`1"/> struct.</summary>
            <param name="n">The collection to choose from.</param>
            <param name="k">The number to choose.</param>
        </member>
        <member name="P:Emik.Morsels.Choices`1.Enumerator.K">
            <inheritdoc cref="P:Emik.Morsels.Choices`1.K"/>
        </member>
        <member name="P:Emik.Morsels.Choices`1.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.Choices`1.Enumerator.N">
            <inheritdoc cref="P:Emik.Morsels.Choices`1.N"/>
        </member>
        <member name="P:Emik.Morsels.Choices`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.Enumerator.Reset(System.Int32[],System.Int32)">
            <summary>Resets the provided array to the initial state.</summary>
            <param name="values">The array to fill.</param>
            <param name="k">
            The length of the area to fill, assumed to be at least
            the length of the parameter <paramref name="values"/>.
            </param>
            <returns>The parameter <paramref name="values"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Choices`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Choices`1.System#Collections#Generic#ICollection{System#Collections#Generic#IList{T}}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Choices`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.Choices`1.K">
            <summary>Gets the number of choices.</summary>
        </member>
        <member name="P:Emik.Morsels.Choices`1.N">
            <summary>Gets the list of choices.</summary>
        </member>
        <member name="P:Emik.Morsels.Choices`1.First">
            <summary>Gets the first <see cref="P:Emik.Morsels.Choices`1.K"/> choices.</summary>
        </member>
        <member name="P:Emik.Morsels.Choices`1.Last">
            <summary>Gets the last <see cref="P:Emik.Morsels.Choices`1.K"/> choices.</summary>
        </member>
        <member name="M:Emik.Morsels.Choices`1.op_Equality(Emik.Morsels.Choices{`0},Emik.Morsels.Choices{`0})">
            <summary>Determines whether the specified objects are equal.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether the specified objects are equal.</returns>
        </member>
        <member name="M:Emik.Morsels.Choices`1.op_Inequality(Emik.Morsels.Choices{`0},Emik.Morsels.Choices{`0})">
            <summary>Determines whether the specified objects are unequal.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>Whether the specified objects are unequal.</returns>
        </member>
        <member name="M:Emik.Morsels.Choices`1.System#Collections#Generic#ICollection{System#Collections#Generic#IList{T}}#Add(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.System#Collections#Generic#ICollection{System#Collections#Generic#IList{T}}#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.CopyTo(System.Collections.Generic.IList{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.Contains(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.Equals(Emik.Morsels.Choices{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.System#Collections#Generic#ICollection{System#Collections#Generic#IList{T}}#Remove(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.IndexOf(System.Collections.Generic.IList{`0})">
            <inheritdoc cref="M:System.Collections.Generic.IList`1.IndexOf(`0)"/>
        </member>
        <member name="M:Emik.Morsels.Choices`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:Emik.Morsels.Choices`1.System#Collections#Generic#IEnumerable{System#Collections#Generic#IList{T}}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Choices`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Collected">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Collected.ToArrayLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Upcasts or creates an <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to upcast or encapsulate.</param>
            <returns>Itself as <see cref="T:System.Collections.Generic.IList`1"/>, or collected.</returns>
        </member>
        <member name="M:Emik.Morsels.Collected.WithCount``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Wraps the <see cref="T:System.Collections.Generic.IEnumerable`1"/> in a known-size collection type.</summary>
            <remarks><para>The parameter <paramref name="count"/> is assumed to be correct.</para></remarks>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to encapsulate.</param>
            <param name="count">The number of elements in the parameter <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/> as a <see cref="T:Emik.Morsels.Collected.Collection`1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Collected.ToCollectionLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Upcasts or creates an <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to upcast or encapsulate.</param>
            <returns>Itself as <see cref="T:System.Collections.Generic.ICollection`1"/>, or collected.</returns>
        </member>
        <member name="M:Emik.Morsels.Collected.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns a fallback enumeration if the collection given is null or empty.</summary>
            <typeparam name="T">The type of item within the enumeration.</typeparam>
            <param name="iterable">The potentially empty collection.</param>
            <param name="fallback">The fallback value.</param>
            <returns>
            The parameter <paramref name="iterable"/> when non-empty, otherwise; <paramref name="fallback"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Collected.ToListLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Upcasts or creates an <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to upcast or encapsulate.</param>
            <returns>Itself as <see cref="T:System.Collections.Generic.IList`1"/>, or collected.</returns>
        </member>
        <member name="T:Emik.Morsels.Collected.Collection`1">
            <summary>Provides a wrapper to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a known count.</summary>
            <param name="enumerable">The enumerable to encapsulate.</param>
            <param name="count">The pre-computed count.</param>
            <typeparam name="T">The type of element in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Collected.Collection`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>Provides a wrapper to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a known count.</summary>
            <param name="enumerable">The enumerable to encapsulate.</param>
            <param name="count">The pre-computed count.</param>
            <typeparam name="T">The type of element in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
        </member>
        <member name="P:Emik.Morsels.Collected.Collection`1.System#Collections#ICollection#IsSynchronized">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Collected.Collection`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Collected.Collection`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Collected.Collection`1.SyncRoot">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Collected.Collection`1.CopyTo(System.Array,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Collected.Collection`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Collected.Collection`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Collected.Collection`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Collected.Collection`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Collected.Collection`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Collected.Collection`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Collected.Collection`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Each">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32,System.Action)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32,System.Action{System.Int32})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0,System.Action{``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0,System.Action{System.Int32,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,System.Int32,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IDictionary{``0,``1},System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{``0,``1,``2})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IDictionary{``0,``1},System.Action{``0,``1,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{``0,``1,System.Int32,``2})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <param name="num">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.GetEnumerator(System.Int32)">
            <summary>Gets an enumeration of a number.</summary>
            <param name="num">The index to count up or down to.</param>
            <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Int32"/> from ranges 0 to <paramref name="upper"/> - 1.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,System.Func{``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TResult">The type of iterator.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The function for each loop.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,System.Converter{System.Int32,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TResult">The type of iterator.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The function for each loop.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.FindAll``1(``0[],System.Predicate{``0})">
            <inheritdoc cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})"/>
        </member>
        <member name="M:Emik.Morsels.Each.ConvertAll``2(``0[],System.Converter{``0,``1})">
            <inheritdoc cref="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})"/>
        </member>
        <member name="M:Emik.Morsels.Each.AsReadOnly``1(``0[])">
            <inheritdoc cref="M:System.Array.AsReadOnly``1(``0[])"/>
        </member>
        <member name="T:Emik.Morsels.EachLazy">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,System.Int32,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Enumerable`2">
            <summary>
            Defines an <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a <see cref="T:System.Delegate"/> that is invoked on iteration.
            </summary>
            <typeparam name="T">The type of item in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TExternal">The context element to pass into the <see cref="T:System.Delegate"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32,`1})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Delegate)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Enumerable`2"/> class.</summary>
            <param name="enumerable">
            The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create an <see cref="T:System.Collections.Generic.IEnumerator`1"/> from.
            </param>
            <param name="external">The context element.</param>
            <param name="action">The <see cref="T:System.Delegate"/> to invoke on iteration.</param>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Enumerable`2.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Enumerable`2.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.op_Implicit(System.ValueTuple{System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0}})~Emik.Morsels.Enumerable{`0,`1}">
            <summary>
            Implicitly converts the parameter by creating the new instance of Enumerable{T, TExternal} by using the constructor
            <see cref="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0})"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Enumerable{T, TExternal} by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0})"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.op_Implicit(System.ValueTuple{System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32}})~Emik.Morsels.Enumerable{`0,`1}">
            <summary>
            Implicitly converts the parameter by creating the new instance of Enumerable{T, TExternal} by using the constructor
            <see cref="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32})"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Enumerable{T, TExternal} by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32})"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.op_Implicit(System.ValueTuple{System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,`1}})~Emik.Morsels.Enumerable{`0,`1}">
            <summary>
            Implicitly converts the parameter by creating the new instance of Enumerable{T, TExternal} by using the constructor
            <see cref="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,`1})"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Enumerable{T, TExternal} by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,`1})"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.op_Implicit(System.ValueTuple{System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32,`1}})~Emik.Morsels.Enumerable{`0,`1}">
            <summary>
            Implicitly converts the parameter by creating the new instance of Enumerable{T, TExternal} by using the constructor
            <see cref="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32,`1})"/>.
            </summary>
            <param name="tuple">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of Enumerable{T, TExternal} by passing the parameter <paramref name="tuple"/> to the constructor
            <see cref="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32,`1})"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.EachWithControlFlow">
            <summary>Similar to <see cref="T:Emik.Morsels.Each"/>, but with control flow, using <see cref="T:Emik.Morsels.ControlFlow"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor(System.Int32,System.Func{Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor(System.Int32,System.Func{System.Int32,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor``1(System.Int32,``0,System.Func{``0,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor``1(System.Int32,``0,System.Func{System.Int32,``0,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,``1,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,System.Int32,``1,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{``0,``1,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Func{``0,``1,``2,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{``0,``1,System.Int32,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.BreakableFor``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Func{``0,``1,System.Int32,``2,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.ControlFlow">
            <summary>Determines control flow for loops in <see cref="T:Emik.Morsels.Each"/>.</summary>
        </member>
        <member name="F:Emik.Morsels.ControlFlow.Continue">
            <summary>The value indicating that the loop should continue.</summary>
        </member>
        <member name="F:Emik.Morsels.ControlFlow.Break">
            <summary>The value indicating that the loop should break.</summary>
        </member>
        <member name="T:Emik.Morsels.EnumeratorToEnumerable">
            <summary>Provides methods to convert <see cref="T:System.Collections.Generic.IEnumerator`1"/> to <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="T:Emik.Morsels.EnumeratorToEnumerable.ComparerCollector">
            <summary>Collects <see cref="T:System.Collections.IComparer"/> and <see cref="T:System.Collections.IEqualityComparer"/> instances.</summary>
        </member>
        <member name="F:Emik.Morsels.EnumeratorToEnumerable.ComparerCollector.Capacity">
            <summary>The most common usage is with tuples, in which the maximum capacity is 8.</summary>
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.ComparerCollector.System#Collections#IEqualityComparer#Equals(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.ComparerCollector.System#Collections#IComparer#Compare(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.ComparerCollector.System#Collections#IEqualityComparer#GetHashCode(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.EnumeratorToEnumerable.Enumerable`1">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IEnumerator`1"/> and exposes it from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> context.
            </summary>
            <param name="enumerator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> to encapsulate.</param>
            <typeparam name="T">The type of item to enumerate.</typeparam>
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.Enumerable`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IEnumerator`1"/> and exposes it from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> context.
            </summary>
            <param name="enumerator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> to encapsulate.</param>
            <typeparam name="T">The type of item to enumerate.</typeparam>
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.Enumerable`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.Enumerable`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.Enumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.EnumeratorToEnumerable.Enumerator">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IEnumerator`1"/> and exposes it from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> context.
            </summary>
            <param name="enumerator">The enumerator to encapsulate.</param>
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.Enumerator.#ctor(System.Collections.IEnumerator)">
            <summary>
            Wraps an <see cref="T:System.Collections.Generic.IEnumerator`1"/> and exposes it from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> context.
            </summary>
            <param name="enumerator">The enumerator to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.EnumeratorToEnumerable.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current" />
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.AsGeneric(System.Collections.IEnumerator)">
            <summary>Wraps the enumerator inside an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <param name="enumerator">The enumerator to encapsulate.</param>
            <returns>
            The <see cref="T:System.Collections.Generic.IEnumerator`1"/> instance that returns the parameter <paramref name="enumerator"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.AsEnumerable(System.Collections.IEnumerator)">
            <summary>Wraps the enumerator inside an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <param name="enumerator">The enumerator to encapsulate.</param>
            <returns>The <see cref="T:System.Collections.Generic.IEnumerator`1"/> instance that wraps <paramref name="enumerator"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.AsGenericEnumerable(System.Array)">
            <summary>Wraps the array inside an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <param name="array">The array to encapsulate.</param>
            <returns>The <see cref="T:System.Collections.Generic.IEnumerator`1"/> instance that wraps <paramref name="array"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumeratorToEnumerable.AsEnumerable``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>Wraps the <see cref="T:System.Collections.Generic.IEnumerator`1"/> inside an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <typeparam name="T">The type of item to enumerate.</typeparam>
            <param name="enumerator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> to encapsulate.</param>
            <returns>The <see cref="T:System.Collections.Generic.IEnumerator`1"/> instance that wraps <paramref name="enumerator"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Force">
            <summary>Extension methods to force full enumerations.</summary>
        </member>
        <member name="M:Emik.Morsels.Force.Enumerate(System.Collections.IEnumerable)">
            <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
            <param name="iterable">The collection of items to go through one-by-one.</param>
        </member>
        <member name="M:Emik.Morsels.Force.Enumerate``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
        </member>
        <member name="T:Emik.Morsels.Indexers">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Indexers.For(System.Index)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <param name="index">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.For(System.Range)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
            See here for more information.
            </a></para></remarks>
            <param name="range">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.Deconstruct``1(System.Collections.Generic.IEnumerable{``0},``0@,System.Collections.Generic.IEnumerable{``0}@)">
            <summary>Separates the head from the tail of an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <remarks><para>
            The tail is not guaranteed to be able to be enumerated over multiple times.
            As such, use a method like <see cref="M:Emik.Morsels.Collected.ToCollectionLazily``1(System.Collections.Generic.IEnumerable{``0})"/> if multiple enumerations are needed.
            </para></remarks>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="enumerable">The enumerable to split.</param>
            <param name="head">The first element of the parameter <paramref name="enumerable"/>.</param>
            <param name="tail">The rest of the parameter <paramref name="enumerable"/>.</param>
        </member>
        <member name="M:Emik.Morsels.Indexers.Nth(System.String,System.Index)">
            <summary>Gets a specific item from a collection.</summary>
            <param name="str">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="str"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Index)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.Nth(System.String,System.Range)">
            <summary>Gets a specific item from a collection.</summary>
            <param name="str">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="range">The index to get.</param>
            <returns>An element from the parameter <paramref name="str"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Range)">
            <summary>Gets a range of items from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get a range of items from.</param>
            <param name="range">The ranges to get.</param>
            <returns>A slice from the parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.GetEnumerator(System.Index)">
            <summary>Gets an enumeration of an index.</summary>
            <param name="index">The index to count up or down to.</param>
            <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.GetEnumerator(System.Range)">
            <summary>Gets an enumeration of a range.</summary>
            <param name="range">The range to iterate over.</param>
            <returns>An enumeration from the range's start to end.</returns>
        </member>
        <member name="T:Emik.Morsels.NegatedEnumerable">
            <summary>Extension methods that negate functions from <see cref="T:System.Linq.Enumerable"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.DistinctDuplicates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.</summary>
            <remarks><para>
            Filters out unique elements within an <see cref="!:Enumerable&lt;T&gt;"/>.
            Each duplicate appears exactly once within the returned value.
            </para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Collections.Generic.IEnumerable`1"/> and <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.</typeparam>
            <param name="source">The source to filter.</param>
            <param name="comparer">The comparer to assess distinctiveness.</param>
            <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.Duplicates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.</summary>
            <remarks><para>
            Filters out unique elements within an <see cref="!:Enumerable&lt;T&gt;"/>.
            Each duplicate appears two or more times within the returned value.
            </para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Collections.Generic.IEnumerable`1"/> and <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.</typeparam>
            <param name="source">The source to filter.</param>
            <param name="comparer">The comparer to assess distinctiveness.</param>
            <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.GroupDuplicates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.</summary>
            <remarks><para>Filters out unique elements within an <see cref="!:Enumerable&lt;T&gt;"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Collections.Generic.IEnumerable`1"/> and <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.</typeparam>
            <param name="source">The source to filter.</param>
            <param name="comparer">The comparer to assess distinctiveness.</param>
            <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.SkipUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements from the input sequence starting at
            the first element in the linear series that does pass the test specified by the predicate.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.SplitEvery``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Negated <see cref="!:Enumerable.SelectMany&lt;T&gt;(IEnumerable&lt;T&gt;, Func&lt;T, IEnumerable&lt;T&gt;&gt;)"/>.</summary>
            <remarks><para>
            Splits the <see cref="T:System.Collections.Generic.IEnumerable`1"/> into multiple <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            instances in at most the specified length.
            </para></remarks>
            <typeparam name="T">The type of the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to chop into slices.</param>
            <param name="count">The maximum length of any given returned <see cref="T:System.Collections.Generic.IEnumerable`1"/> instances.</param>
            <returns>The wrapper of the parameter <paramref name="source"/> that returns slices of it.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.TakeUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements from the input
            sequence that occur before the element at which the test no longer fails.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.TakeUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.Omit``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.Omit``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="T:Emik.Morsels.Pancake">
            <summary>Provides methods to flatten <see cref="T:System.Collections.Generic.IEnumerable`1"/> instances.</summary>
        </member>
        <member name="M:Emik.Morsels.Pancake.Flatten``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Flattens the nested collection.</summary>
            <typeparam name="T">The type of collection.</typeparam>
            <param name="enumerable">The collection to flatten.</param>
            <returns>The flattened collection of the parameter <paramref name="enumerable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Pancake.Flatten2``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}}})">
            <inheritdoc cref="M:Emik.Morsels.Pancake.Flatten``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:Emik.Morsels.Pancake.Flatten3``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}}}})">
            <inheritdoc cref="M:Emik.Morsels.Pancake.Flatten``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:Emik.Morsels.Pancake.Flatten4``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}}}}})">
            <inheritdoc cref="M:Emik.Morsels.Pancake.Flatten``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:Emik.Morsels.Pancake.Flatten5``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}}}}}})">
            <inheritdoc cref="M:Emik.Morsels.Pancake.Flatten``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:Emik.Morsels.Pancake.Flatten6``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}}}}}}})">
            <inheritdoc cref="M:Emik.Morsels.Pancake.Flatten``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:Emik.Morsels.Pancake.Transpose``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Flattens the nested collection by taking all the first elements of the enumerations,
            then all the second elements of the enumerations, the third, and so on.
            When any enumeration runs out, it simply moves onto the next enumeration until all enumerations are finished.
            </summary>
            <typeparam name="T">The type of collection.</typeparam>
            <param name="enumerable">The collection to flatten.</param>
            <returns>
            The flattened collection by taking items in order of appearance of each individual enumerable,
            and only then by the outer enumerable.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Permuted">
            <summary>Provides methods for creating combinations of items.</summary>
        </member>
        <member name="M:Emik.Morsels.Permuted.Combinations``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Generates all combinations of the nested enumerable.</summary>
            <typeparam name="T">The type of nested enumerable.</typeparam>
            <param name="iterator">The input to generate combinations of.</param>
            <returns>Every combination of the items in <paramref name="iterator"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Permuted.Combinations``1(System.Collections.Generic.IList{System.Collections.Generic.IList{``0}})">
            <summary>Generates all combinations of the nested list.</summary>
            <typeparam name="T">The type of nested list.</typeparam>
            <param name="lists">The input to generate combinations of.</param>
            <returns>Every combination of the items in <paramref name="lists"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Permuted.Combinations``1(Emik.Morsels.SmallList{Emik.Morsels.SmallList{``0}})">
            <summary>Generates all combinations of the nested list.</summary>
            <typeparam name="T">The type of nested list.</typeparam>
            <param name="lists">The input to generate combinations of.</param>
            <returns>Every combination of the items in <paramref name="lists"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Permuted.SmallListCombinations``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Generates all combinations of the nested enumerable.</summary>
            <typeparam name="T">The type of nested enumerable.</typeparam>
            <param name="iterator">The input to generate combinations of.</param>
            <returns>Every combination of the items in <paramref name="iterator"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.PowerSetFactories">
            <summary>Extension methods to create power sets.</summary>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet(System.Collections.ICollection)">
            <inheritdoc cref="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})">
            <summary>Creates a power set from a collection.</summary>
            <remarks><para>
            The power set is defined as the set of all subsets, including the empty set and the set itself.
            </para></remarks>
            <typeparam name="T">The type of item in the set.</typeparam>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The argument <paramref name="collection"/> has 32 or more elements.
            </exception>
            <param name="collection">The set to create a power set.</param>
            <returns>The power set of the parameter <paramref name="collection"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <inheritdoc cref="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet``1(``0[])">
            <inheritdoc cref="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="T:Emik.Morsels.TryAccessCount">
            <summary>Extension methods to attempt to grab the length from enumerables.</summary>
        </member>
        <member name="M:Emik.Morsels.TryAccessCount.TryCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Tries to count the elements in the enumerable.</summary>
            <typeparam name="T">The type of element in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <param name="enumerable">The enumerable to count.</param>
            <returns>
            If relatively cheap to compute, the number of elements in the parameter
            <paramref name="enumerable"/>; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.TryAccessSpan">
            <summary>Extension methods to attempt to grab the span from enumerables.</summary>
        </member>
        <member name="T:Emik.Morsels.TryTake">
            <summary>Extension methods to attempt to grab ranges from enumerables.</summary>
        </member>
        <member name="M:Emik.Morsels.TryTake.EnumerateOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the last item lazily, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.FirstOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the first item, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The first item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.LastOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the last item, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Nth``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="TKey">The key item in the collection.</typeparam>
            <typeparam name="TValue">The value item in the collection.</typeparam>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="key">The key to use to get the value.</param>
            <returns>An element from the parameter <paramref name="dictionary"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Or``1(``0,``0)">
            <summary>Returns the item, or a fallback.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="self">The item to potentially return.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The parameter <paramref name="self"/>, or <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Or``1(System.Nullable{``0},``0)">
            <summary>Returns the item, or a fallback.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="self">The item to potentially return.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The parameter <paramref name="self"/>, or <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.OrNew``1(``0)">
            <summary>Returns the item, or a fallback.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="self">The item to potentially return.</param>
            <returns>The parameter <paramref name="self"/>, or a new instance.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.OrEmpty(System.String)">
            <summary>Returns the string, or an empty string.</summary>
            <param name="str">The string to potentially return.</param>
            <returns>The parameter <paramref name="str"/>, or <see cref="F:System.String.Empty"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.OrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns the enumeration, or an empty enumeration.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The enumeration to potentially return.</param>
            <returns>The parameter <paramref name="iterable"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Nth(System.String,System.Int32)">
            <summary>Gets a specific character from a string.</summary>
            <param name="str">The string to get the character from.</param>
            <param name="index">The index to use.</param>
            <returns>The character based on the parameters <paramref name="str"/> and <paramref name="index"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.NthLast(System.String,System.Int32)">
            <summary>Gets a specific character from a string.</summary>
            <param name="str">The string to get the character from.</param>
            <param name="index">The index to use.</param>
            <returns>The character based on the parameters <paramref name="str"/> and <paramref name="index"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.NthLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.ManyQueries">
            <summary>Methods that creates enumerations from individual items.</summary>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.TryGetTypes(System.Reflection.Assembly)">
            <summary>Gets the types from an assembly even if type loads occur.</summary>
            <param name="assembly">The assembly to get the types from.</param>
            <returns>
            The enumeration of all successfully loaded types from the parameter <paramref name="assembly"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(``0,System.Converter{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="item">The item to check.</param>
            <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Nullable{``0},System.Converter{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="item">The item to check.</param>
            <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.MethodGroupings">
            <summary>Methods to create methods.</summary>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Compared`1.Compare(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Compared`2.Compare(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Equated`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.MethodGroupings.Equated`1"/> class.</summary>
            <param name="comparer">The comparer to convert.</param>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Equated`1.Default(`0)">
            <summary>Returns 0.</summary>
            <param name="_">The discard.</param>
            <returns>The value 0.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Equated`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Equated`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Equated`1.FromIComparer(System.Collections.Generic.IComparer{`0})">
            <summary>Returns the equality function based on the <see cref="T:System.Collections.Generic.IComparer`1"/>.</summary>
            <param name="comparer">The comparer to evaluate equality.</param>
            <returns>The equality function that wraps <paramref name="comparer"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Equated`2.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Equated`2.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="F:Emik.Morsels.MethodGroupings.BitsInByte">
            <summary>The number of bits in a byte.</summary>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Invoke(System.Action)">
            <summary>Invokes a method.</summary>
            <param name="del">The method to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Noop">
            <summary>Performs nothing.</summary>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Noop``1(``0)">
            <summary>Performs nothing.</summary>
            <typeparam name="T">The type of discard.</typeparam>
            <param name="_">The discard.</param>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Noop``2(``0,``1)">
            <summary>Performs nothing.</summary>
            <typeparam name="T1">The first type of discard.</typeparam>
            <typeparam name="T2">The second type of discard.</typeparam>
            <param name="_">The first discard.</param>
            <param name="__">The second discard.</param>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action(System.Action)">
            <summary>Create a delegate.</summary>
            <param name="del">The method group.</param>
            <returns>An invokable method.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action1``1(System.Action{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action2``2(System.Action{``0,``1})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action3``3(System.Action{``0,``1,``2})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action4``4(System.Action{``0,``1,``2,``3})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func``1(System.Func{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func1``2(System.Func{``0,``1})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func2``3(System.Func{``0,``1,``2})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func3``4(System.Func{``0,``1,``2,``3})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func4``5(System.Func{``0,``1,``2,``3,``4})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not1``1(System.Func{``0,System.Boolean})">
            <summary>Negates a predicate.</summary>
            <typeparam name="T">The type of item for the predicate.</typeparam>
            <param name="predicate">The predicate to negate.</param>
            <returns>The argument <paramref name="predicate"/> wrapped in another that negates its result.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not2``1(System.Func{``0,System.Int32,System.Boolean})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Comparing``1(System.Comparison{``0})">
            <summary>Creates the <see cref="T:System.Collections.Generic.IComparer`1"/> from the mapping.</summary>
            <typeparam name="T">The type to compare.</typeparam>
            <param name="comparison">The <see cref="T:System.Comparison`1"/> to use.</param>
            <returns>The <see cref="T:System.Collections.Generic.IComparer`1"/> that wraps the parameter <paramref name="comparison"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Comparing``2(System.Converter{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>Creates the <see cref="T:System.Collections.Generic.IComparer`1"/> from the mapping.</summary>
            <typeparam name="T">The type to compare.</typeparam>
            <typeparam name="TResult">The resulting value from the mapping used for comparison.</typeparam>
            <param name="converter">The converter to use.</param>
            <param name="comparer">If specified, the way the result of the delegate should be sorted.</param>
            <returns>The <see cref="T:System.Collections.Generic.IComparer`1"/> that wraps the parameter <paramref name="converter"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.AsEquality``1(System.Collections.Generic.IComparer{``0})">
            <summary>Creates the <see cref="T:System.Collections.Generic.IComparer`1"/> from the mapping.</summary>
            <typeparam name="T">The type to compare.</typeparam>
            <param name="comparison">The <see cref="T:System.Comparison`1"/> to use.</param>
            <returns>The <see cref="T:System.Collections.Generic.IComparer`1"/> that wraps the parameter <paramref name="comparison"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Equating``2(System.Converter{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Creates the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> from the mapping.</summary>
            <typeparam name="T">The type to compare.</typeparam>
            <typeparam name="TResult">The resulting value from the mapping used for comparison.</typeparam>
            <param name="converter">The converter to use.</param>
            <param name="comparer">If specified, the way the result of the delegate should be sorted.</param>
            <returns>The <see cref="T:System.Collections.Generic.IComparer`1"/> that wraps the parameter <paramref name="converter"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Equating``1(System.Func{``0,``0,System.Boolean},System.Func{``0,System.Int32})">
            <summary>Creates the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> from the mapping.</summary>
            <typeparam name="T">The type to compare.</typeparam>
            <param name="comparer">The comparer to use.</param>
            <param name="hashCode">If specified, the hash code algorithm.</param>
            <returns>The <see cref="T:System.Collections.Generic.IComparer`1"/> that wraps the parameter <paramref name="comparer"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Invoke``1(System.Func{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Invoke(System.Action)"/>
        </member>
        <member name="T:Emik.Morsels.Clamped">
            <summary>Extension methods to clamp numbers.</summary>
        </member>
        <member name="M:Emik.Morsels.Clamped.IsPow2(System.Int32)">
            <inheritdoc cref="!:IsPow2(IntPtr)"/>
        </member>
        <member name="M:Emik.Morsels.Clamped.IsPow2(System.UInt32)">
            <inheritdoc cref="!:IsPow2(IntPtr)"/>
        </member>
        <member name="M:Emik.Morsels.Clamped.IsPow2(System.Int64)">
            <inheritdoc cref="!:IsPow2(IntPtr)"/>
        </member>
        <member name="M:Emik.Morsels.Clamped.IsPow2(System.UInt64)">
            <inheritdoc cref="!:IsPow2(IntPtr)"/>
        </member>
        <member name="M:Emik.Morsels.Clamped.IsPow2(System.IntPtr)">
            <summary>Evaluate whether a given integral value is a power of 2.</summary>
            <param name="value">The value.</param>
            <returns>
            The value <see langword="true"/> if the parameter <paramref name="value"/>
            is a power of 2; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Clamped.IsPow2(System.UIntPtr)">
            <inheritdoc cref="!:IsPow2(IntPtr)"/>
        </member>
        <member name="M:Emik.Morsels.Clamped.RoundUpToPowerOf2(System.UInt32)">
            <summary>Round the given integral value up to a power of 2.</summary>
            <remarks><para>
            The fallback implementation is based on
            <a href="https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2">
            Bit Twiddling Hacks by Sean Eron Anderson
            </a>.
            </para></remarks>
            <param name="value">The value.</param>
            <returns>
            The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
            If <paramref name="value"/> is 0 or the result overflows, returns 0.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Clamped.RoundUpToPowerOf2(System.UInt64)">
            <inheritdoc cref="M:Emik.Morsels.Clamped.RoundUpToPowerOf2(System.UInt32)"/>
        </member>
        <member name="M:Emik.Morsels.Clamped.RoundUpToPowerOf2(System.UIntPtr)">
            <inheritdoc cref="M:Emik.Morsels.Clamped.RoundUpToPowerOf2(System.UInt32)"/>
        </member>
        <member name="M:Emik.Morsels.Clamped.Clamp(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
            <param name="number">The number to clip.</param>
            <param name="min">If specified, the smallest number to return.</param>
            <param name="max">If specified, the greatest number to return.</param>
            <returns>
            The parameter <paramref name="min"/> if <paramref name="number"/> is smaller than <paramref name="min"/>,
            otherwise, the parameter <paramref name="max"/> if <paramref name="number"/> is greater than
            <paramref name="max"/>, otherwise the parameter <paramref name="number"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Clamped.Clamp(System.Single,System.Nullable{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:Emik.Morsels.Clamped.Clamp(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>
        </member>
        <member name="M:Emik.Morsels.Clamped.Mod(System.Int32,System.Int32)">
            <summary>
            Calculates the least nonnegative remainder of <paramref name="number"/> <c>%</c> <paramref name="radix"/>.
            </summary>
            <remarks><para>
            Implementation based on <a href="https://doc.rust-lang.org/src/core/num/int_macros.rs.html#2190">
            Rust standard library (core)'s rem_euclid function
            </a>.
            </para></remarks>
            <param name="number">The number to calculate the remainder of.</param>
            <param name="radix">The radix to use.</param>
            <returns>The result of the Euclidean division algorithm.</returns>
        </member>
        <member name="M:Emik.Morsels.Clamped.Mod(System.Single,System.Single)">
            <inheritdoc cref="M:Emik.Morsels.Clamped.Mod(System.Int32,System.Int32)"/>
        </member>
        <member name="T:Emik.Morsels.DigitCounter">
            <summary>Extension methods to count digits in numbers.</summary>
        </member>
        <member name="M:Emik.Morsels.DigitCounter.DigitCount(System.Byte)">
            <summary>Gets the amount of digits of the number.</summary>
            <param name="number">The number to count.</param>
            <returns>The amount of digits in the parameter <paramref name="number"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.DigitCounter.DigitCount(System.SByte)">
            <inheritdoc cref="M:Emik.Morsels.DigitCounter.DigitCount(System.Byte)"/>
        </member>
        <member name="M:Emik.Morsels.DigitCounter.DigitCount(System.UInt16)">
            <inheritdoc cref="M:Emik.Morsels.DigitCounter.DigitCount(System.Byte)"/>
        </member>
        <member name="M:Emik.Morsels.DigitCounter.DigitCount(System.Int16)">
            <inheritdoc cref="M:Emik.Morsels.DigitCounter.DigitCount(System.Byte)"/>
        </member>
        <member name="M:Emik.Morsels.DigitCounter.DigitCount(System.UInt32)">
            <inheritdoc cref="M:Emik.Morsels.DigitCounter.DigitCount(System.Byte)"/>
        </member>
        <member name="M:Emik.Morsels.DigitCounter.DigitCount(System.Int32)">
            <inheritdoc cref="M:Emik.Morsels.DigitCounter.DigitCount(System.Byte)"/>
        </member>
        <member name="M:Emik.Morsels.DigitCounter.DigitCount(System.UInt64)">
            <inheritdoc cref="M:Emik.Morsels.DigitCounter.DigitCount(System.Byte)"/>
        </member>
        <member name="M:Emik.Morsels.DigitCounter.DigitCount(System.Int64)">
            <inheritdoc cref="M:Emik.Morsels.DigitCounter.DigitCount(System.Byte)"/>
        </member>
        <member name="T:Emik.Morsels.EnumMath">
            <summary>Provides methods to do math on enums without overhead from boxing.</summary>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Has``1(``0,``0)">
            <summary>Checks if the left-hand side implements the right-hand side.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>
            The value <see langword="true"/> if the parameter <paramref name="left"/> has the values
            of the parameter <paramref name="right"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.AsInt``1(``0)">
            <summary>Performs a conversion operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="value">The value.</param>
            <returns>The <see cref="T:System.Int32"/> cast of <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.GetValues``1">
            <summary>Gets the values of an enum cached and strongly-typed.</summary>
            <typeparam name="T">The type of enum to get the values from.</typeparam>
            <returns>All values in the type parameter <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.As``1(System.Int32)">
            <summary>Performs a conversion operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="value">The value.</param>
            <returns>The <typeparamref name="T"/> cast of <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Negate``1(``0)">
            <summary>Performs a negation operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="value">The value.</param>
            <returns>The negated value of the parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Predecessor``1(``0)">
            <summary>Performs an decrement operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="value">The value.</param>
            <returns>The predecessor of the parameter <paramref name="value"/>; the number immediately before it.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Successor``1(``0)">
            <summary>Performs a increment operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="value">The value.</param>
            <returns>The predecessor of the parameter <paramref name="value"/>; the number immediately after it.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Add``1(``0,``0)">
            <summary>Performs an addition operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>The sum of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Subtract``1(``0,``0)">
            <summary>Performs a subtraction operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>The difference of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Multiply``1(``0,``0)">
            <summary>Performs a multiplication operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>The product of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Divide``1(``0,``0)">
            <summary>Performs a division operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>The quotient of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Modulo``1(``0,``0)">
            <summary>Performs a modulo operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>The remainder of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Product``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Computes the product of a sequence of <typeparamref name="T"/> values.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="source">A sequence of <typeparamref name="T"/> values to calculate the product of.</param>
            <returns>The product of the values in the sequence.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Sum``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Computes the sum of a sequence of <typeparamref name="T"/> values.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="source">A sequence of <typeparamref name="T"/> values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
        </member>
        <member name="T:Emik.Morsels.RangeMethodsWithoutValueTuples">
            <summary>Implements a <see cref="M:Emik.Morsels.RangeMethodsWithoutValueTuples.GetOffsetAndLength(System.Range,System.Int32,System.Int32@,System.Int32@)"/> overload that doesn't rely on tuples.</summary>
        </member>
        <member name="M:Emik.Morsels.RangeMethodsWithoutValueTuples.GetOffsetAndLength(System.Range,System.Int32,System.Int32@,System.Int32@)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <remarks><para>
            For performance reasons, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </para></remarks>
            <param name="range">The <see cref="T:System.Range"/> that contains the range of elements.</param>
            <param name="length">
            The length of the collection that the range will be used with.
            <paramref name="length"/> has to be a positive value.
            </param>
            <param name="outOffset">The resulting offset.</param>
            <param name="outLength">The resulting length.</param>
        </member>
        <member name="M:Emik.Morsels.RangeMethodsWithoutValueTuples.TryGetOffsetAndLength(System.Range,System.Int32,System.Int32@,System.Int32@)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="range">The <see cref="T:System.Range"/> that contains the range of elements.</param>
            <param name="length">
            The length of the collection that the range will be used with.
            <paramref name="length"/> has to be a positive value.
            </param>
            <param name="outOffset">The resulting offset.</param>
            <param name="outLength">The resulting length.</param>
            <returns>Whether the values are set.</returns>
        </member>
        <member name="T:Emik.Morsels.Heap">
            <summary>Provides methods for heap-allocation analysis.</summary>
        </member>
        <member name="F:Emik.Morsels.Heap.NotForProduction">
            <summary>
            A <see langword="string"/> to use in an <see cref="T:System.ObsoleteAttribute"/> to indicate that the API isn't meant
            for production, but not for deprecated reasons.
            </summary>
        </member>
        <member name="M:Emik.Morsels.Heap.Swallow(System.Action)">
            <summary>Swallows all exceptions from a callback; Use with caution.</summary>
            <param name="action">The dangerous callback.</param>
            <returns>An exception, if caught.</returns>
        </member>
        <member name="M:Emik.Morsels.Heap.Swallow``1(System.Func{``0})">
            <summary>Swallows all exceptions from a callback; Use with caution.</summary>
            <typeparam name="T">The type of return.</typeparam>
            <param name="func">The dangerous callback.</param>
            <returns>The value returned from <paramref name="func"/>, or the exception caught.</returns>
        </member>
        <member name="M:Emik.Morsels.Heap.CountAllocation(System.Action,System.Boolean)">
            <summary>Gets the amount of bytes a callback uses.</summary>
            <remarks><para>
            This method temporarily tunes the <see cref="T:System.GC"/> to <see cref="F:System.Runtime.GCLatencyMode.LowLatency"/>
            for accurate results. As such, the parameter <paramref name="heap"/> should not cause
            substantial allocation such that collecting mid-way is required.
            </para></remarks>
            <param name="heap">The callback that causes some amount of heap allocation.</param>
            <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
            <returns>The number of bytes the <see cref="T:System.GC"/> allocated from calling <paramref name="heap"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Heap.CountAllocations(System.Action,System.Int32,System.Boolean)">
            <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
            <param name="heap">The callback that causes some amount of heap allocation.</param>
            <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
            <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
            <returns>
            An <see cref="T:System.Array"/> where each entry is a separate test of the number of
            bytes the <see cref="T:System.GC"/> allocated from calling <paramref name="heap"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Heap.HasAllocations(System.Action,System.Int32,System.Boolean)">
            <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
            <param name="heap">The callback that causes some amount of heap allocation.</param>
            <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
            <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
            <returns>
            An <see cref="T:System.Array"/> where each entry is a separate test of the number of
            bytes the <see cref="T:System.GC"/> allocated from calling <paramref name="heap"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.CharacterInvariance">
            <summary>Provides extension methods for <see cref="T:System.Char"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsControl(System.Char)">
            <inheritdoc cref="M:System.Char.IsControl(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsDigit(System.Char)">
            <inheritdoc cref="M:System.Char.IsDigit(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsHighSurrogate(System.Char)">
            <inheritdoc cref="M:System.Char.IsHighSurrogate(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsLetter(System.Char)">
            <inheritdoc cref="M:System.Char.IsLetter(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsLetterOrDigit(System.Char)">
            <inheritdoc cref="M:System.Char.IsLetterOrDigit(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsLower(System.Char)">
            <inheritdoc cref="M:System.Char.IsLower(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsLowSurrogate(System.Char)">
            <inheritdoc cref="M:System.Char.IsLowSurrogate(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsNullOrWhitespace(System.String)">
            <summary>
            Indicates whether a specified string is <see langword="null"/>,
            empty, or consists only of white-space characters.
            </summary>
            <param name="value">The string to test.</param>
            <returns>
            <see langword="true"/> if the <paramref name="value"/> parameter is <see langword="null"/>,
            or <see cref="F:System.String.Empty"/>, or if <paramref name="value"/> consists exclusively of white-space characters.
            </returns>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsNumber(System.Char)">
            <inheritdoc cref="M:System.Char.IsNumber(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsPunctuation(System.Char)">
            <inheritdoc cref="M:System.Char.IsPunctuation(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsSeparator(System.Char)">
            <inheritdoc cref="M:System.Char.IsSeparator(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsSurrogate(System.Char)">
            <inheritdoc cref="M:System.Char.IsSurrogate(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsSymbol(System.Char)">
            <inheritdoc cref="M:System.Char.IsSymbol(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsUpper(System.Char)">
            <inheritdoc cref="M:System.Char.IsUpper(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsWhitespace(System.Char)">
            <inheritdoc cref="M:System.Char.IsWhiteSpace(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.AsDigit(System.Char)">
            <summary>Converts the character to the byte-equivalent, 0-9.</summary>
            <param name="c">The character to convert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The parameter <paramref name="c"/> isn't between '0' and '9', inclusively on both ends.
            </exception>
            <returns>The number 0-9 representing the character.</returns>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.TryAsDigit(System.Char)">
            <summary>Attempts to convert the character to the byte-equivalent, 0-9.</summary>
            <param name="c">The character to convert.</param>
            <returns>The number 0-9 representing the character, or <see langword="null"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.ToLower(System.Char)">
            <inheritdoc cref="M:System.Char.ToLower(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.ToUpper(System.Char)">
            <inheritdoc cref="M:System.Char.ToUpper(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.GetNumericValue(System.Char)">
            <inheritdoc cref="M:System.Char.GetNumericValue(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.Trim(System.String,System.String)">
            <inheritdoc cref="M:System.String.Trim(System.Char[])"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.TrimEnd(System.String,System.String)">
            <inheritdoc cref="M:System.String.TrimEnd(System.Char[])"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.TrimStart(System.String,System.String)">
            <inheritdoc cref="M:System.String.TrimStart(System.Char[])"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.GetUnicodeCategory(System.Char)">
            <inheritdoc cref="M:System.Char.GetUnicodeCategory(System.Char)"/>
        </member>
        <member name="T:Emik.Morsels.DeconstructionCollectionExtensions">
            <summary>Contains methods for deconstructing objects.</summary>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollectionExtensions.ToDeconstructed(System.Object,System.Int32,System.Int32,System.Int32)">
            <summary>Takes the complex object and turns it into a structure that is serializable.</summary>
            <param name="value">The complex object to convert.</param>
            <param name="visitLength">The maximum number of times to recurse through an enumeration.</param>
            <param name="stringLength">The maximum length of any given <see cref="T:System.String"/>.</param>
            <param name="recurseLength">The maximum number of times to recurse a nested object or dictionary.</param>
            <returns>
            The serializable object: any of <see cref="T:System.IntPtr"/>, <see cref="T:System.UIntPtr"/>,
            <see cref="T:System.Runtime.Serialization.ISerializable"/>, or <see cref="T:Emik.Morsels.DeconstructionCollection"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.DeconstructionCollection">
            <summary>Defines the collection responsible for deconstructing.</summary>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.#ctor(System.Int32)">
            <summary>Defines the collection responsible for deconstructing.</summary>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
        </member>
        <member name="T:Emik.Morsels.DeconstructionCollection.DeconstructionComparer">
            <summary>Represents a comparer for <see cref="T:Emik.Morsels.DeconstructionCollection"/> recursion checks.</summary>
            <remarks><para>
            All values considered to be scalar values are treated as being always unique even when the exact
            reference is the same. The point of the comparer is to avoid reference cycles, not for equality.
            </para></remarks>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionComparer.Equals(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionComparer.GetHashCode(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionComparer.IsScalar(System.Object)">
            <summary>Determines whether the value is a scalar.</summary>
            <param name="value">The value to check.</param>
            <returns>
            The value <see langword="true"/> if the value is a scalar; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.DeconstructionCollection.DeconstructionList">
            <summary>Represents a deep-cloned list.</summary>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.#ctor(System.Int32)">
            <summary>Represents a deep-cloned list.</summary>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionList.Inner">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionList.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionList.System#Collections#IList#IsFixedSize">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionList.System#Collections#IList#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.TryCollect(System.Collections.IEnumerator,System.Int32,System.Int32@,Emik.Morsels.DeconstructionCollection.DeconstructionList@,System.Collections.Generic.HashSet{System.Object})">
            <summary>Attempts to deconstruct an object by enumerating it.</summary>
            <param name="enumerator">The enumerator to collect. It will be disposed after the method halts.</param>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
            <param name="visit">The maximum number of times to recurse.</param>
            <param name="list">The resulting <see cref="T:Emik.Morsels.DeconstructionCollection.DeconstructionList"/>.</param>
            <param name="seen">The set of seen values, which is used to avoid recursion.</param>
            <returns>
            Whether the parameter <paramref name="enumerator"/> was deconstructed fully and <paramref name="visit"/>
            altered. When this method returns <see langword="false"/>, the parameter <paramref name="list"/>
            will still contain the elements that were able to be deconstructed, alongside an ellipsis.
            </returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.TryCollect(System.Collections.IEnumerable,System.Int32,System.Int32@,Emik.Morsels.DeconstructionCollection.DeconstructionList@,System.Collections.Generic.HashSet{System.Object})">
            <summary>Attempts to deconstruct an object by enumerating it.</summary>
            <param name="enumerable">The enumerator to collect.</param>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
            <param name="visit">The maximum number of times to recurse.</param>
            <param name="list">The resulting <see cref="T:Emik.Morsels.DeconstructionCollection.DeconstructionList"/>.</param>
            <param name="seen">The set of seen values, which is used to avoid recursion.</param>
            <returns>
            Whether the parameter <paramref name="enumerable"/> was deconstructed fully and <paramref name="visit"/>
            altered. When this method returns <see langword="false"/>, the parameter <paramref name="list"/>
            will still contain the elements that were able to be deconstructed, alongside an ellipsis.
            </returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.TryRecurse(System.Int32,System.Int32@,System.Collections.Generic.HashSet{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.Add(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.Simplify">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.System#Collections#IList#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.System#Collections#IList#Insert(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.System#Collections#IList#Remove(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.System#Collections#IList#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.System#Collections#IList#Contains(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.System#Collections#IList#IndexOf(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.op_Implicit(System.Int32)~Emik.Morsels.DeconstructionCollection.DeconstructionList">
            <summary>
            Implicitly converts the parameter by creating the new instance of DeconstructionList by using the constructor
            <see cref="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.#ctor(System.Int32)"/>.
            </summary>
            <param name="str">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of DeconstructionList by passing the parameter <paramref name="str"/> to the constructor
            <see cref="M:Emik.Morsels.DeconstructionCollection.DeconstructionList.#ctor(System.Int32)"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary">
            <summary>Represents either a complex object or a deep-cloned dictionary.</summary>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.#ctor(System.Int32)">
            <summary>Represents either a complex object or a deep-cloned dictionary.</summary>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
        </member>
        <member name="T:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Enumerator">
            <summary>Handles enumeration of the <see cref="T:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary"/>.</summary>
            <param name="dictionary">The <see cref="T:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary"/> to enumerate.</param>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Enumerator.#ctor(Emik.Morsels.DeconstructionCollection.DeconstructionDictionary)">
            <summary>Handles enumeration of the <see cref="T:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary"/>.</summary>
            <param name="dictionary">The <see cref="T:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary"/> to enumerate.</param>
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Enumerator.Entry">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Enumerator.System#Collections#IDictionaryEnumerator#Key">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Enumerator.System#Collections#IDictionaryEnumerator#Value">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Enumerator.System#Collections#IEnumerator#MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.System#Collections#IDictionary#Item(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.System#Collections#IDictionary#IsFixedSize">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.System#Collections#IDictionary#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.System#Collections#IDictionary#Keys">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.System#Collections#IDictionary#Values">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Inner">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Serialized">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.TryCollect(System.Collections.IDictionaryEnumerator,System.Int32,System.Int32@,Emik.Morsels.DeconstructionCollection.DeconstructionDictionary@,System.Collections.Generic.HashSet{System.Object})">
            <summary>Attempts to deconstruct an object by enumerating it.</summary>
            <param name="enumerator">The enumerator to collect. It will be disposed after the method halts.</param>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
            <param name="visit">The maximum number of times to recurse.</param>
            <param name="dictionary">
            The resulting <see cref="T:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary"/>.
            </param>
            <param name="seen">The set of seen values, which is used to avoid recursion.</param>
            <returns>
            Whether the parameter <paramref name="enumerator"/> was deconstructed fully and <paramref name="visit"/>
            altered. When this method returns <see langword="false"/>, the parameter <paramref name="dictionary"/>
            will still contain the elements that were able to be deconstructed, alongside an ellipsis.
            </returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.TryCollect(System.Collections.IDictionary,System.Int32,System.Int32@,Emik.Morsels.DeconstructionCollection.DeconstructionDictionary@,System.Collections.Generic.HashSet{System.Object})">
            <summary>Attempts to deconstruct an object by enumerating it.</summary>
            <param name="dict">The dictionary to collect.</param>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
            <param name="visit">The maximum number of times to recurse.</param>
            <param name="dictionary">
            The resulting <see cref="T:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary"/>.
            </param>
            <param name="seen">The set of seen values, which is used to avoid recursion.</param>
            <returns>
            Whether the parameter <paramref name="dict"/> was deconstructed fully and <paramref name="visit"/>
            altered. When this method returns <see langword="false"/>, the parameter <paramref name="dictionary"/>
            will still contain the elements that were able to be deconstructed, alongside an ellipsis.
            </returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.TryReflectivelyCollect(System.Object,System.Int32,System.Int32@,Emik.Morsels.DeconstructionCollection.DeconstructionDictionary@,System.Collections.Generic.HashSet{System.Object})">
            <summary>Attempts to deconstruct an object by reflectively collecting its fields and properties.</summary>
            <param name="value">The complex object to convert.</param>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
            <param name="visit">The maximum number of times to recurse.</param>
            <param name="dictionary">
            The resulting <see cref="T:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary"/>.
            </param>
            <param name="seen">The set of seen values, which is used to avoid recursion.</param>
            <returns>
            Whether the parameter <paramref name="value"/> was deconstructed fully and <paramref name="visit"/>
            altered. When this method returns <see langword="false"/>, the parameter <paramref name="dictionary"/>
            will still contain the elements that were able to be deconstructed, alongside an ellipsis.
            </returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Add(System.Object,System.Object)">
            <inheritdoc cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)"/>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Clear">
            <inheritdoc cref="M:System.Collections.IDictionary.Clear"/>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Fail">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.TryRecurse(System.Int32,System.Int32@,System.Collections.Generic.HashSet{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.Simplify">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.System#Collections#IDictionary#Remove(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.System#Collections#IDictionary#Contains(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.System#Collections#IDictionary#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.op_Implicit(System.Int32)~Emik.Morsels.DeconstructionCollection.DeconstructionDictionary">
            <summary>
            Implicitly converts the parameter by creating the new instance of DeconstructionDictionary by using the constructor
            <see cref="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.#ctor(System.Int32)"/>.
            </summary>
            <param name="str">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of DeconstructionDictionary by passing the parameter <paramref name="str"/> to the constructor
            <see cref="M:Emik.Morsels.DeconstructionCollection.DeconstructionDictionary.#ctor(System.Int32)"/>.
            </returns>
        </member>
        <member name="F:Emik.Morsels.DeconstructionCollection.DefaultVisitLength">
            <summary>The defaults used in <see cref="M:Emik.Morsels.DeconstructionCollectionExtensions.ToDeconstructed(System.Object,System.Int32,System.Int32,System.Int32)"/>.</summary>
        </member>
        <member name="F:Emik.Morsels.DeconstructionCollection.DefaultStringLength">
            <summary>The defaults used in <see cref="M:Emik.Morsels.DeconstructionCollectionExtensions.ToDeconstructed(System.Object,System.Int32,System.Int32,System.Int32)"/>.</summary>
        </member>
        <member name="F:Emik.Morsels.DeconstructionCollection.DefaultRecurseLength">
            <summary>The defaults used in <see cref="M:Emik.Morsels.DeconstructionCollectionExtensions.ToDeconstructed(System.Object,System.Int32,System.Int32,System.Int32)"/>.</summary>
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.Comparer">
            <summary>Gets the comparer used in <see cref="M:Emik.Morsels.DeconstructionCollectionExtensions.ToDeconstructed(System.Object,System.Int32,System.Int32,System.Int32)"/>.</summary>
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.IsSynchronized">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.Count">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.MaxStringLength">
            <summary>Gets the maximum length of any given <see cref="T:System.String"/>.</summary>
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.SyncRoot">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.Inner">
            <summary>Gets the underlying collection.</summary>
        </member>
        <member name="P:Emik.Morsels.DeconstructionCollection.Serialized">
            <summary>Gets the collection to a serializable collection.</summary>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.TryTruncate(System.Object,System.Int32,System.String@)">
            <summary>Attempts to truncate the <paramref name="v"/>.</summary>
            <param name="v">The <see cref="T:System.Object"/> to truncate.</param>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
            <param name="o">The resulting truncation <see cref="T:System.String"/>.</param>
            <returns>Whether the <paramref name="v"/> was truncated.</returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.CollectNext(System.Object,System.Int32,System.Int32@,System.Boolean@,System.Collections.Generic.HashSet{System.Object})">
            <summary>Collects the value however applicable, reverting on failure.</summary>
            <param name="value">The complex object to convert.</param>
            <param name="str">The maximum length of any given <see cref="T:System.String"/>.</param>
            <param name="visit">The maximum number of times to recurse.</param>
            <param name="any">Whether any value was collected.</param>
            <param name="seen">The set of seen values, which is used to avoid recursion.</param>
            <returns>The replacement value.</returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.CopyTo(System.Array,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.Fail">
            <summary>Adds a failure element, and returns <see langword="false"/>.</summary>
            <returns>The value <see langword="false"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.TryRecurse(System.Int32,System.Int32@,System.Collections.Generic.HashSet{System.Object})">
            <summary>Attempts to recurse into this instance's elements.</summary>
            <param name="layer">The amount of layers of recursion to apply.</param>
            <param name="visit">The maximum number of times to recurse.</param>
            <param name="seen">The set of seen values, which is used to avoid recursion.</param>
            <returns>Whether any mutation occured.</returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.ToStringWithoutNewLines">
            <summary>Returns the <see cref="T:System.String"/> representation of this instance without newlines.</summary>
            <returns>The <see cref="T:System.String"/> representation of this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.Simplify">
            <summary>Recursively simplifies every value according to <see cref="M:Emik.Morsels.DeconstructionCollection.Simplify"/>.</summary>
            <returns>Itself. The returned value is not a copy; mutation applies to the instance.</returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.RecurseNext(System.Object,System.Int32,System.Int32@,System.Boolean@,System.Collections.Generic.HashSet{System.Object})">
            <summary>Starts recursion if the value is a collection.</summary>
            <param name="value">The complex object to convert.</param>
            <param name="layer">The amount of layers of recursion to apply.</param>
            <param name="visit">The maximum number of times to recurse.</param>
            <param name="any">Whether any value was collected.</param>
            <param name="seen">The set of seen values, which is used to avoid recursion.</param>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.ToString(System.Object)">
            <summary>Converts the <see cref="T:System.Object"/> to a <see cref="T:System.String"/>.</summary>
            <param name="value">The <see cref="T:System.Object"/> to convert.</param>
            <returns>The converted <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.DeconstructionCollection.SimplifyObject(System.Object)">
            <summary>Simplifies the value to either a <see cref="T:System.IConvertible"/> or <see cref="T:System.String"/>.</summary>
            <param name="value">The value to simplify.</param>
            <returns>The simplified value.</returns>
        </member>
        <member name="T:Emik.Morsels.GenericParser">
            <summary>Provides extension methods to convert representations of text into destination types.</summary>
        </member>
        <member name="M:Emik.Morsels.GenericParser.Parse``1(System.String)">
            <inheritdoc cref="M:Emik.Morsels.GenericParser.Parse``1(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Emik.Morsels.GenericParser.Parse``1(System.String,System.Boolean@)">
            <summary>Parses the <see cref="T:System.String"/> into a <typeparamref name="T"/>.</summary>
            <typeparam name="T">The type to parse into.</typeparam>
            <param name="s">The buffer source.</param>
            <param name="success">Whether the parsing was successful.</param>
            <returns>The parsed value.</returns>
        </member>
        <member name="M:Emik.Morsels.GenericParser.Parse``1(System.ReadOnlySpan{System.Byte})">
            <inheritdoc cref="M:Emik.Morsels.GenericParser.Parse``1(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Emik.Morsels.GenericParser.Parse``1(System.ReadOnlySpan{System.Byte},System.Boolean@)">
            <inheritdoc cref="M:Emik.Morsels.GenericParser.Parse``1(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Emik.Morsels.GenericParser.Parse``1(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Emik.Morsels.GenericParser.Parse``1(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Emik.Morsels.GenericParser.Parse``1(System.ReadOnlySpan{System.Char},System.Boolean@)">
            <inheritdoc cref="M:Emik.Morsels.GenericParser.Parse``1(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Emik.Morsels.GenericParser.TryParse``1(System.String)">
            <inheritdoc cref="M:Emik.Morsels.GenericParser.Parse``1(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Emik.Morsels.GenericParser.TryParse``1(System.ReadOnlySpan{System.Byte})">
            <inheritdoc cref="M:Emik.Morsels.GenericParser.Parse``1(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Emik.Morsels.GenericParser.TryParse``1(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Emik.Morsels.GenericParser.Parse``1(System.String,System.Boolean@)"/>
        </member>
        <member name="T:Emik.Morsels.Stringifier">
            <summary>Provides stringification methods.</summary>
        </member>
        <member name="M:Emik.Morsels.Stringifier.FieldCount(System.Version)">
            <summary>Gets the field count of the version.</summary>
            <param name="version">The <see cref="T:System.Version"/> to use.</param>
            <returns>The field count of the parameter <paramref name="version"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Collapse(System.String)">
            <summary>Creates the collapsed form of the string.</summary>
            <param name="s">The string to collapse.</param>
            <returns>The collapsed string.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.CollapseToSingleLine(System.String,System.String)">
            <summary>Collapses the <see cref="T:System.String"/> to a single line.</summary>
            <param name="expression">The <see cref="T:System.String"/> to collapse.</param>
            <param name="prefix">The prefix to use.</param>
            <returns>The collapsed <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Conjugate(System.Int32,System.String,System.String)">
            <summary>Converts a number to an ordinal.</summary>
            <param name="i">The number to convert.</param>
            <param name="one">The string for the value 1 or -1.</param>
            <param name="many">The string to concatenate. Use prefixed dashes to trim <paramref name="one"/>.</param>
            <returns>The conjugation of all the parameters.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.FileName(System.String)">
            <summary>Extracts the file name from the path.</summary>
            <remarks><para>
            The return type depends on what framework is used. Ensure that the caller doesn't care about the return type.
            </para></remarks>
            <param name="path">The path to extract the file name from.</param>
            <returns>The file name.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Prettify(System.String)">
            <summary>Creates the prettified form of the string.</summary>
            <param name="s">The string to prettify.</param>
            <returns>The prettified string.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Prettify(System.String,System.String,System.String,System.String,System.String)">
            <summary>Creates the prettified form of the string.</summary>
            <remarks><para>
            The functionality is based on
            <a href="https://gist.github.com/kodo-pp/89cefb17a8772cd9fd7b875d94fd29c7">this gist by kodo-pp</a>.
            </para></remarks>
            <param name="s">The string to prettify.</param>
            <param name="start">The characters considered to be starting blocks.</param>
            <param name="end">The characters considered to be ending blocks.</param>
            <param name="separator">The characters considered to be separators.</param>
            <param name="indent">The amount of spaces for indentation.</param>
            <returns>The prettified string.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.Char)">
            <summary>Joins a set of values into one long <see cref="T:System.String"/>.</summary>
            <remarks><para>
            This method is more efficient than using
            <see cref="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.String)"/> for <see cref="T:System.Char"/> separators.
            </para></remarks>
            <typeparam name="T">The type of each item in the collection.</typeparam>
            <param name="values">The values to join.</param>
            <param name="separator">The separator between each item.</param>
            <returns>One long <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Joins a set of values into one long <see cref="T:System.String"/>.</summary>
            <typeparam name="T">The type of each item in the collection.</typeparam>
            <param name="values">The values to join.</param>
            <param name="separator">The separator between each item.</param>
            <returns>One long <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.ToHexString(System.Reflection.Pointer)">
            <summary>Converts a <see cref="T:System.Reflection.Pointer"/> to a <see cref="T:System.String"/>.</summary>
            <param name="value">The <see cref="T:System.Reflection.Pointer"/> to convert.</param>
            <returns>The <see cref="T:System.String"/> representation of <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.ToShortString(System.Version)">
            <summary>Gets the short display form of the version.</summary>
            <param name="version">The <see cref="T:System.Version"/> to convert.</param>
            <returns>The full name of the parameter <paramref name="version"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.UnfoldedFullName(System.Type)">
            <summary>Gets the full type name, with its generics extended.</summary>
            <param name="type">The <see cref="T:System.Type"/> to get the full name of.</param>
            <returns>The full name of the parameter <paramref name="type"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.UnfoldedName(System.Type)">
            <summary>Gets the type name, with its generics extended.</summary>
            <param name="type">The <see cref="T:System.Type"/> to get the name of.</param>
            <returns>The name of the parameter <paramref name="type"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Nth(System.Int32,System.Boolean)">
            <summary>Converts a number to an ordinal.</summary>
            <param name="i">The number to convert.</param>
            <param name="indexByZero">Determines whether to index from zero or one.</param>
            <returns>The parameter <paramref name="i"/> as an ordinal.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Split(System.String,System.String)">
            <inheritdoc cref="M:System.String.Split(System.String[],System.StringSplitOptions)"/>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Stringify``1(``0)">
            <summary>
            Converts <paramref name="source"/> into a <see cref="T:System.String"/> representation of <paramref name="source"/>.
            </summary>
            <remarks><para>
            Unlike <see cref="M:System.Object.ToString"/>, the values of all properties are printed out,
            unless they explicitly define a <see cref="M:System.Object.ToString"/>, or implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>,
            in which case each item within is printed out separately.
            </para></remarks>
            <typeparam name="T">The type of the source.</typeparam>
            <param name="source">The item to get a <see cref="T:System.String"/> representation of.</param>
            <returns><paramref name="source"/> as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Stringify``1(``0,System.Int32,System.Boolean)">
            <summary>
            Converts <paramref name="source"/> into a <see cref="T:System.String"/> representation of <paramref name="source"/>.
            </summary>
            <remarks><para>
            Unlike <see cref="M:System.Object.ToString"/>, the values of all properties are printed out,
            unless they explicitly define a <see cref="M:System.Object.ToString"/>, or implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>,
            in which case each item within is printed out separately.
            </para></remarks>
            <typeparam name="T">The type of the source.</typeparam>
            <param name="source">The item to get a <see cref="T:System.String"/> representation of.</param>
            <param name="depth">Determines how deep the recursive function should go.</param>
            <param name="useQuotes">
            Determines whether <see cref="T:System.String"/> and <see cref="T:System.Char"/> have a " and ' surrounding them.
            </param>
            <returns><paramref name="source"/> as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.ToHexString``1(``0)">
            <summary>Converts the value to a hex <see cref="T:System.String"/>.</summary>
            <remarks><para>The implementation is based on
            <a href="https://github.com/CommunityToolkit/dotnet/blob/7b53ae23dfc6a7fb12d0fc058b89b6e948f48448/src/CommunityToolkit.Diagnostics/Extensions/ValueTypeExtensions.cs#L44">
            CommunityToolkit.Diagnostics.ValueTypeExtensions.ToHexString
            </a>.
            </para></remarks>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="value">The value to convert.</param>
            <returns>The hex <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.UseStringifier``1(``0,System.Int32)">
            <summary>Forces the use of reflective stringification.</summary>
            <typeparam name="T">The type of the source.</typeparam>
            <param name="source">The item to get a <see cref="T:System.String"/> representation of.</param>
            <param name="depth">The amount of nesting.</param>
            <returns><paramref name="source"/> as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.AppendMany``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.Char)">
            <summary>Appends an enumeration onto the <see cref="T:System.Text.StringBuilder"/>.</summary>
            <typeparam name="T">The type of each item in the collection.</typeparam>
            <param name="builder">The <see cref="T:System.Text.StringBuilder"/> to mutate and <see langword="return"/>.</param>
            <param name="values">The values to join.</param>
            <param name="separator">The separator between each item.</param>
            <returns>The parameter <paramref name="builder"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.AppendMany``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Appends an enumeration onto the <see cref="T:System.Text.StringBuilder"/>.</summary>
            <typeparam name="T">The type of each item in the collection.</typeparam>
            <param name="builder">The <see cref="T:System.Text.StringBuilder"/> to mutate and <see langword="return"/>.</param>
            <param name="values">The values to join.</param>
            <param name="separator">The separator between each item.</param>
            <returns>The parameter <paramref name="builder"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.IsUnmanaged(System.Type)">
            <summary>Gets the type name, with its generics extended.</summary>
            <param name="type">The <see cref="T:System.Type"/> to get the name of.</param>
            <returns>The name of the parameter <paramref name="type"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.StringRemoval">
            <summary>Provides extension methods for <see cref="T:System.Char"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.Pop(System.String,System.Int32,System.Char@)">
            <summary>Removes the single character based on the index from the langword="string"/>.</summary>
            <param name="str">The builder to take the character from.</param>
            <param name="index">The index to remove.</param>
            <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
            <returns>The parameter <paramref name="str"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.Pop(System.String,System.Index,System.Char@)">
            <inheritdoc cref="M:Emik.Morsels.StringRemoval.Pop(System.Text.StringBuilder,System.Int32,System.Char@)"/>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.Pop(System.String,System.Range,System.String@)">
            <summary>Removes the substring based on the range from the langword="string"/>.</summary>
            <param name="str">The builder to take the character from.</param>
            <param name="range">The range to remove.</param>
            <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="str"/>.
            </exception>
            <returns>The parameter <paramref name="str"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.Remove(System.String,System.Range)">
            <summary>Removes the substring based on the range from the <see langword="string"/>.</summary>
            <param name="str">The builder to take the character from.</param>
            <param name="range">The range to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="str"/>.
            </exception>
            <returns>The parameter <paramref name="str"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.Pop(System.Text.StringBuilder,System.Int32,System.Char@)">
            <summary>Removes the single character based on the index from the <see cref="T:System.Text.StringBuilder"/>.</summary>
            <param name="builder">The builder to take the character from.</param>
            <param name="index">The index to remove.</param>
            <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
            <returns>The parameter <paramref name="builder"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.Pop(System.Text.StringBuilder,System.Index,System.Char@)">
            <inheritdoc cref="M:Emik.Morsels.StringRemoval.Pop(System.Text.StringBuilder,System.Int32,System.Char@)"/>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.Pop(System.Text.StringBuilder,System.Range,System.String@)">
            <summary>Removes the substring based on the range from the <see cref="T:System.Text.StringBuilder"/>.</summary>
            <param name="builder">The builder to take the character from.</param>
            <param name="range">The range to remove.</param>
            <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="builder"/>.
            </exception>
            <returns>The parameter <paramref name="builder"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.Remove(System.Text.StringBuilder,System.Range)">
            <summary>Removes the substring based on the range from the <see cref="T:System.Text.StringBuilder"/>.</summary>
            <param name="builder">The builder to take the character from.</param>
            <param name="range">The range to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="builder"/>.
            </exception>
            <returns>The parameter <paramref name="builder"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.Trim(System.Text.StringBuilder)">
            <inheritdoc cref="M:System.String.Trim"/>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.TrimEnd(System.Text.StringBuilder)">
            <inheritdoc cref="M:System.String.TrimEnd(System.Char[])"/>
        </member>
        <member name="M:Emik.Morsels.StringRemoval.TrimStart(System.Text.StringBuilder)">
            <inheritdoc cref="M:System.String.TrimStart(System.Char[])"/>
        </member>
        <member name="T:Emik.Morsels.Whitespaces">
            <summary>Contains a myriad of strings that list all whitespace characters.</summary>
        </member>
        <member name="F:Emik.Morsels.Whitespaces.Breaking">
            <summary>All unicode characters where <c>White_Space=yes</c>, and are line breaks.</summary>
        </member>
        <member name="F:Emik.Morsels.Whitespaces.NonBreaking">
            <summary>All unicode characters where <c>White_Space=yes</c>, and are not a line break.</summary>
        </member>
        <member name="F:Emik.Morsels.Whitespaces.Related">
            <summary>All unicode characters where <c>White_Space=no</c>, but appears to be whitespace.</summary>
        </member>
        <member name="F:Emik.Morsels.Whitespaces.Unicode">
            <summary>All unicode characters where <c>White_Space=yes</c>.</summary>
        </member>
        <member name="F:Emik.Morsels.Whitespaces.Combined">
            <summary>All unicode characters that appear to be whitespace.</summary>
        </member>
        <member name="T:Emik.Morsels.TupleExtracts">
            <summary>Methods to get elements of a tuple.</summary>
        </member>
        <member name="M:Emik.Morsels.TupleExtracts.First``2(System.ValueTuple{``0,``1})">
            <summary>Gets the first item of the tuple.</summary>
            <typeparam name="T1">The first type of the tuple.</typeparam>
            <typeparam name="T2">The second type of the tuple.</typeparam>
            <param name="tuple">The tuple to get the value from.</param>
            <returns>The field <see cref="F:System.ValueTuple`2.Item1"/> from the parameter <paramref name="tuple"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TupleExtracts.Second``2(System.ValueTuple{``0,``1})">
            <summary>Gets the second item of the tuple.</summary>
            <typeparam name="T1">The first type of the tuple.</typeparam>
            <typeparam name="T2">The second type of the tuple.</typeparam>
            <param name="tuple">The tuple to get the value from.</param>
            <returns>The field <see cref="F:System.ValueTuple`2.Item2"/> from the parameter <paramref name="tuple"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TupleExtracts.AsEnumerable(System.Runtime.CompilerServices.ITuple)">
            <summary>Gets the enumeration of the tuple.</summary>
            <param name="tuple">The tuple to enumerate.</param>
            <returns>The enumeration of the parameter <paramref name="tuple"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TupleExtracts.AsEnumerable``1(``0)">
            <summary>Gets the enumeration of the tuple.</summary>
            <typeparam name="T">The type of tuple.</typeparam>
            <param name="tuple">The tuple to enumerate.</param>
            <returns>The enumeration of the parameter <paramref name="tuple"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Unfolding">
            <summary>Provides methods for unfolding.</summary>
        </member>
        <member name="M:Emik.Morsels.Unfolding.FindPathToNull``1(``0,System.Converter{``0,``0})">
            <summary>Applies a selector and collects the returned items recursively until the value becomes null.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The initial value.</param>
            <param name="converter">The converter to apply.</param>
            <returns>
            The parameter <paramref name="value"/>, followed by each non-null
            returned value from the parameter <paramref name="converter"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Unfolding.FindPathToEmptyNullable``1(``0,System.Converter{``0,``0})">
            <inheritdoc cref="M:Emik.Morsels.Unfolding.FindPathToNull``1(``0,System.Converter{``0,``0})"/>
        </member>
        <member name="M:Emik.Morsels.Unfolding.FindPathToEmptyNullable``1(``0,System.Converter{``0,System.Nullable{``0}})">
            <inheritdoc cref="M:Emik.Morsels.Unfolding.FindPathToNull``1(``0,System.Converter{``0,``0})"/>
        </member>
        <member name="M:Emik.Morsels.Unfolding.FindPathToEmptyNullable``1(System.Nullable{``0},System.Converter{``0,``0})">
            <inheritdoc cref="M:Emik.Morsels.Unfolding.FindPathToNull``1(``0,System.Converter{``0,``0})"/>
        </member>
        <member name="M:Emik.Morsels.Unfolding.FindPathToEmptyNullable``1(System.Nullable{``0},System.Converter{``0,System.Nullable{``0}})">
            <inheritdoc cref="M:Emik.Morsels.Unfolding.FindPathToNull``1(``0,System.Converter{``0,``0})"/>
        </member>
        <member name="M:Emik.Morsels.Unfolding.FindSmallPathToNull``1(``0,System.Converter{``0,``0})">
            <inheritdoc cref="M:Emik.Morsels.Unfolding.FindPathToNull``1(``0,System.Converter{``0,``0})"/>
        </member>
        <member name="M:Emik.Morsels.Unfolding.FindSmallPathToEmptyNullable``1(``0,System.Converter{``0,``0})">
            <inheritdoc cref="M:Emik.Morsels.Unfolding.FindPathToNull``1(``0,System.Converter{``0,``0})"/>
        </member>
        <member name="M:Emik.Morsels.Unfolding.FindSmallPathToEmptyNullable``1(``0,System.Converter{``0,System.Nullable{``0}})">
            <inheritdoc cref="M:Emik.Morsels.Unfolding.FindPathToNull``1(``0,System.Converter{``0,``0})"/>
        </member>
        <member name="M:Emik.Morsels.Unfolding.FindSmallPathToEmptyNullable``1(System.Nullable{``0},System.Converter{``0,``0})">
            <inheritdoc cref="M:Emik.Morsels.Unfolding.FindPathToNull``1(``0,System.Converter{``0,``0})"/>
        </member>
        <member name="M:Emik.Morsels.Unfolding.FindSmallPathToEmptyNullable``1(System.Nullable{``0},System.Converter{``0,System.Nullable{``0}})">
            <inheritdoc cref="M:Emik.Morsels.Unfolding.FindPathToNull``1(``0,System.Converter{``0,``0})"/>
        </member>
        <member name="T:Emik.Morsels.VersionDeconstructors">
            <summary>Methods that deconstructs <see cref="T:System.Version"/> instances.</summary>
        </member>
        <member name="M:Emik.Morsels.VersionDeconstructors.Deconstruct(System.Version,System.Int32@,System.Int32@)">
            <summary>Deconstructs this instance into the major and minor versions.</summary>
            <remarks><para>
            If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
            </para></remarks>
            <param name="version">The <see cref="T:System.Version"/> to deconstruct.</param>
            <param name="major">The resulting major version.</param>
            <param name="minor">The resulting minor version.</param>
        </member>
        <member name="M:Emik.Morsels.VersionDeconstructors.Deconstruct(System.Version,System.Int32@,System.Int32@,System.Int32@)">
            <summary>Deconstructs this instance into the major, minor, and build versions.</summary>
            <remarks><para>
            If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
            </para></remarks>
            <param name="version">The <see cref="T:System.Version"/> to deconstruct.</param>
            <param name="major">The resulting major version.</param>
            <param name="minor">The resulting minor version.</param>
            <param name="build">The resulting build version.</param>
        </member>
        <member name="M:Emik.Morsels.VersionDeconstructors.Deconstruct(System.Version,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>Deconstructs this instance into the major, minor, build, and revision versions.</summary>
            <remarks><para>
            If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
            </para></remarks>
            <param name="version">The <see cref="T:System.Version"/> to deconstruct.</param>
            <param name="major">The resulting major version.</param>
            <param name="minor">The resulting minor version.</param>
            <param name="build">The resulting build version.</param>
            <param name="revision">The resulting revision version.</param>
        </member>
        <member name="M:Emik.Morsels.VersionDeconstructors.Deconstruct(System.Version,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Deconstructs this instance into the major, minor, build, major revision, and minor revision versions.
            </summary>
            <remarks><para>
            If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
            </para></remarks>
            <param name="version">The <see cref="T:System.Version"/> to deconstruct.</param>
            <param name="major">The resulting major version.</param>
            <param name="minor">The resulting minor version.</param>
            <param name="build">The resulting build version.</param>
            <param name="majorRevision">The resulting major revision version.</param>
            <param name="minorRevision">The resulting minor revision version.</param>
        </member>
        <member name="T:Emik.MatchAttribute">
            <summary>Declares a contract that the generic parameter must include the qualified member.</summary>
        </member>
        <member name="M:Emik.MatchAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>Initializes a new instance of the <see cref="T:Emik.MatchAttribute"/> class.</summary>
            <param name="pattern">The regular expression pattern to match.</param>
            <param name="options">The bitwise combination of the enumeration values that modify the regular expression.</param>
        </member>
        <member name="P:Emik.MatchAttribute.Pattern">
            <summary>Gets the regular expression to match.</summary>
        </member>
        <member name="P:Emik.MatchAttribute.Options">
            <summary>Gets the bitwise combination of the enumeration values that modify the regular expression.</summary>
        </member>
        <member name="T:Emik.RegexDeconstructors">
            <summary>Declares a contract that the generic parameter must include the qualified member.</summary>
        </member>
        <member name="T:Emik.ChoiceAttribute">
            <summary>
            Indicates to Emik.SourceGenerators.Choices to extend the type, transforming it to a disjoint union.
            </summary>
        </member>
        <member name="M:Emik.ChoiceAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.ChoiceAttribute"/> class.
            </summary>
        </member>
        <member name="M:Emik.ChoiceAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.ChoiceAttribute"/> class.
            </summary>
            <param name="set">The type of fields that define the annotated union.</param>
        </member>
        <member name="M:Emik.ChoiceAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.ChoiceAttribute"/> class.
            </summary>
            <param name="isPubliclyMutable">Determines if mutability is private or public.</param>
        </member>
        <member name="M:Emik.ChoiceAttribute.#ctor(System.Type,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.ChoiceAttribute"/> class.
            </summary>
            <param name="set">The type of fields that define the annotated union.</param>
            <param name="isPubliclyMutable">Determines if mutability is private or public.</param>
        </member>
        <member name="M:Emik.ChoiceAttribute.#ctor(System.Boolean,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.ChoiceAttribute"/> class.
            </summary>
            <param name="isPubliclyMutable">Determines if mutability is private or public.</param>
            <param name="set">The type of fields that define the annotated union.</param>
        </member>
        <member name="P:Emik.ChoiceAttribute.IsPubliclyMutable">
            <summary>
            When specified, determines whether the type is mutable publicly.
            </summary>
        </member>
        <member name="P:Emik.ChoiceAttribute.Set">
            <summary>
            When specified, gets the set of fields that define the annotated union.
            </summary>
        </member>
        <member name="T:Emik.NoImplicitOperatorAttribute">
            <summary>
            Prevents the analyzer from generating the implicit conversion into this constructor.
            </summary>
        </member>
        <member name="T:Emik.NoStructuralTypingAttribute">
            <summary>Signifies to ignore this when determining potential interfaces that can be implemented.</summary>
            <remarks>
            <para>
            The behavior of this attribute depends on what you apply it on:
            </para>
            <list type="table">
               <listheader>
                   <term>Target</term>
                   <description>Behavior</description>
               </listheader>
               <item>
                   <term>Type Member</term>
                   <description>Ignores the type altogether. No generation is ever performed on it.</description>
               </item>
               <item>
                   <term>Member</term>
                   <description>Ignores only this particular member when evaluating potential interfaces.</description>
               </item>
            </list>
            </remarks>
        </member>
        <member name="T:NullGuard.AllowNullAttribute">
            <summary>Prevents the injection of null checking (implicit mode only).</summary>
        </member>
        <member name="T:NullGuard.MaybeNullTaskResultAttribute">
            <summary>Prevents the injection of null checking (implicit mode only).</summary>
        </member>
        <member name="T:NullGuard.NullGuardAttribute">
            <summary>Prevents the injection of null checking (implicit mode only).</summary>
            <param name="flags">
            The <see cref="T:NullGuard.ValidationFlags"/> to use for the target this attribute is being applied to.
            </param>
        </member>
        <member name="M:NullGuard.NullGuardAttribute.#ctor(NullGuard.ValidationFlags)">
            <summary>Prevents the injection of null checking (implicit mode only).</summary>
            <param name="flags">
            The <see cref="T:NullGuard.ValidationFlags"/> to use for the target this attribute is being applied to.
            </param>
        </member>
        <member name="M:NullGuard.NullGuardAttribute.op_Implicit(NullGuard.ValidationFlags)~NullGuard.NullGuardAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of NullGuardAttribute by using the constructor
            <see cref="M:NullGuard.NullGuardAttribute.#ctor(NullGuard.ValidationFlags)"/>.
            </summary>
            <param name="flags">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of NullGuardAttribute by passing the parameter <paramref name="flags"/> to the constructor
            <see cref="M:NullGuard.NullGuardAttribute.#ctor(NullGuard.ValidationFlags)"/>.
            </returns>
        </member>
        <member name="T:NullGuard.ValidationFlags">
            <summary>Used by <see cref="T:NullGuard.NullGuardAttribute"/> to target specific categories of members.</summary>
        </member>
        <member name="F:NullGuard.ValidationFlags.None">
            <summary>Does nothing.</summary>
        </member>
        <member name="F:NullGuard.ValidationFlags.Properties">
            <summary>
            Adds null guard checks to properties getter (cannot return null) and setter (cannot be set to null).
            </summary>
        </member>
        <member name="F:NullGuard.ValidationFlags.Arguments">
            <summary>
            Method arguments are checked to make sure they are not null. This only
            applies to normal arguments, and the incoming value of a ref argument.
            </summary>
        </member>
        <member name="F:NullGuard.ValidationFlags.AllPublicArguments">
            <summary>Processes all methods (arguments and return values) and properties.</summary>
        </member>
        <member name="F:NullGuard.ValidationFlags.OutValues">
            <summary>Out and ref arguments of a method are checked for null just before the method returns.</summary>
        </member>
        <member name="F:NullGuard.ValidationFlags.ReturnValues">
            <summary>Checks the return value of a method for null.</summary>
        </member>
        <member name="F:NullGuard.ValidationFlags.Methods">
            <summary>Processes all arguments (normal, out and ref) and return values of methods.</summary>
        </member>
        <member name="F:NullGuard.ValidationFlags.AllPublic">
            <summary>Checks everything (properties, all method args and return values).</summary>
        </member>
        <member name="F:NullGuard.ValidationFlags.NonPublic">
            <summary>Applies the other flags to all non-public members as well.</summary>
        </member>
        <member name="F:NullGuard.ValidationFlags.All">
            <summary>Wildcard.</summary>
        </member>
        <member name="T:Virtuosity.DoNotVirtualizeAttribute">
            <summary>Used to exclude a class form virtualization.</summary>
        </member>
        <member name="T:InlineMethod.InlineAttribute">
            <summary>Method to inline.</summary>
        </member>
        <member name="M:InlineMethod.InlineAttribute.#ctor(System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:InlineMethod.InlineAttribute"/> class.</summary>
            <param name="remove">The value to set.</param>
        </member>
        <member name="P:InlineMethod.InlineAttribute.Remove">
            <summary>Gets a value indicating whether to remove the method after inlining, if private.</summary>
        </member>
        <member name="M:InlineMethod.InlineAttribute.op_Implicit(System.Boolean)~InlineMethod.InlineAttribute">
            <summary>
            Implicitly converts the parameter by creating the new instance of InlineAttribute by using the constructor
            <see cref="M:InlineMethod.InlineAttribute.#ctor(System.Boolean)"/>.
            </summary>
            <param name="remove">The parameter to pass onto the constructor.</param>
            <returns>
            The new instance of InlineAttribute by passing the parameter <paramref name="remove"/> to the constructor
            <see cref="M:InlineMethod.InlineAttribute.#ctor(System.Boolean)"/>.
            </returns>
        </member>
        <member name="T:CanvasModule">
            <summary>On the Subject of The Canvas.</summary>
        </member>
    </members>
</doc>
