<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emik.Unions</name>
    </assembly>
    <members>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks><para>
            Index is used by the C# compiler to support the new index syntax.
            </para><code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code></remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks><para>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means
            pointing at beyond last element.
            </para></remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <inheritdoc />
        </member>
        <member name="M:System.Index.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">
            The length of the collection that the Index will be used with. length has to be a positive value.
            </param>
            <remarks><para>
            For performance reasons, we don't validate the input length parameter and the returned offset value against
            negative values. We don't validate either the returned offset is greater than the input length.
            It is expected that Index be used with collections which always have non-negative length/count.
            If the returned offset is negative and then used to index a collection will get out of range exception which
            will be same affect as the validation.
            </para></remarks>
        </member>
        <member name="M:System.Index.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks><para>
            Range is used by the C# compiler to support the range syntax.
            </para><code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code></remarks>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <inheritdoc />
        </member>
        <member name="M:System.Range.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Range.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.RangeMethodsWithoutValueTuples">
            <summary>Implements a <see cref="M:System.RangeMethodsWithoutValueTuples.GetOffsetAndLength(System.Range,System.Int32,System.Int32@,System.Int32@)"/> overload that doesn't rely on tuples.</summary>
        </member>
        <member name="M:System.RangeMethodsWithoutValueTuples.GetOffsetAndLength(System.Range,System.Int32,System.Int32@,System.Int32@)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <remarks><para>
            For performance reasons, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </para></remarks>
            <param name="range">The <see cref="T:System.Range"/> that contains the range of elements.</param>
            <param name="length">
            The length of the collection that the range will be used with.
            <paramref name="length"/> has to be a positive value.
            </param>
            <param name="outOffset">The resulting offset.</param>
            <param name="outLength">The resulting length.</param>
        </member>
        <member name="T:System.Diagnostics.Contracts.PureAttribute">
            <summary>Indicates that a type or method is pure, that is, it does not make any visible state changes.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute"/> class
            with the specified return value condition.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>,
            the parameter will not be null even if the corresponding type allows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute"/> class
            with the specified return value condition.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute"/> class
            with the associated parameter name.
            </summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute"/> class
            with the specified parameter value.
            </summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>
            Gets a value indicating whether the condition parameter value
            is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute"/> class with a field or property member.
            </summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute"/> class
            with the list of field and property members.
            </summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute"/> class
            with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute"/> class
            with the specified return value condition and list of field and property members.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type,
            and callers do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.UnreachableException">
            <summary>Exception thrown when the program executes an instruction that was thought to be unreachable.</summary>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with a specified error message
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:System.Runtime.CompilerServices.ITuple">
            <summary>This interface is required for types that want to be indexed into by dynamic patterns.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Length">
            <summary>The number of positions in this data structure.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)">
            <summary>Get the element at position <paramref name="index"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleElementNamesAttribute">
            <summary>
            Indicates that the use of <see cref="T:System.ValueTuple" /> on a member is meant to be treated as a tuple with element names.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute" /> class.
            </summary>
            <param name="transformNames">
            Specifies, in a pre-order depth-first traversal of a type's
            construction, which <see cref="T:System.ValueTuple" /> occurrences are
            meant to carry element names.
            </param>
            <remarks><para>
            This constructor is meant to be used on types that contain an
            instantiation of <see cref="T:System.ValueTuple" /> that contains
            element names.  For instance, if <c>C</c> is a generic type with
            two type parameters, then a use of the constructed type <c>C{<see cref="T:System.ValueTuple`2" />,
            <see cref="T:System.ValueTuple`3" /></c> might be intended to
            treat the first type argument as a tuple with element names and the
            second as a tuple without element names. In which case, the
            appropriate attribute specification should use a
            <paramref name="transformNames"/> value of <c>{ "name1", "name2", null, null,
            null }</c>.
            </para></remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames">
            <summary>
            Specifies, in a pre-order depth-first traversal of a type's
            construction, which <see cref="T:System.ValueTuple" /> elements are
            meant to carry element names.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
            <summary>
            Used to indicate to the compiler that a method should be called in its containing module's initializer.
            </summary>
            <remarks><para>
            When one or more valid methods with this attribute are found in a compilation,
            the compiler will emit a module initializer that calls each of the attributed methods.<br />
            Certain requirements are imposed on any method targeted with this attribute:
            </para><list type="bullet">
            <item><description>The method must be <see langword="static"/>.</description></item>
            <item><description>
            The method must be an ordinary member method, as opposed to a property accessor,
            constructor, local function, and so on.
            </description></item>
            <item><description>The method must be parameterless..</description></item>
            <item><description>The method must return <see langword="void"/>.</description></item>
            <item><description>The method must not be generic or be contained in a generic type.</description></item>
            <item><description>
            The method's effective accessibility must be <see langword="internal"/> or <see langword="public"/>.
            </description></item>
            </list><para>
            For more information, see
            https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerFilePathAttribute">
            <inheritdoc />
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerLineNumberAttribute">
            <inheritdoc />
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerMemberNameAttribute">
            <inheritdoc />
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>Indicates that a parameter captures the expression passed for another parameter as a string.</summary>
            <remarks><para>This attribute is implemented in the compiler for C# 10 and later versions only.</para></remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.</summary>
            <param name="parameterName">The name of the parameter whose expression should be captured as a string.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>Gets the name of the parameter whose expression should be captured as a string.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
            </summary>
            <remarks><para>
            This attribute is unsafe because it may reveal uninitialized memory to the application in certain
            instances (e.g., reading from uninitialized stackalloc'd memory). If applied to a method directly,
            the attribute applies to that method and all nested functions (lambdas, local functions) below it.
            If applied to a type or module, it applies to all methods nested inside. This attribute is intentionally
            not permitted on assemblies. Use at the module level instead to apply to multiple type declarations.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is
            required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> class.</summary>
            <param name="featureName">The name of the compiler feature.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>Gets the name of the compiler feature.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            Gets or sets a value indicating whether the compiler can choose to allow access to the location
            where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>Specifies that a type has required members or that a member is required.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RuntimeHelpers">
            <summary>
            Provides a set of static methods and properties that provide support for compilers. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray``1(``0[],System.Range)">
            <summary>Slices the specified array using the specified range.</summary>
            <typeparam name="T">The type of elements in the array.</typeparam>
            <param name="array">The array to slice.</param>
            <param name="range">
            An object that determines the portion of <paramref name="array"/> to include in the slice.
            </param>
            <returns>The subarray defined by <paramref name="range"/>.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.MethodImplOptions">
            <summary>
            Specifies constants that define the details of how a method is implemented.
            This enumeration supports a bitwise combination of its member values.
            </summary>
            <remarks><para>
            This enumeration is used with the <see cref="T:System.Runtime.CompilerServices.MethodImplAttribute"/> attribute.
            You can specify multiple <see cref="T:System.Runtime.CompilerServices.MethodImplOptions"/> values by using the bitwise OR operator.
            </para></remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.Unmanaged">
            <summary>The method is implemented in unmanaged code.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.NoInlining">
            <summary>
            The method cannot be inlined.
            Inlining is an optimization by which a method call is replaced with the method body.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.ForwardRef">
            <summary>The method is declared, but its implementation is provided elsewhere.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.Synchronized">
            <summary>
            The method can be executed by only one thread at a time.
            Static methods lock on the type, whereas instance methods lock on the instance.
            Only one thread can execute in any of the instance functions,
            and only one thread can execute in any of a class's static functions.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.NoOptimization">
            <summary>
            The method is not optimized by the just-in-time (JIT) compiler or by native code generation (see Ngen.exe)
            when debugging possible code generation problems.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.PreserveSig">
            <summary>The method signature is exported exactly as declared.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining">
            <summary>The method should be inlined if possible.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization">
            <summary>The method contains code that should always be optimized by the just-in-time (JIT) compiler.</summary>
            <remarks><para>
            Use this attribute if running an unoptimized version of the method has undesirable effects,
            for instance causing too much overhead or extra memory allocation.
            </para><para>
            Methods with this attribute may not have optimal code generation.
            They bypass the first tier of Tiered Compilation and therefore can't benefit from optimizations that rely on
            tiering, for example, Dynamic PGO or optimizations based on initialized classes.
            </para></remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.InternalCall">
            <summary>
            The call is internal, that is, it calls a method that's implemented within the common language runtime.
            </summary>
        </member>
        <member name="T:System.IValueTupleInternal">
            <summary>
            Helper so we can call some tuple methods recursively without knowing the underlying types.
            </summary>
        </member>
        <member name="T:System.ValueTuple">
            <summary>
            The ValueTuple types (from arity 0 to 8) comprise the runtime implementation that underlies tuples in C# and struct tuples in F#.
            Aside from created via language syntax, they are most easily created via the ValueTuple.Create factory methods.
            The System.ValueTuple types differ from the System.Tuple types in that:
            - they are structs rather than classes,
            - they are mutable rather than readonly, and
            - their members (such as Item1, Item2, etc) are fields rather than properties.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is a <see cref="T:System.ValueTuple"/>.</returns>
        </member>
        <member name="M:System.ValueTuple.Equals(System.ValueTuple)">
            <summary>Returns a value indicating whether this instance is equal to a specified value.</summary>
            <param name="other">An instance to compare to this instance.</param>
            <returns>true if <paramref name="other"/> has the same value as this instance; otherwise, false.</returns>
        </member>
        <member name="M:System.ValueTuple.CompareTo(System.ValueTuple)">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>()</c>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Create">
            <summary>Creates a new struct 0-tuple.</summary>
            <returns>A 0-tuple.</returns>
        </member>
        <member name="M:System.ValueTuple.Create``1(``0)">
            <summary>Creates a new struct 1-tuple, or singleton.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <returns>A 1-tuple (singleton) whose value is (item1).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``2(``0,``1)">
            <summary>Creates a new struct 2-tuple, or pair.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <returns>A 2-tuple (pair) whose value is (item1, item2).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``3(``0,``1,``2)">
            <summary>Creates a new struct 3-tuple, or triple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <returns>A 3-tuple (triple) whose value is (item1, item2, item3).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``4(``0,``1,``2,``3)">
            <summary>Creates a new struct 4-tuple, or quadruple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <returns>A 4-tuple (quadruple) whose value is (item1, item2, item3, item4).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``5(``0,``1,``2,``3,``4)">
            <summary>Creates a new struct 5-tuple, or quintuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <returns>A 5-tuple (quintuple) whose value is (item1, item2, item3, item4, item5).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>Creates a new struct 6-tuple, or sextuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <returns>A 6-tuple (sextuple) whose value is (item1, item2, item3, item4, item5, item6).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>Creates a new struct 7-tuple, or septuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <returns>A 7-tuple (septuple) whose value is (item1, item2, item3, item4, item5, item6, item7).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Creates a new struct 8-tuple, or octuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <typeparam name="T8">The type of the eighth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <param name="item8">The value of the eighth component of the tuple.</param>
            <returns>An 8-tuple (octuple) whose value is (item1, item2, item3, item4, item5, item6, item7, item8).</returns>
        </member>
        <member name="T:System.ValueTuple`1">
            <summary>Represents a 1-tuple, or singleton, as a value type.</summary>
            <typeparam name="T1">The type of the tuple's only component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`1.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`1"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`1"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`1"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.ValueTuple{`0})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`1"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its field
            is equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.CompareTo(System.ValueTuple{`0})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`1.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`1.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`1"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1)</c>,
            where <c>Item1</c> represents the value of <see cref="F:System.ValueTuple`1.Item1"/>. If the field is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`2">
            <summary>
            Represents a 2-tuple, or pair, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`2.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`2.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`2"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.Object)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified object.
             </summary>
             <param name="obj">The object to compare with this instance.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
             <list type="bullet">
                 <item><description>It is a <see cref="T:System.ValueTuple`2"/> value type.</description></item>
                 <item><description>Its components are of the same types as those of the current instance.</description></item>
                 <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.ValueTuple{`0,`1})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified <see cref="T:System.ValueTuple`2"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`2.CompareTo(System.ValueTuple{`0,`1})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`2.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`2.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`2"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2)</c>,
            where <c>Item1</c> and <c>Item2</c> represent the values of the <see cref="F:System.ValueTuple`2.Item1"/>
            and <see cref="F:System.ValueTuple`2.Item2"/> fields. If either field value is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`3">
            <summary>
            Represents a 3-tuple, or triple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`3.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's third component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`3"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`3"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.ValueTuple{`0,`1,`2})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`3"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.CompareTo(System.ValueTuple{`0,`1,`2})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`3.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`3.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`3"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`4">
            <summary>
            Represents a 4-tuple, or quadruple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`4.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's fourth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`4"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`4"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.ValueTuple{`0,`1,`2,`3})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`4"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.CompareTo(System.ValueTuple{`0,`1,`2,`3})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`4.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`4.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`4"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`5">
            <summary>
            Represents a 5-tuple, or quintuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`5.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fifth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`5"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`5"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`5"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`5.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`5.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`5"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`6">
            <summary>
            Represents a 6-tuple, or sixtuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`6.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's sixth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`6"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`6"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`6"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`6.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`6.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`6"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`7">
            <summary>
            Represents a 7-tuple, or sentuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`7.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's seventh component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`7"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`7"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`7"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`7.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`7.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`7"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`8">
            <summary>
            Represents an 8-tuple, or octuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
            <typeparam name="TRest">The type of the tuple's eighth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`8.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's seventh component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Rest">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's eighth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`8"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
            <param name="rest">The value of the tuple's eight component.</param>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`8"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`8"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`8.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`8.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`8"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7, Rest)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.KeyValuePairDeconstructors">
            <summary>Allows a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> to be deconstructed, much like a tuple.</summary>
        </member>
        <member name="M:System.KeyValuePairDeconstructors.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>Deconstructs a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> into its components.</summary>
            <typeparam name="TKey">The key generic in the <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</typeparam>
            <typeparam name="TValue">The value generic in the <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</typeparam>
            <param name="kvp">The key value pair to deconstruct.</param>
            <param name="key">The key value to get assigned as the key value pair's key.</param>
            <param name="value">The key value to get assigned as the key value pair's value.</param>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyCollection`1">
            <summary>Provides a read-only, covariant view of a generic list.</summary>
            <typeparam name="T">The type of item on the list.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyCollection`1.Count">
            <summary>Gets the amount of items on the list.</summary>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyDictionary`2">
            <summary>Represents a generic read-only collection of key/value pairs.</summary>
            <typeparam name="TKey">The type of keys in the read-only dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the read-only dictionary.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Keys">
            <summary>Gets an enumerable collection that contains the keys in the read-only dictionary.</summary>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Values">
            <summary>Gets an enumerable collection that contains the values in the read-only dictionary.</summary>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Item(`0)">
            <summary>Gets the element that has the specified key in the read-only dictionary.</summary>
            <param name="key">The key to locate.</param>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the read-only dictionary contains an element that has the specified key.</summary>
            <param name="key">The key to locate.</param>
            <returns>
            <see langword="true"/> if the read-only dictionary contains an element that has the specified key;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>Gets the value that is associated with the specified key.</summary>
            <param name="key">The key to locate.</param>
            <param name="value">
            When this method returns, the value associated with the specified key, if the key is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <see langword="true"/> if the object that implements the <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>
            interface contains an element that has the specified key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyList`1">
            <summary>Represents a read-only collection of elements that can be accessed by index.</summary>
            <typeparam name="T">The type of elements in the read-only list.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyList`1.Item(System.Int32)">
            <summary>Performs an index operation on the list.</summary>
            <param name="index">The item to retrieve.</param>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlySet`1">
            <summary>Provides a readonly abstraction of a set.</summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.Contains(`0)">
            <summary>Determines if the set contains a specific item.</summary>
            <param name="item">The item to check if the set contains.</param>
            <returns><see langword="true"/> if found; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) subset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set is a proper subset of other; otherwise <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) superset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the collection is a proper superset of other; otherwise <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determine whether the current set is a subset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true"/> if the current set is a subset of other; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determine whether the current set is a super set of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true"/> if the current set is a subset of other; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set overlaps with the specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set and other share at least one common element;
            otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set is equal to other; otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="T:System.Collections.Generic.ISet`1">
            <summary>Provides the base interface for the abstraction of sets.</summary>
            <remarks><para>
            This interface provides methods for implementing sets,
            which are collections that have unique elements and specific operations.
            </para></remarks>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes all elements in the specified collection from the current set.</summary>
            <remarks><para>
            This method is an O(<c>n</c>) operation,
            where <c>n</c> is the number of elements in the <paramref name="other"/> parameter.
            </para></remarks>
            <param name="other">The collection of items to remove from the set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains only elements that are also in a specified collection.
            </summary>
            <remarks><para>This method ignores any duplicate elements in other.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains only elements that are present
            either in the current set or in the specified collection, but not both.
            </summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains all elements that are present in the current set,
            in the specified collection, or in both.
            </summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.Add(`0)">
            <summary>
            Adds an element to the current set and returns a value to indicate if the element was successfully added.
            </summary>
            <param name="item">The element to add to the set.</param>
            <returns>
            <see langword="true"/> if the element is added to the set;
            <see langword="false"/> if the element is already in the set.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) superset of a specified collection.</summary>
            <remarks><para>
            If the current set is a proper superset of <paramref name="other"/>,
            <paramref name="other"/> must have at least one element that the current set does not have.
            </para><para>
            An empty set is a proper superset of any other collection. Therefore, this method returns <see langword="true"/>
            if the current set is empty, unless the <paramref name="other"/> parameter is also an empty set.
            </para><para>
            This method always returns <see langword="false"/> if the current set is
            less than or equal to the number of elements in <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a proper superset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) subset of a specified collection.</summary>
            <remarks><para>
            If the current set is a proper subset of <paramref name="other"/>,
            <paramref name="other"/> must have at least one element that the current set does not have.
            </para><para>
            An empty set is a proper subset of any other collection. Therefore, this method returns <see langword="true"/>
            if the current set is empty, unless the <paramref name="other"/> parameter is also an empty set.
            </para><para>
            This method always returns <see langword="false"/> if the current set has
            more or the same number of elements than <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a proper subset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a set is a subset of a specified collection.</summary>
            <remarks><para>
            If <paramref name="other"/> contains the same elements as the current set,
            the current set is still considered a subset of <paramref name="other"/>.
            </para><para>
            This method always returns <see langword="false"/> if the current
            set has elements that are not in <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a subset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a superset of a specified collection.</summary>
            <remarks><para>
            If <paramref name="other"/> contains the same elements as the current set,
            the current set is still considered a superset of <paramref name="other"/>.
            </para><para>
            This method always returns <see langword="false"/> if the current
            set has fewer elements than <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a superset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set overlaps with the specified collection.</summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set and <paramref name="other"/> share at least one common element;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is equal to <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Each">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32,System.Action)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32,System.Action{System.Int32})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0,System.Action{``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0,System.Action{System.Int32,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,System.Int32,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IDictionary{``0,``1},System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{``0,``1,``2})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IDictionary{``0,``1},System.Action{``0,``1,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{``0,``1,System.Int32,``2})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="num">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.GetEnumerator(System.Int32)">
            <summary>Gets an enumeration of a number.</summary>
            <param name="num">The index to count up or down to.</param>
            <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Int32"/> from ranges 0 to <paramref name="upper"/> - 1.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,System.Func{``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TResult">The type of iterator.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The function for each loop.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,System.Converter{System.Int32,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TResult">The type of iterator.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The function for each loop.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Force">
            <summary>Extension methods to force full enumerations.</summary>
        </member>
        <member name="M:Emik.Morsels.Force.Enumerate(System.Collections.IEnumerable)">
            <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
            <param name="iterable">The collection of items to go through one-by-one.</param>
        </member>
        <member name="M:Emik.Morsels.Force.Enumerate``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
        </member>
        <member name="T:Emik.Morsels.Heap">
            <summary>Provides methods for heap-allocation analysis.</summary>
        </member>
        <member name="F:Emik.Morsels.Heap.NotForProduction">
            <summary>
            A <see langword="string"/> to use in an <see cref="T:System.ObsoleteAttribute"/> to indicate that the API isn't meant
            for production, but not for deprecated reasons.
            </summary>
        </member>
        <member name="M:Emik.Morsels.Heap.Swallow(System.Action)">
            <summary>Swallows all exceptions from a callback; Use with caution.</summary>
            <param name="action">The dangerous callback.</param>
        </member>
        <member name="M:Emik.Morsels.Heap.CountAllocation(System.Action,System.Boolean)">
            <summary>Gets the amount of bytes a callback uses.</summary>
            <remarks><para>
            This method temporarily tunes the <see cref="T:System.GC"/> to <see cref="F:System.Runtime.GCLatencyMode.LowLatency"/>
            for accurate results. As such, the parameter <paramref name="heap"/> should not cause
            substantial allocation such that collecting mid-way is required.
            </para></remarks>
            <param name="heap">The callback that causes some amount of heap allocation.</param>
            <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
            <returns>The number of bytes the <see cref="T:System.GC"/> allocated from calling <paramref name="heap"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Heap.CountAllocations(System.Action,System.Int32,System.Boolean)">
            <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
            <param name="heap">The callback that causes some amount of heap allocation.</param>
            <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
            <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
            <returns>
            An <see cref="T:System.Array"/> where each entry is a separate test of the number of
            bytes the <see cref="T:System.GC"/> allocated from calling <paramref name="heap"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.TryTake">
            <summary>Extension methods to attempt to grab values from enumerables.</summary>
        </member>
        <member name="M:Emik.Morsels.TryTake.TryCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Attempts to determine the number of elements in a sequence without forcing an enumeration.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <remarks><para>
            The method performs a series of type tests, identifying common subtypes whose
            count can be determined without enumerating; this includes <see cref="T:System.Collections.Generic.ICollection`1"/>,
            <see cref="T:System.Collections.ICollection"/>, and <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.
            </para><para>
            The method is typically a constant-time operation, but ultimately this depends on the complexity
            characteristics of the underlying collection implementation.
            </para></remarks>
            <returns>The length of the collection if pre-computed, or <see langword="null"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.EnumerateOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the last item lazily, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.FirstOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the first item, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The first item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.LastOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the last item, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.OrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns the enumeration, or an empty enumeration.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The enumeration to potentially return.</param>
            <returns>The parameter <paramref name="iterable"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.NthLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Nth``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="TKey">The key item in the collection.</typeparam>
            <typeparam name="TValue">The value item in the collection.</typeparam>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="key">The key to use to get the value.</param>
            <returns>An element from the parameter <paramref name="dictionary"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.EachLazy">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,System.Int32,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Enumerable`2">
            <summary>
            Defines an <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a <see cref="T:System.Delegate"/> that is invoked on iteration.
            </summary>
            <typeparam name="T">The type of item in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TExternal">The context element to pass into the <see cref="T:System.Delegate"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32,`1})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Delegate)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Enumerable`2"/> class.</summary>
            <param name="enumerable">
            The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create an <see cref="T:System.Collections.Generic.IEnumerator`1"/> from.
            </param>
            <param name="external">The context element.</param>
            <param name="action">The <see cref="T:System.Delegate"/> to invoke on iteration.</param>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Enumerable`2.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Enumerable`2.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Indexers">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Indexers.For(System.Index)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="index">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.For(System.Range)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="range">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Index)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Range)">
            <summary>Gets a range of items from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get a range of items from.</param>
            <param name="range">The ranges to get.</param>
            <returns>A slice from the parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.GetEnumerator(System.Index)">
            <summary>Gets an enumeration of an index.</summary>
            <param name="index">The index to count up or down to.</param>
            <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.GetEnumerator(System.Range)">
            <summary>Gets an enumeration of a range.</summary>
            <param name="range">The range to iterate over.</param>
            <returns>An enumeration from the range's start to end.</returns>
        </member>
        <member name="T:Emik.Morsels.ManyQueries">
            <summary>Methods that creates enumerations from individual items.</summary>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(``0,System.Converter{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="item">The item to check.</param>
            <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Nullable{``0},System.Converter{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="item">The item to check.</param>
            <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Peeks">
            <summary>Provides methods to use callbacks within a statement.</summary>
        </member>
        <member name="E:Emik.Morsels.Peeks.OnWrite">
            <summary>An event that is invoked every time <see cref="M:Emik.Morsels.Peeks.Write(System.String)"/> is called.</summary>
        </member>
        <member name="M:Emik.Morsels.Peeks.Shout(System.String)">
            <summary>
            Invokes <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>, and <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)"/>.
            </summary>
            <remarks><para>
            This method exists to be able to hook both conditional methods in <see cref="E:Emik.Morsels.Peeks.OnWrite"/>,
            and to allow the consumer to be able to remove this method to the same <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.
            </para></remarks>
            <param name="message">The value to send a message.</param>
        </member>
        <member name="M:Emik.Morsels.Peeks.Write(System.String)">
            <summary>Quick and dirty debugging function, invokes <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.</summary>
            <param name="message">The value to send a message.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
        </member>
        <member name="M:Emik.Morsels.Peeks.Write``1(``0)">
            <summary>Quick and dirty debugging function, invokes <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to stringify.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
        </member>
        <member name="M:Emik.Morsels.Peeks.Debug``1(``0,System.Boolean,System.Converter{``0,System.Object},System.Predicate{``0},System.Action{System.String},System.String,System.String,System.Int32,System.String)">
            <summary>Quick and dirty debugging function.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to stringify and return.</param>
            <param name="shouldLogExpression">Determines whether <paramref name="expression"/> is logged.</param>
            <param name="map">The map callback.</param>
            <param name="filter">The filter callback.</param>
            <param name="logger">The logging callback.</param>
            <param name="expression">Automatically filled by compilers; the source code of <paramref name="value"/>.</param>
            <param name="path">Automatically filled by compilers; the file's path where this method was called.</param>
            <param name="line">Automatically filled by compilers; the line number where this method was called.</param>
            <param name="member">Automatically filled by compilers; the member's name where this method was called.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Peeks.Peek``1(``0,System.Action{``0})">
            <summary>Executes an <see cref="T:System.Action`1"/>, and returns the argument.</summary>
            <typeparam name="T">The type of value and action parameter.</typeparam>
            <param name="value">The value to pass into the callback.</param>
            <param name="action">The callback to perform.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Clamped">
            <summary>Extension methods to clamp numbers.</summary>
        </member>
        <member name="M:Emik.Morsels.Clamped.Clamp(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
            <param name="number">The number to clip.</param>
            <param name="min">If specified, the smallest number to return.</param>
            <param name="max">If specified, the greatest number to return.</param>
            <returns>
            The parameter <paramref name="min"/> if <paramref name="number"/> is smaller than <paramref name="min"/>,
            otherwise, the parameter <paramref name="max"/> if <paramref name="number"/> is greater than
            <paramref name="max"/>, otherwise the parameter <paramref name="number"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Clamped.Clamp(System.Single,System.Nullable{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:Emik.Morsels.Clamped.Clamp(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>
        </member>
        <member name="T:Emik.Morsels.Collected">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Collected.ToCollectionLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Upcasts or creates an <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to upcast or encapsulate.</param>
            <returns>Itself as <see cref="T:System.Collections.Generic.ICollection`1"/>, or a collected <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Collected.ToListLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Upcasts or creates an <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to upcast or encapsulate.</param>
            <returns>Itself as <see cref="T:System.Collections.Generic.IList`1"/>, or a collected <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Collected.Collect``2(System.Collections.Generic.IEnumerable{``0},System.Converter{System.Collections.Generic.IEnumerable{``0},``1})">
            <summary>Attempts to create a list from an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <typeparam name="T">The type of item in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TList">The destination type.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to convert.</param>
            <param name="converter">The <see cref="T:System.Collections.Generic.IList`1"/> to convert it to.</param>
            <returns>
            A <typeparamref name="TList"/> from <paramref name="converter"/>, as long as every element returned
            is not <paramref langword="null"/>, otherwise <paramref langword="default"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Conditionals">
            <summary>Extension methods for nullable types and booleans.</summary>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsAnd``1(``0,System.Predicate{``0})">
            <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="predicate">The predicate to determine the return value.</param>
            <returns>
            The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
            and returned <see langword="true"/> from the predicate, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsAnd``1(System.Nullable{``0},System.Predicate{``0})">
            <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="predicate">The predicate to determine the return value.</param>
            <returns>
            The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
            and returned <see langword="true"/> from the predicate, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsFalse(System.Boolean,System.String)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="that">The value that must be <see langword="false"/>.</param>
            <param name="exThat">Filled by the compiler, the expression to assert.</param>
            <returns>The parameter <paramref name="that"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsTrue(System.Boolean,System.String)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="that">The value that must be <see langword="true"/>.</param>
            <param name="exThat">Filled by the compiler, the expression to assert.</param>
            <returns>The parameter <paramref name="that"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.NotThen(System.Boolean,System.Action,System.Action)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="value">The value to check.</param>
            <param name="ifFalse">The value to invoke when <see langword="false"/>.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then(System.Boolean,System.Action,System.Action)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="value">The value to check.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <param name="ifFalse">The value to invoke when <see langword="false"/>.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Filter``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Filters an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to only non-null values.</summary>
            <typeparam name="T">The type of value to filter.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to filter.</param>
            <returns>A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> with strictly non-null values.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Filter``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>Filters an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to only non-null values.</summary>
            <typeparam name="T">The type of value to filter.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to filter.</param>
            <returns>A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> with strictly non-null values.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.NotThen``1(System.Boolean,``0)">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is eagerly evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="ifFalse">The value to return when <see langword="false"/>.</param>
            <returns>
            The value <paramref name="ifFalse"/> if <paramref name="value"/>
            is <see langword="false"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.NotThen``1(System.Boolean,System.Func{``0})">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is lazily evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="onFalse">The value to invoke when <see langword="false"/>.</param>
            <returns>
            The value returned from <paramref name="onFalse"/> if <paramref name="value"/>
            is <see langword="false"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then``1(System.Boolean,``0)">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is eagerly evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="onTrue">The value to return when <see langword="true"/>.</param>
            <returns>
            The value <paramref name="onTrue"/> if <paramref name="value"/>
            is <see langword="true"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then``1(System.Boolean,System.Func{``0})">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is lazily evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <returns>
            The value returned from <paramref name="ifTrue"/> if <paramref name="value"/>
            is <see langword="true"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Stringifier">
            <summary>Provides stringification methods.</summary>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.Char)">
            <summary>Joins a set of values into one long <see cref="T:System.String"/>.</summary>
            <remarks><para>
            This method is more efficient than using
            <see cref="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.String)"/> for <see cref="T:System.Char"/> separators.
            </para></remarks>
            <typeparam name="T">The type of each item in the collection.</typeparam>
            <param name="values">The values to join.</param>
            <param name="separator">The separator between each item.</param>
            <returns>One long <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Joins a set of values into one long <see cref="T:System.String"/>.</summary>
            <typeparam name="T">The type of each item in the collection.</typeparam>
            <param name="values">The values to join.</param>
            <param name="separator">The separator between each item.</param>
            <returns>One long <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Nth(System.Int32,System.Boolean)">
            <summary>Converts a number to an ordinal.</summary>
            <param name="i">The number to convert.</param>
            <param name="indexByZero">Determines whether to index from zero or one.</param>
            <returns>The parameter <paramref name="i"/> as an ordinal.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Stringify``1(``0)">
            <summary>
            Converts <paramref name="source"/> into a <see cref="T:System.String"/> representation of <paramref name="source"/>.
            </summary>
            <remarks><para>
            Unlike <see cref="M:System.Object.ToString"/>, the values of all properties are printed out,
            unless they explicitly define a <see cref="M:System.Object.ToString"/>, or inherit <see cref="T:System.Collections.IEnumerable"/>,
            in which case each item within is printed out separately.
            </para></remarks>
            <typeparam name="T">The type of the source.</typeparam>
            <param name="source">The item to get a <see cref="T:System.String"/> representation of.</param>
            <returns><paramref name="source"/> as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Stringify``1(``0,System.Boolean,System.Boolean)">
            <summary>
            Converts <paramref name="source"/> into a <see cref="T:System.String"/> representation of <paramref name="source"/>.
            </summary>
            <remarks><para>
            Unlike <see cref="M:System.Object.ToString"/>, the values of all properties are printed out,
            unless they explicitly define a <see cref="M:System.Object.ToString"/>, or inherit <see cref="T:System.Collections.IEnumerable"/>,
            in which case each item within is printed out separately.
            </para></remarks>
            <typeparam name="T">The type of the source.</typeparam>
            <param name="source">The item to get a <see cref="T:System.String"/> representation of.</param>
            <param name="isSurrounded">
            Determines whether <see cref="T:System.String"/> and <see cref="T:System.Char"/> have a " and ' surrounding them.
            </param>
            <param name="isRecursive">
            Determines whether it re-calls <see cref="M:Emik.Morsels.Stringifier.Stringify``1(``0,System.Boolean,System.Boolean)"/>
            on each property in <paramref name="source"/>.
            </param>
            <returns><paramref name="source"/> as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Yes`1">
            <summary>A factory for creating iterator types that yield the same item forever.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Yes`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.Yes`1"/> struct. Prepares enumeration of a single item forever.
            </summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Yes`1.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Yes`1.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.op_Implicit(`0)~Emik.Morsels.Yes{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.op_Implicit(Emik.Morsels.Yes{`0})~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Yes`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Yes`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.GetEnumerator">
            <summary>Returns itself.</summary>
            <remarks><para>Used to allow <see langword="foreach"/> to be used on <see cref="T:Emik.Morsels.Yes`1"/>.</para></remarks>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerator#Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerator#MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.YesFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Yes`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.YesFactory.Forever``1(``0)">
            <summary>Creates a <see cref="T:Emik.Morsels.Yes`1"/> from an item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The <see cref="T:Emik.Morsels.Yes`1"/> instance that can be yielded forever.</returns>
        </member>
        <member name="T:Emik.Morsels.MethodGroupings">
            <summary>Methods to create methods.</summary>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Invoke(System.Action)">
            <summary>Invokes a method.</summary>
            <param name="del">The method to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action(System.Action)">
            <summary>Create a delegate.</summary>
            <param name="del">The method group.</param>
            <returns>An invokable method.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action1``1(System.Action{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action2``2(System.Action{``0,``1})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action3``3(System.Action{``0,``1,``2})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action4``4(System.Action{``0,``1,``2,``3})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func``1(System.Func{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func1``2(System.Func{``0,``1})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func2``3(System.Func{``0,``1,``2})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func3``4(System.Func{``0,``1,``2,``3})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func4``5(System.Func{``0,``1,``2,``3,``4})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not1``1(System.Func{``0,System.Boolean})">
            <summary>Negates a predicate.</summary>
            <typeparam name="T">The type of item for the predicate.</typeparam>
            <param name="predicate">The predicate to negate.</param>
            <returns>The argument <paramref name="predicate"/> wrapped in another that negates its result.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not2``1(System.Func{``0,System.Int32,System.Boolean})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Invoke``1(System.Func{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Invoke(System.Action)"/>
        </member>
        <member name="T:Emik.Morsels.Once`1">
            <summary>A factory for creating iterator types that yields an item once.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Once`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.Once`1"/> struct. Prepares enumeration of a single item forever.
            </summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.Current">
            <summary>Gets the item to use.</summary>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IReadOnlyList{T}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.Once`1.op_Implicit(`0)~Emik.Morsels.Once{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.op_Implicit(Emik.Morsels.Once{`0})~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Once`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Once`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.Once`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.GetEnumerator">
            <summary>
            Returns itself. Used to tell the compiler that it can be used in a <see langword="foreach"/> loop.
            </summary>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Once`1.Enumerator">
            <summary>An enumerator over <see cref="T:Emik.Morsels.Once`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.Once`1.Enumerator"/> struct.
            Prepares enumeration of a single item forever.
            </summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Once`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Once`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.op_Implicit(`0)~Emik.Morsels.Once{`0}.Enumerator">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.op_Implicit(Emik.Morsels.Once{`0}.Enumerator)~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Once`1.Enumerator.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Once`1.Enumerator.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.OnceFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Once`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.OnceFactory.Yield``1(``0)">
            <summary>Creates a <see cref="T:Emik.Morsels.Once`1"/> from an item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The <see cref="T:Emik.Morsels.Once`1"/> instance that can be yielded once.</returns>
        </member>
        <member name="T:Emik.Morsels.Split`1">
            <summary>Represents a fixed collection of 2 items.</summary>
            <typeparam name="T">The type of item in the collection.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Split`1.#ctor(`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Split`1"/> class.</summary>
            <param name="value">The value representing both values.</param>
        </member>
        <member name="M:Emik.Morsels.Split`1.#ctor(`0,`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Split`1"/> class.</summary>
            <param name="truthy">The value representing a <see langword="true"/> value.</param>
            <param name="falsy">The value representing a <see langword="false"/> value.</param>
        </member>
        <member name="P:Emik.Morsels.Split`1.Falsy">
            <summary>Gets or sets the value representing a <see langword="false"/> value.</summary>
        </member>
        <member name="P:Emik.Morsels.Split`1.Truthy">
            <summary>Gets or sets the value representing a <see langword="true"/> value.</summary>
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="M:Emik.Morsels.Split`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Clear" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.Values">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#Keys">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.Item(System.Boolean)">
            <inheritdoc cref="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.Add(System.Boolean,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Add(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.CopyTo(System.Collections.Generic.KeyValuePair{System.Boolean,`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Contains(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.TryGetValue(System.Boolean,`0@)">
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Clear">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Clear" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Remove(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#Remove(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#ContainsKey(System.Boolean)">
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyCollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#Keys">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#Values">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#ContainsKey(System.Boolean)">
            <inheritdoc cref="M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.Deconstruct(`0@,`0@)">
            <summary>Deconstructs a <see cref="T:Emik.Morsels.Split`1"/> into its components.</summary>
            <param name="truthy">The value to get assigned as <see cref="P:Emik.Morsels.Split`1.Truthy"/>.</param>
            <param name="falsy">The value to get assigned as <see cref="P:Emik.Morsels.Split`1.Falsy"/>.</param>
        </member>
        <member name="M:Emik.Morsels.Split`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.SplitFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Split`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.SplitFactory.SplitBy``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Splits an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in two based on a method provided.</summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <param name="source">The collection to split.</param>
            <param name="predicate">The method that decides where the item ends up.</param>
            <returns>
            A <see cref="T:Emik.Morsels.Split`1"/> instance that contains 2 lists containing the elements that returned
            <see langword="true"/> and <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Unforgiving">
            <summary>Provides a reference for an <see cref="T:System.Diagnostics.UnreachableException"/>.</summary>
        </member>
        <member name="P:Emik.Morsels.Unforgiving.CannotBeEmpty">
            <summary>Gets the <see cref="T:System.Exception"/> that a collection cannot be empty.</summary>
        </member>
        <member name="P:Emik.Morsels.Unforgiving.Unreachable">
            <summary>Gets the <see cref="T:System.Exception"/> that represents an unreachable state.</summary>
        </member>
        <member name="T:Emik.Morsels.NullableItems">
            <summary>Extension methods for improving nullability awareness for enumerables.</summary>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="iterable">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="iterable"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="iterator">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="iterator"/>, with <see cref="T:JetBrains.Annotations.ItemCanBeNullAttribute"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemNotNull``1(System.Collections.Generic.IList{``0})">
            <summary>Returns the list if all items are non-null.</summary>
            <typeparam name="T">The type of list.</typeparam>
            <param name="list">The list to filter.</param>
            <returns>
            The parameter <paramref name="list"/> if all items are non-<see langword="null"/>,
            otherwise <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="collection">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="collection"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="list">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="list"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlySet{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="set">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="set"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="T:Emik.Morsels.NegatedEnumerable">
            <summary>Extension methods that negate functions from <see cref="T:System.Linq.Enumerable"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.TakeUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.TakeUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.ToEnumerable(System.Collections.IEnumerator)">
            <summary>
            Negated <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>.
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <param name="iterator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> to encapsulate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating the parameter <paramref name="iterator"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.ToEnumerable``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Negated <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>.
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> to encapsulate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating the parameter <paramref name="iterator"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.WhereNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.WhereNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="T:Emik.Morsels.PowerSetFactories">
            <summary>Extension methods to create power sets.</summary>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet(System.Collections.ICollection)">
            <inheritdoc cref="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})">
            <summary>Creates a power set from a collection.</summary>
            <remarks><para>
            The power set is defined as the set of all subsets, including the empty set and the set itself.
            </para></remarks>
            <typeparam name="T">The type of item in the set.</typeparam>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The argument <paramref name="collection"/> has 32 or more elements.
            </exception>
            <param name="collection">The set to create a power set.</param>
            <returns>The power set of the parameter <paramref name="collection"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <inheritdoc cref="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="T:Emik.Morsels.ClippedList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where indices are always clamped and therefore never be out of range.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.ClippedList`1"/> class.</summary>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:Emik.Morsels.ClippedList`1.Count"/> returns a non-positive number.</exception>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.ClippedFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.ClippedList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.ClippedFactory.ToClippedLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.ClippedList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.ClippedList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.ClippedList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.GuardedList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where applying an index will always result in an optional value;
            an out of range value will always give the <see langword="default"/> value.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.GuardedList`1"/> class.</summary>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.GuardedFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.GuardedList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.GuardedFactory.ToGuardedLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.GuardedList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.GuardedList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.GuardedList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.CircularList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where elements are treated as circular;
            indices wrap around and will therefore never be out of range.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.CircularList`1"/> class.</summary>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:Emik.Morsels.CircularList`1.Count"/> returns a non-positive number.</exception>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.CircularFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.CircularList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.CircularFactory.ToCircularLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.CircularList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.CircularList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.CircularList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.RandomizedGetters">
            <summary>Extension methods for randomized getters.</summary>
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>Shuffles a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <param name="selector">The indices to swap with, when left unspecified, uses <see cref="M:Emik.Morsels.RandomizedGetters.Rand"/>.</param>
            <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.PickRandom``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>Shuffles a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <param name="selector">The indices to swap with, when left unspecified, uses <see cref="M:Emik.Morsels.RandomizedGetters.Rand"/>.</param>
            <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.ReadOnlyList`1">
            <summary>Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> and make all mutating methods a no-op.</summary>
            <typeparam name="T">The type of element in the list.</typeparam>
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.ReadOnlyList`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)" />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.ReadOnlyFactory">
            <summary>Extension methods that act as factories for <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.ReadOnlyFactory.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.</param>
            <returns>A <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Unions.Disjoints.Either">
            <summary>A static class that provides methods for creating new instances of disjoint union types.</summary>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either.New``2(``0)">
            <summary>
            Creates a <see cref="T:Emik.Unions.Disjoints.IEither`2"/> with the inner value <typeparamref name="T1"/>.
            </summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <param name="first">
            The parameter to pass in the type <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </param>
            <returns><see cref="T:Emik.Unions.Disjoints.IEither`2"/> with <paramref name="first"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either.New``2(``1)">
            <summary>
            Creates a <see cref="T:Emik.Unions.Disjoints.IEither`2"/> with the inner value <typeparamref name="T2"/>.
            </summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <param name="second">
            The parameter to pass in the type <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </param>
            <returns><see cref="T:Emik.Unions.Disjoints.IEither`2"/> with <paramref name="second"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either.New``3(``0)">
            <summary>
            Creates a <see cref="T:Emik.Unions.Disjoints.IEither`3"/> with the inner value <typeparamref name="T1"/>.
            </summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="first">
            The parameter to pass in the type <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </param>
            <returns><see cref="T:Emik.Unions.Disjoints.IEither`3"/> with <paramref name="first"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either.New``3(``1)">
            <summary>
            Creates a <see cref="T:Emik.Unions.Disjoints.IEither`3"/> with the inner value <typeparamref name="T2"/>.
            </summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="second">
            The parameter to pass in the type <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </param>
            <returns><see cref="T:Emik.Unions.Disjoints.IEither`3"/> with <paramref name="second"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either.New``3(``2)">
            <summary>
            Creates a <see cref="T:Emik.Unions.Disjoints.IEither`3"/> with the inner value <typeparamref name="T3"/>.
            </summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="third">
            The parameter to pass in the type <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </param>
            <returns><see cref="T:Emik.Unions.Disjoints.IEither`3"/> with <paramref name="third"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either.New``4(``0)">
            <summary>
            Creates a <see cref="T:Emik.Unions.Disjoints.IEither`4"/> with the inner value <typeparamref name="T1"/>.
            </summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="first">
            The parameter to pass in the type <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </param>
            <returns><see cref="T:Emik.Unions.Disjoints.IEither`4"/> with <paramref name="first"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either.New``4(``1)">
            <summary>
            Creates a <see cref="T:Emik.Unions.Disjoints.IEither`4"/> with the inner value <typeparamref name="T2"/>.
            </summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="second">
            The parameter to pass in the type <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </param>
            <returns><see cref="T:Emik.Unions.Disjoints.IEither`4"/> with <paramref name="second"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either.New``4(``2)">
            <summary>
            Creates a <see cref="T:Emik.Unions.Disjoints.IEither`4"/> with the inner value <typeparamref name="T3"/>.
            </summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="third">
            The parameter to pass in the type <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </param>
            <returns><see cref="T:Emik.Unions.Disjoints.IEither`4"/> with <paramref name="third"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either.New``4(``3)">
            <summary>
            Creates a <see cref="T:Emik.Unions.Disjoints.IEither`4"/> with the inner value <typeparamref name="T4"/>.
            </summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="fourth">
            The parameter to pass in the type <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </param>
            <returns><see cref="T:Emik.Unions.Disjoints.IEither`4"/> with <paramref name="fourth"/>.</returns>
        </member>
        <member name="T:Emik.Unions.Disjoints.Either`3">
            <summary>Defines an inheritable record that automates logic for a disjoint union.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="TType">The type of the inheriting record.</typeparam>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`3.Emik#Unions#Disjoints#IEither{T1,T2}#First">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`3.New(`0)">
            <summary>
            Creates a new instance of <typeparamref name="TType"/> with
            the <typeparamref name="T2"/> value being set.
            </summary>
            <param name="first">The value of the disjoint union.</param>
            <returns>
            A new instance of <typeparamref name="TType"/> which contains <paramref name="first"/>.
            </returns>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`3.Emik#Unions#Disjoints#IEither{T1,T2}#Second">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`3.New(`1)">
            <summary>
            Creates a new instance of <typeparamref name="TType"/> with
            the <typeparamref name="T2"/> value being set.
            </summary>
            <param name="second">The value of the disjoint union.</param>
            <returns>
            A new instance of <typeparamref name="TType"/> which contains <paramref name="second"/>.
            </returns>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`3.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`3.Emik#Unions#Disjoints#IEither#Index">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`3.Emik#Unions#Disjoints#IEither#Value">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`3.Emik#Unions#IProperties#Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`3.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Disjoints.Either`4">
            <summary>Defines an inheritable record that automates logic for a disjoint union.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
            <typeparam name="TType">The type of the inheriting record.</typeparam>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`4.Emik#Unions#Disjoints#IEither{T1,T2,T3}#First">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`4.New(`0)">
            <summary>
            Creates a new instance of <typeparamref name="TType"/> with
            the <typeparamref name="T3"/> value being set.
            </summary>
            <param name="first">The value of the disjoint union.</param>
            <returns>
            A new instance of <typeparamref name="TType"/> which contains <paramref name="first"/>.
            </returns>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`4.Emik#Unions#Disjoints#IEither{T1,T2,T3}#Second">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`4.New(`1)">
            <summary>
            Creates a new instance of <typeparamref name="TType"/> with
            the <typeparamref name="T3"/> value being set.
            </summary>
            <param name="second">The value of the disjoint union.</param>
            <returns>
            A new instance of <typeparamref name="TType"/> which contains <paramref name="second"/>.
            </returns>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`4.Emik#Unions#Disjoints#IEither{T1,T2,T3}#Third">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`4.New(`2)">
            <summary>
            Creates a new instance of <typeparamref name="TType"/> with
            the <typeparamref name="T3"/> value being set.
            </summary>
            <param name="third">The value of the disjoint union.</param>
            <returns>
            A new instance of <typeparamref name="TType"/> which contains <paramref name="third"/>.
            </returns>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`4.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`4.Emik#Unions#Disjoints#IEither#Index">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`4.Emik#Unions#Disjoints#IEither#Value">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`4.Emik#Unions#IProperties#Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`4.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Disjoints.Either`5">
            <summary>Defines an inheritable record that automates logic for a disjoint union.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
            <typeparam name="T4">The fourth type of the disjoint union.</typeparam>
            <typeparam name="TType">The type of the inheriting record.</typeparam>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`5.Emik#Unions#Disjoints#IEither{T1,T2,T3,T4}#First">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`5.New(`0)">
            <summary>
            Creates a new instance of <typeparamref name="TType"/> with
            the <typeparamref name="T4"/> value being set.
            </summary>
            <param name="first">The value of the disjoint union.</param>
            <returns>
            A new instance of <typeparamref name="TType"/> which contains <paramref name="first"/>.
            </returns>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`5.Emik#Unions#Disjoints#IEither{T1,T2,T3,T4}#Second">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`5.New(`1)">
            <summary>
            Creates a new instance of <typeparamref name="TType"/> with
            the <typeparamref name="T4"/> value being set.
            </summary>
            <param name="second">The value of the disjoint union.</param>
            <returns>
            A new instance of <typeparamref name="TType"/> which contains <paramref name="second"/>.
            </returns>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`5.Emik#Unions#Disjoints#IEither{T1,T2,T3,T4}#Third">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`5.New(`2)">
            <summary>
            Creates a new instance of <typeparamref name="TType"/> with
            the <typeparamref name="T4"/> value being set.
            </summary>
            <param name="third">The value of the disjoint union.</param>
            <returns>
            A new instance of <typeparamref name="TType"/> which contains <paramref name="third"/>.
            </returns>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`5.Emik#Unions#Disjoints#IEither{T1,T2,T3,T4}#Fourth">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`5.New(`3)">
            <summary>
            Creates a new instance of <typeparamref name="TType"/> with
            the <typeparamref name="T4"/> value being set.
            </summary>
            <param name="fourth">The value of the disjoint union.</param>
            <returns>
            A new instance of <typeparamref name="TType"/> which contains <paramref name="fourth"/>.
            </returns>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`5.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`5.Emik#Unions#Disjoints#IEither#Index">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`5.Emik#Unions#Disjoints#IEither#Value">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.Either`5.Emik#Unions#IProperties#Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.Either`5.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Disjoints.EitherExtensions">
            <summary>A static class that provides functionality for disjoint union types.</summary>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``2(Emik.Unions.Disjoints.IEither{``0,``1},``0@,``1@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1">The truthy value.</param>
            <param name="n2">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``2(Emik.Unions.Disjoints.IEither{``0,``1},``1@,``0@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2">The truthy value.</param>
            <param name="n1">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``2(Emik.Unions.Disjoints.IEither{``0,``1},``0@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``2(Emik.Unions.Disjoints.IEither{``0,``1},``1@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``2(Emik.Unions.Disjoints.IEither{``0,``1},System.Action{``0},System.Action{``1})">
            <summary>Runs the callback based on the value of the disjoint union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="on1">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`2.First"/>.
            </param>
            <param name="on2">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`2.Second"/>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1},System.Converter{``0,``2},System.Converter{``1,``2})">
            <summary>Runs the callback based on the value of the disjoint union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <typeparam name="TResult">The type for the <see langword="return"/> type of the callbacks.</typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="on1">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`2.First"/>.
            </param>
            <param name="on2">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`2.Second"/>.
            </param>
            <returns>
            The value returned from the callback that corresponded to the
            <see cref="P:Emik.Unions.Disjoints.IEither.Value"/> of <paramref name="that"/>.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Index``2(Emik.Unions.Disjoints.IEither{``0,``1},System.Int32)">
            <summary>Performs an index operation on the disjoint union.</summary>
            <typeparam name="T1">The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.</typeparam>
            <typeparam name="T2">The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.</typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="index">The index to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the index of the disjoint union.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The value <paramref name="index"/> is out of range.</exception>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.InnerType``2(Emik.Unions.Disjoints.IEither{``0,``1})">
            <summary>Gets the <see cref="T:System.Type"/> of <see cref="P:Emik.Unions.Disjoints.IEither.Value"/>.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`2"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <returns>The <see cref="T:System.Type"/> of the <see cref="P:Emik.Unions.Disjoints.IEither.Value"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},``0@,Emik.Unions.Disjoints.IEither{``1,``2}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1">The truthy value.</param>
            <param name="n2n3">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},``1@,Emik.Unions.Disjoints.IEither{``0,``2}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2">The truthy value.</param>
            <param name="n1n3">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},Emik.Unions.Disjoints.IEither{``0,``1}@,``2@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n2">The truthy value.</param>
            <param name="n3">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},``2@,Emik.Unions.Disjoints.IEither{``0,``1}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n3">The truthy value.</param>
            <param name="n1n2">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},Emik.Unions.Disjoints.IEither{``0,``2}@,``1@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n3">The truthy value.</param>
            <param name="n2">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},Emik.Unions.Disjoints.IEither{``1,``2}@,``0@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2n3">The truthy value.</param>
            <param name="n1">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},``0@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},``1@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},Emik.Unions.Disjoints.IEither{``0,``1}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n2">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},``2@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n3">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},Emik.Unions.Disjoints.IEither{``0,``2}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n3">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},Emik.Unions.Disjoints.IEither{``1,``2}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2n3">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},System.Action{``0},System.Action{``1},System.Action{``2})">
            <summary>Runs the callback based on the value of the disjoint union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="on1">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`3.First"/>.
            </param>
            <param name="on2">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`3.Second"/>.
            </param>
            <param name="on3">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`3.Third"/>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2},System.Converter{``0,``3},System.Converter{``1,``3},System.Converter{``2,``3})">
            <summary>Runs the callback based on the value of the disjoint union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="TResult">The type for the <see langword="return"/> type of the callbacks.</typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="on1">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`3.First"/>.
            </param>
            <param name="on2">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`3.Second"/>.
            </param>
            <param name="on3">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`3.Third"/>.
            </param>
            <returns>
            The value returned from the callback that corresponded to the
            <see cref="P:Emik.Unions.Disjoints.IEither.Value"/> of <paramref name="that"/>.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Index``3(Emik.Unions.Disjoints.IEither{``0,``1,``2},System.Int32)">
            <summary>Performs an index operation on the disjoint union.</summary>
            <typeparam name="T1">The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.</typeparam>
            <typeparam name="T2">The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.</typeparam>
            <typeparam name="T3">The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.</typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="index">The index to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the index of the disjoint union.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The value <paramref name="index"/> is out of range.</exception>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.InnerType``3(Emik.Unions.Disjoints.IEither{``0,``1,``2})">
            <summary>Gets the <see cref="T:System.Type"/> of <see cref="P:Emik.Unions.Disjoints.IEither.Value"/>.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`3"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <returns>The <see cref="T:System.Type"/> of the <see cref="P:Emik.Unions.Disjoints.IEither.Value"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},``0@,Emik.Unions.Disjoints.IEither{``1,``2,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1">The truthy value.</param>
            <param name="n2n3n4">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},``1@,Emik.Unions.Disjoints.IEither{``0,``2,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2">The truthy value.</param>
            <param name="n1n3n4">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``1}@,Emik.Unions.Disjoints.IEither{``2,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n2">The truthy value.</param>
            <param name="n3n4">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},``2@,Emik.Unions.Disjoints.IEither{``0,``1,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n3">The truthy value.</param>
            <param name="n1n2n4">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``2}@,Emik.Unions.Disjoints.IEither{``1,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n3">The truthy value.</param>
            <param name="n2n4">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``1,``2}@,Emik.Unions.Disjoints.IEither{``0,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2n3">The truthy value.</param>
            <param name="n1n4">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``1,``2}@,``3@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n2n3">The truthy value.</param>
            <param name="n4">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},``3@,Emik.Unions.Disjoints.IEither{``0,``1,``2}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n4">The truthy value.</param>
            <param name="n1n2n3">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``3}@,Emik.Unions.Disjoints.IEither{``1,``2}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n4">The truthy value.</param>
            <param name="n2n3">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``1,``3}@,Emik.Unions.Disjoints.IEither{``0,``2}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2n4">The truthy value.</param>
            <param name="n1n3">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``1,``3}@,``2@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n2n4">The truthy value.</param>
            <param name="n3">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``2,``3}@,Emik.Unions.Disjoints.IEither{``0,``1}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n3n4">The truthy value.</param>
            <param name="n1n2">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``2,``3}@,``1@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n3n4">The truthy value.</param>
            <param name="n2">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``1,``2,``3}@,``0@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2n3n4">The truthy value.</param>
            <param name="n1">The falsy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},``0@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},``1@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``1}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n2">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},``2@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n3">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``2}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n3">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``1,``2}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2n3">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``1,``2}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n2n3">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},``3@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n4">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n4">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``1,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2n4">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``1,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n2n4">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``2,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n3n4">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``0,``2,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n1n3n4">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},Emik.Unions.Disjoints.IEither{``1,``2,``3}@)">
            <summary>Determines whether the disjoint union is the type provided.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="n2n3n4">The truthy value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>
            The value <see langword="true"/> if <paramref name="that"/> matches the pattern,
            otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},System.Action{``0},System.Action{``1},System.Action{``2},System.Action{``3})">
            <summary>Runs the callback based on the value of the disjoint union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="on1">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`4.First"/>.
            </param>
            <param name="on2">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`4.Second"/>.
            </param>
            <param name="on3">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`4.Third"/>.
            </param>
            <param name="on4">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`4.Fourth"/>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Is``5(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},System.Converter{``0,``4},System.Converter{``1,``4},System.Converter{``2,``4},System.Converter{``3,``4})">
            <summary>Runs the callback based on the value of the disjoint union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="TResult">The type for the <see langword="return"/> type of the callbacks.</typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="on1">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`4.First"/>.
            </param>
            <param name="on2">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`4.Second"/>.
            </param>
            <param name="on3">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`4.Third"/>.
            </param>
            <param name="on4">
            The callback for <paramref name="that"/> having <see cref="P:Emik.Unions.Disjoints.IEither`4.Fourth"/>.
            </param>
            <returns>
            The value returned from the callback that corresponded to the
            <see cref="P:Emik.Unions.Disjoints.IEither.Value"/> of <paramref name="that"/>.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.Index``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3},System.Int32)">
            <summary>Performs an index operation on the disjoint union.</summary>
            <typeparam name="T1">The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.</typeparam>
            <typeparam name="T2">The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.</typeparam>
            <typeparam name="T3">The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.</typeparam>
            <typeparam name="T4">The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.</typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <param name="index">The index to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the index of the disjoint union.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The value <paramref name="index"/> is out of range.</exception>
        </member>
        <member name="M:Emik.Unions.Disjoints.EitherExtensions.InnerType``4(Emik.Unions.Disjoints.IEither{``0,``1,``2,``3})">
            <summary>Gets the <see cref="T:System.Type"/> of <see cref="P:Emik.Unions.Disjoints.IEither.Value"/>.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Disjoints.IEither`4"/>.
            </typeparam>
            <param name="that">The instance of the disjoint union.</param>
            <returns>The <see cref="T:System.Type"/> of the <see cref="P:Emik.Unions.Disjoints.IEither.Value"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value <paramref name="that"/> has an invalid <see cref="P:Emik.Unions.Disjoints.IEither.Index"/>.
            </exception>
        </member>
        <member name="T:Emik.Unions.Disjoints.IEither">
            <summary>An interface for everything that disjoint union types share in common with.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither.Index">
            <summary>Gets the index where the value is contained.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither.Value">
            <summary>Gets the value.</summary>
        </member>
        <member name="T:Emik.Unions.Disjoints.IEither`2">
            <summary>Defines an interface for disjoint union of size 2.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`2.First">
            <summary>Gets the <typeparamref name="T1"/> first value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`2.Second">
            <summary>Gets the <typeparamref name="T2"/> second value of the disjoint union.</summary>
        </member>
        <member name="T:Emik.Unions.Disjoints.IEither`3">
            <summary>Defines an interface for disjoint union of size 3.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`3.First">
            <summary>Gets the <typeparamref name="T1"/> first value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`3.Second">
            <summary>Gets the <typeparamref name="T2"/> second value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`3.Third">
            <summary>Gets the <typeparamref name="T3"/> third value of the disjoint union.</summary>
        </member>
        <member name="T:Emik.Unions.Disjoints.IEither`4">
            <summary>Defines an interface for disjoint union of size 4.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
            <typeparam name="T4">The fourth type of the disjoint union.</typeparam>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`4.First">
            <summary>Gets the <typeparamref name="T1"/> first value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`4.Second">
            <summary>Gets the <typeparamref name="T2"/> second value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`4.Third">
            <summary>Gets the <typeparamref name="T3"/> third value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`4.Fourth">
            <summary>Gets the <typeparamref name="T4"/> fourth value of the disjoint union.</summary>
        </member>
        <member name="T:Emik.Unions.Disjoints.IEither`5">
            <summary>Defines an interface for disjoint union of size 5.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
            <typeparam name="T4">The fourth type of the disjoint union.</typeparam>
            <typeparam name="T5">The fifth type of the disjoint union.</typeparam>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`5.First">
            <summary>Gets the <typeparamref name="T1"/> first value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`5.Second">
            <summary>Gets the <typeparamref name="T2"/> second value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`5.Third">
            <summary>Gets the <typeparamref name="T3"/> third value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`5.Fourth">
            <summary>Gets the <typeparamref name="T4"/> fourth value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.IEither`5.Fifth">
            <summary>Gets the <typeparamref name="T5"/> fifth value of the disjoint union.</summary>
        </member>
        <member name="T:Emik.Unions.Disjoints.InnerEither`2">
            <summary>
            Defines an internal disjoint union for storing 1 of 2 different values.
            Instances of this type are exposed to the consumer as an interface.
            </summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`2.#ctor(`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Disjoints.InnerEither`2"/> class.</summary>
            <param name="first">
            The <typeparamref name="T1"/> value to assign to the disjoint union.
            </param>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`2.First">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`2.#ctor(`1)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Disjoints.InnerEither`2"/> class.</summary>
            <param name="second">
            The <typeparamref name="T2"/> value to assign to the disjoint union.
            </param>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`2.Second">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`2.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`2.Index">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`2.Value">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`2.Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`2.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Disjoints.InnerEither`3">
            <summary>
            Defines an internal disjoint union for storing 1 of 3 different values.
            Instances of this type are exposed to the consumer as an interface.
            </summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`3.#ctor(`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Disjoints.InnerEither`3"/> class.</summary>
            <param name="first">
            The <typeparamref name="T1"/> value to assign to the disjoint union.
            </param>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`3.First">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`3.#ctor(`1)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Disjoints.InnerEither`3"/> class.</summary>
            <param name="second">
            The <typeparamref name="T2"/> value to assign to the disjoint union.
            </param>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`3.Second">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`3.#ctor(`2)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Disjoints.InnerEither`3"/> class.</summary>
            <param name="third">
            The <typeparamref name="T3"/> value to assign to the disjoint union.
            </param>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`3.Third">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`3.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`3.Index">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`3.Value">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`3.Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`3.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Disjoints.InnerEither`4">
            <summary>
            Defines an internal disjoint union for storing 1 of 4 different values.
            Instances of this type are exposed to the consumer as an interface.
            </summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
            <typeparam name="T4">The fourth type of the disjoint union.</typeparam>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`4.#ctor(`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Disjoints.InnerEither`4"/> class.</summary>
            <param name="first">
            The <typeparamref name="T1"/> value to assign to the disjoint union.
            </param>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`4.First">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`4.#ctor(`1)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Disjoints.InnerEither`4"/> class.</summary>
            <param name="second">
            The <typeparamref name="T2"/> value to assign to the disjoint union.
            </param>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`4.Second">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`4.#ctor(`2)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Disjoints.InnerEither`4"/> class.</summary>
            <param name="third">
            The <typeparamref name="T3"/> value to assign to the disjoint union.
            </param>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`4.Third">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`4.#ctor(`3)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Disjoints.InnerEither`4"/> class.</summary>
            <param name="fourth">
            The <typeparamref name="T4"/> value to assign to the disjoint union.
            </param>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`4.Fourth">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`4.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`4.Index">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`4.Value">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Disjoints.InnerEither`4.Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Disjoints.InnerEither`4.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Disjoints.Overload`2">
            <summary>Defines a disjoint union with implicit conversions, for parameter signatures.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <param name="First">The first value of the disjoint union.</param>
            <param name="Second">The second value of the disjoint union.</param>
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`2.#ctor(`0,`1)">
            <summary>Defines a disjoint union with implicit conversions, for parameter signatures.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <param name="First">The first value of the disjoint union.</param>
            <param name="Second">The second value of the disjoint union.</param>
        </member>
        <member name="P:Emik.Unions.Disjoints.Overload`2.First">
            <summary>The first value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.Overload`2.Second">
            <summary>The second value of the disjoint union.</summary>
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`2.op_Implicit(`0)~Emik.Unions.Disjoints.Overload{`0,`1}">
            <inheritdoc cref="M:Emik.Unions.Disjoints.Either`3.New(`0)" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`2.op_Explicit(Emik.Unions.Disjoints.Overload{`0,`1})~`0">
            <inheritdoc cref="P:Emik.Unions.Disjoints.IEither`2.First" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`2.op_Implicit(`1)~Emik.Unions.Disjoints.Overload{`0,`1}">
            <inheritdoc cref="M:Emik.Unions.Disjoints.Either`3.New(`1)" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`2.op_Explicit(Emik.Unions.Disjoints.Overload{`0,`1})~`1">
            <inheritdoc cref="P:Emik.Unions.Disjoints.IEither`2.Second" />
        </member>
        <member name="T:Emik.Unions.Disjoints.Overload`3">
            <summary>Defines a disjoint union with implicit conversions, for parameter signatures.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
            <param name="First">The first value of the disjoint union.</param>
            <param name="Second">The second value of the disjoint union.</param>
            <param name="Third">The third value of the disjoint union.</param>
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`3.#ctor(`0,`1,`2)">
            <summary>Defines a disjoint union with implicit conversions, for parameter signatures.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
            <param name="First">The first value of the disjoint union.</param>
            <param name="Second">The second value of the disjoint union.</param>
            <param name="Third">The third value of the disjoint union.</param>
        </member>
        <member name="P:Emik.Unions.Disjoints.Overload`3.First">
            <summary>The first value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.Overload`3.Second">
            <summary>The second value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.Overload`3.Third">
            <summary>The third value of the disjoint union.</summary>
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`3.op_Implicit(`0)~Emik.Unions.Disjoints.Overload{`0,`1,`2}">
            <inheritdoc cref="M:Emik.Unions.Disjoints.Either`4.New(`0)" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`3.op_Explicit(Emik.Unions.Disjoints.Overload{`0,`1,`2})~`0">
            <inheritdoc cref="P:Emik.Unions.Disjoints.IEither`3.First" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`3.op_Implicit(`1)~Emik.Unions.Disjoints.Overload{`0,`1,`2}">
            <inheritdoc cref="M:Emik.Unions.Disjoints.Either`4.New(`1)" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`3.op_Explicit(Emik.Unions.Disjoints.Overload{`0,`1,`2})~`1">
            <inheritdoc cref="P:Emik.Unions.Disjoints.IEither`3.Second" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`3.op_Implicit(`2)~Emik.Unions.Disjoints.Overload{`0,`1,`2}">
            <inheritdoc cref="M:Emik.Unions.Disjoints.Either`4.New(`2)" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`3.op_Explicit(Emik.Unions.Disjoints.Overload{`0,`1,`2})~`2">
            <inheritdoc cref="P:Emik.Unions.Disjoints.IEither`3.Third" />
        </member>
        <member name="T:Emik.Unions.Disjoints.Overload`4">
            <summary>Defines a disjoint union with implicit conversions, for parameter signatures.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
            <typeparam name="T4">The fourth type of the disjoint union.</typeparam>
            <param name="First">The first value of the disjoint union.</param>
            <param name="Second">The second value of the disjoint union.</param>
            <param name="Third">The third value of the disjoint union.</param>
            <param name="Fourth">The fourth value of the disjoint union.</param>
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`4.#ctor(`0,`1,`2,`3)">
            <summary>Defines a disjoint union with implicit conversions, for parameter signatures.</summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
            <typeparam name="T4">The fourth type of the disjoint union.</typeparam>
            <param name="First">The first value of the disjoint union.</param>
            <param name="Second">The second value of the disjoint union.</param>
            <param name="Third">The third value of the disjoint union.</param>
            <param name="Fourth">The fourth value of the disjoint union.</param>
        </member>
        <member name="P:Emik.Unions.Disjoints.Overload`4.First">
            <summary>The first value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.Overload`4.Second">
            <summary>The second value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.Overload`4.Third">
            <summary>The third value of the disjoint union.</summary>
        </member>
        <member name="P:Emik.Unions.Disjoints.Overload`4.Fourth">
            <summary>The fourth value of the disjoint union.</summary>
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`4.op_Implicit(`0)~Emik.Unions.Disjoints.Overload{`0,`1,`2,`3}">
            <inheritdoc cref="M:Emik.Unions.Disjoints.Either`5.New(`0)" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`4.op_Explicit(Emik.Unions.Disjoints.Overload{`0,`1,`2,`3})~`0">
            <inheritdoc cref="P:Emik.Unions.Disjoints.IEither`4.First" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`4.op_Implicit(`1)~Emik.Unions.Disjoints.Overload{`0,`1,`2,`3}">
            <inheritdoc cref="M:Emik.Unions.Disjoints.Either`5.New(`1)" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`4.op_Explicit(Emik.Unions.Disjoints.Overload{`0,`1,`2,`3})~`1">
            <inheritdoc cref="P:Emik.Unions.Disjoints.IEither`4.Second" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`4.op_Implicit(`2)~Emik.Unions.Disjoints.Overload{`0,`1,`2,`3}">
            <inheritdoc cref="M:Emik.Unions.Disjoints.Either`5.New(`2)" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`4.op_Explicit(Emik.Unions.Disjoints.Overload{`0,`1,`2,`3})~`2">
            <inheritdoc cref="P:Emik.Unions.Disjoints.IEither`4.Third" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`4.op_Implicit(`3)~Emik.Unions.Disjoints.Overload{`0,`1,`2,`3}">
            <inheritdoc cref="M:Emik.Unions.Disjoints.Either`5.New(`3)" />
        </member>
        <member name="M:Emik.Unions.Disjoints.Overload`4.op_Explicit(Emik.Unions.Disjoints.Overload{`0,`1,`2,`3})~`3">
            <inheritdoc cref="P:Emik.Unions.Disjoints.IEither`4.Fourth" />
        </member>
        <member name="T:Emik.Unions.Mappings.Chains">
            <summary>Allows the start of method chaining for functors.</summary>
        </member>
        <member name="M:Emik.Unions.Mappings.Chains.Chain``1(``0)">
            <summary>Starts a method chaining pattern of functors.</summary>
            <typeparam name="T">The type to encapsulate.</typeparam>
            <param name="item">The item to encapsulate.</param>
            <returns>A <see cref="T:Emik.Unions.Mappings.Self`1"/> which encapsulates the parameter <paramref name="item"/>.</returns>
        </member>
        <member name="T:Emik.Unions.Mappings.Functor`1">
            <summary>Defines a functor of unspecified types.</summary>
            <typeparam name="TType">The type of the inheriting record.</typeparam>
        </member>
        <member name="M:Emik.Unions.Mappings.Functor`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Unions.Mappings.Functor`1"/> class by updating <see cref="P:Emik.Unions.Mappings.Functor`1.Instance"/>.
            </summary>
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`1.New">
            <summary>
            Gets or sets the method used to create an instance of <typeparamref name="TType"/> without parameters.
            This is meant to be set in a static constructor to intercept the creation of <see cref="P:Emik.Unions.Mappings.Functor`1.Instance"/>.
            </summary>
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`1.Instance">
            <summary>Gets the shared instance.</summary>
        </member>
        <member name="T:Emik.Unions.Mappings.Functor`3">
            <summary>Defines a type that acts as a functor and <c>newtype</c> idiom from Rust simultaneously.</summary>
            <typeparam name="T">The type that can be converted into this type.</typeparam>
            <typeparam name="TResult">The resulting type that encapsulates this type.</typeparam>
            <typeparam name="TType">The type of the implementor.</typeparam>
            <param name="Converter">The converting function that creates this instance, much like <c>From</c> in Rust.</param>
        </member>
        <member name="M:Emik.Unions.Mappings.Functor`3.#ctor(System.Converter{`0,`1})">
            <summary>Defines a type that acts as a functor and <c>newtype</c> idiom from Rust simultaneously.</summary>
            <typeparam name="T">The type that can be converted into this type.</typeparam>
            <typeparam name="TResult">The resulting type that encapsulates this type.</typeparam>
            <typeparam name="TType">The type of the implementor.</typeparam>
            <param name="Converter">The converting function that creates this instance, much like <c>From</c> in Rust.</param>
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`3.Converter">
            <summary>The converting function that creates this instance, much like <c>From</c> in Rust.</summary>
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`3.New">
            <inheritdoc cref="P:Emik.Unions.Mappings.Functor`1.New"/>
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`3.Factory">
            <inheritdoc />
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`3.Item(System.Reflection.PropertyInfo)">
            <inheritdoc />
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`3.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`3.Item(System.String)">
            <inheritdoc />
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`3.Emik#Unions#Tagged#IProduct{TResult,System#Converter{T,TResult}}#Second">
            <inheritdoc />
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`3.Emik#Unions#IProperties#Properties">
            <inheritdoc />
        </member>
        <member name="P:Emik.Unions.Mappings.Functor`3.Emik#Unions#Tagged#IProduct{TResult,System#Converter{T,TResult}}#First">
            <inheritdoc />
        </member>
        <member name="M:Emik.Unions.Mappings.Functor`3.Emik#Unions#IPropertyEnumerable#Enumeration">
            <inheritdoc />
        </member>
        <member name="M:Emik.Unions.Mappings.Functor`3.op_Implicit(Emik.Unions.Mappings.Functor{`0,`1,`2})~`1">
            <summary>Gets the encapsulated value.</summary>
            <param name="functor">The value encapsulating an inner value.</param>
            <returns>The inner value of the parameter <paramref name="functor"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Mappings.Functor`3.To``1">
            <summary>Maps this instance to another functor.</summary>
            <typeparam name="TFunctor">The resulting value.</typeparam>
            <returns>
            The instance of <typeparamref name="TFunctor"/> from the mapping of <typeparamref name="TType"/>.
            </returns>
        </member>
        <member name="M:Emik.Unions.Mappings.Functor`3.Then``1">
            <inheritdoc cref="M:Emik.Unions.Mappings.Functor`3.To``1"/>
        </member>
        <member name="T:Emik.Unions.Mappings.IFunctor`2">
            <summary>
            A functor with an unspecified result type to allow for better type inference.
            Currently used in <see cref="M:Emik.Unions.Mappings.Functor`3.To``1"/>.
            </summary>
            <typeparam name="T">The input type.</typeparam>
            <typeparam name="TType">The type of the implementor.</typeparam>
        </member>
        <member name="P:Emik.Unions.Mappings.IFunctor`2.Factory">
            <summary>Gets the factory that creates a <typeparamref name="TType"/> out of <typeparamref name="T"/>.</summary>
        </member>
        <member name="T:Emik.Unions.Mappings.Self`1">
            <summary>A functor that returns itself.</summary>
            <typeparam name="T">The encapsulating type.</typeparam>
            <param name="Value">The encapsulated value.</param>
        </member>
        <member name="M:Emik.Unions.Mappings.Self`1.#ctor(`0)">
            <summary>A functor that returns itself.</summary>
            <typeparam name="T">The encapsulating type.</typeparam>
            <param name="Value">The encapsulated value.</param>
        </member>
        <member name="P:Emik.Unions.Mappings.Self`1.Value">
            <summary>The encapsulated value.</summary>
        </member>
        <member name="T:Emik.Unions.Tagged.Fault`1">
            <summary>
            A pseudo-exception-like type tossed by some other type, typically as an <see cref="P:Emik.Results.Result`2.Err"/> value.
            </summary>
            <param name="Fact">The expression that was asserted, but failed.</param>
            <param name="Uninit">The object that failed to initialize. Be wary that this object is in an invalid state.</param>
            <typeparam name="T">The type that created this instance.</typeparam>
        </member>
        <member name="M:Emik.Unions.Tagged.Fault`1.#ctor(System.String,`0)">
            <summary>
            A pseudo-exception-like type tossed by some other type, typically as an <see cref="P:Emik.Results.Result`2.Err"/> value.
            </summary>
            <param name="Fact">The expression that was asserted, but failed.</param>
            <param name="Uninit">The object that failed to initialize. Be wary that this object is in an invalid state.</param>
            <typeparam name="T">The type that created this instance.</typeparam>
        </member>
        <member name="P:Emik.Unions.Tagged.Fault`1.Fact">
            <summary>The expression that was asserted, but failed.</summary>
        </member>
        <member name="P:Emik.Unions.Tagged.Fault`1.Uninit">
            <summary>The object that failed to initialize. Be wary that this object is in an invalid state.</summary>
        </member>
        <member name="M:Emik.Unions.Tagged.Fault`1.op_Implicit(Emik.Unions.Tagged.Fault{`0})~System.Exception">
            <summary>
            Converts this instance into an <see cref="T:Emik.Unions.Tagged.FaultException"/>, then downcasting as <see cref="T:System.Exception"/>.
            This allows an <see cref="T:Emik.Unions.Tagged.Fault`1"/> to be thrown just like an <see cref="T:System.Exception"/>,
            without the heap allocation for ones that aren't thrown.
            </summary>
            <param name="fault">The instance to convert.</param>
            <returns>An <see cref="T:System.Exception"/> that contains metadata from <paramref name="fault"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Tagged.Fault`1.op_Implicit(Emik.Unions.Tagged.Fault{`0})~Emik.Unions.Tagged.FaultException">
            <summary>
            Converts this instance into an <see cref="T:Emik.Unions.Tagged.FaultException"/>.
            This allows an <see cref="T:Emik.Unions.Tagged.Fault`1"/> to be thrown just like an <see cref="T:System.Exception"/>,
            without the heap allocation for ones that aren't thrown.
            </summary>
            <param name="fault">The instance to convert.</param>
            <returns>An <see cref="T:System.Exception"/> that contains metadata from <paramref name="fault"/>.</returns>
        </member>
        <member name="M:Emik.Unions.Tagged.Fault`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Unions.Tagged.FaultException">
            <summary>The exception type that is raised by <see cref="T:Emik.Unions.Tagged.Fault`1"/>.</summary>
        </member>
        <member name="M:Emik.Unions.Tagged.FaultException.#ctor(System.String,System.String,System.Object)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.FaultException"/> class.</summary>
            <param name="message">The assertion message.</param>
            <param name="paramName">The class responsible for creating the <see cref="T:Emik.Unions.Tagged.Fault`1"/>.</param>
            <param name="uninit">The uninitialized object.</param>
        </member>
        <member name="P:Emik.Unions.Tagged.FaultException.ParamName">
            <inheritdoc />
        </member>
        <member name="P:Emik.Unions.Tagged.FaultException.Uninit">
            <summary>Gets the object that is in an invalid state.</summary>
        </member>
        <member name="M:Emik.Unions.Tagged.FaultException.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Unions.Tagged.InnerProduct`1">
            <summary>
            Defines an internal disjoint union for storing 1 of 1 different values.
            Instances of this type are exposed to the consumer as an interface.
            </summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`1.#ctor(`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.InnerProduct`1"/> class.</summary>
            <param name="first">The first parameter to pass in the union.</param>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`1.Item(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`1.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`1.First">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`1.Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`1.Enumeration">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Tagged.InnerProduct`2">
            <summary>
            Defines an internal disjoint union for storing 1 of 2 different values.
            Instances of this type are exposed to the consumer as an interface.
            </summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`2.#ctor(`0,`1)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.InnerProduct`2"/> class.</summary>
            <param name="first">The first parameter to pass in the union.</param>
            <param name="second">The second parameter to pass in the union.</param>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`2.Item(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`2.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`2.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`2.First">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`2.Second">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`2.Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`2.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`2.Enumeration">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Tagged.InnerProduct`3">
            <summary>
            Defines an internal disjoint union for storing 1 of 3 different values.
            Instances of this type are exposed to the consumer as an interface.
            </summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`3.#ctor(`0,`1,`2)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.InnerProduct`3"/> class.</summary>
            <param name="first">The first parameter to pass in the union.</param>
            <param name="second">The second parameter to pass in the union.</param>
            <param name="third">The third parameter to pass in the union.</param>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`3.Item(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`3.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`3.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`3.First">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`3.Second">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`3.Third">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`3.Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`3.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`3.Enumeration">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Tagged.InnerProduct`4">
            <summary>
            Defines an internal disjoint union for storing 1 of 4 different values.
            Instances of this type are exposed to the consumer as an interface.
            </summary>
            <typeparam name="T1">The first type of the disjoint union.</typeparam>
            <typeparam name="T2">The second type of the disjoint union.</typeparam>
            <typeparam name="T3">The third type of the disjoint union.</typeparam>
            <typeparam name="T4">The fourth type of the disjoint union.</typeparam>
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`4.#ctor(`0,`1,`2,`3)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.InnerProduct`4"/> class.</summary>
            <param name="first">The first parameter to pass in the union.</param>
            <param name="second">The second parameter to pass in the union.</param>
            <param name="third">The third parameter to pass in the union.</param>
            <param name="fourth">The fourth parameter to pass in the union.</param>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`4.Item(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`4.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`4.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`4.First">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`4.Second">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`4.Third">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`4.Fourth">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.InnerProduct`4.Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`4.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Unions.Tagged.InnerProduct`4.Enumeration">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Tagged.IProduct">
            <summary>Provides an indexer.</summary>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct.Item(System.Reflection.PropertyInfo)">
            <summary>Gets an <see cref="T:System.Object"/> corresponding to the property.</summary>
            <param name="name">The property name to get its value.</param>
            <returns><see cref="T:System.Object"/> corresponding to the property name <paramref name="name"/>.</returns>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct.Item(System.String)">
            <summary>Gets an <see cref="T:System.Object"/> corresponding to the name.</summary>
            <param name="name">The property name to get its value.</param>
            <returns><see cref="T:System.Object"/> corresponding to the property name <paramref name="name"/>.</returns>
        </member>
        <member name="T:Emik.Unions.Tagged.IProduct`1">
            <summary>Defines an interface for union of size 1.</summary>
            <typeparam name="T1">The first type of the union.</typeparam>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct`1.First">
            <summary>Gets the <typeparamref name="T1"/> first value of the union.</summary>
        </member>
        <member name="T:Emik.Unions.Tagged.IProduct`2">
            <summary>Defines an interface for union of size 2.</summary>
            <typeparam name="T1">The first type of the union.</typeparam>
            <typeparam name="T2">The second type of the union.</typeparam>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct`2.First">
            <summary>Gets the <typeparamref name="T1"/> first value of the union.</summary>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct`2.Second">
            <summary>Gets the <typeparamref name="T2"/> second value of the union.</summary>
        </member>
        <member name="T:Emik.Unions.Tagged.IProduct`3">
            <summary>Defines an interface for union of size 3.</summary>
            <typeparam name="T1">The first type of the union.</typeparam>
            <typeparam name="T2">The second type of the union.</typeparam>
            <typeparam name="T3">The third type of the union.</typeparam>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct`3.First">
            <summary>Gets the <typeparamref name="T1"/> first value of the union.</summary>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct`3.Second">
            <summary>Gets the <typeparamref name="T2"/> second value of the union.</summary>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct`3.Third">
            <summary>Gets the <typeparamref name="T3"/> third value of the union.</summary>
        </member>
        <member name="T:Emik.Unions.Tagged.IProduct`4">
            <summary>Defines an interface for union of size 4.</summary>
            <typeparam name="T1">The first type of the union.</typeparam>
            <typeparam name="T2">The second type of the union.</typeparam>
            <typeparam name="T3">The third type of the union.</typeparam>
            <typeparam name="T4">The fourth type of the union.</typeparam>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct`4.First">
            <summary>Gets the <typeparamref name="T1"/> first value of the union.</summary>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct`4.Second">
            <summary>Gets the <typeparamref name="T2"/> second value of the union.</summary>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct`4.Third">
            <summary>Gets the <typeparamref name="T3"/> third value of the union.</summary>
        </member>
        <member name="P:Emik.Unions.Tagged.IProduct`4.Fourth">
            <summary>Gets the <typeparamref name="T4"/> fourth value of the union.</summary>
        </member>
        <member name="T:Emik.Unions.Tagged.Product">
            <summary>A static class that provides methods for creating new instances of union types.</summary>
        </member>
        <member name="M:Emik.Unions.Tagged.Product.New``1(``0,System.Predicate{Emik.Unions.Tagged.IProduct{``0}},System.String)">
            <summary>Creates a <see cref="T:Emik.Unions.Tagged.IProduct`1"/> with the provided values.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`1"/>.
            </typeparam>
            <param name="first">
            The first parameter to pass in the type <see cref="T:Emik.Unions.Tagged.IProduct`1"/>.
            </param>
            <param name="firstPred">The first condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <returns><see cref="T:Emik.Unions.Tagged.IProduct`1"/> with the parameters passed in.</returns>
        </member>
        <member name="M:Emik.Unions.Tagged.Product.New``2(``0,``1,System.Predicate{Emik.Unions.Tagged.IProduct{``0,``1}},System.Predicate{Emik.Unions.Tagged.IProduct{``0,``1}},System.String,System.String)">
            <summary>Creates a <see cref="T:Emik.Unions.Tagged.IProduct`2"/> with the provided values.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`2"/>.
            </typeparam>
            <param name="first">
            The first parameter to pass in the type <see cref="T:Emik.Unions.Tagged.IProduct`2"/>.
            </param>
            <param name="second">
            The second parameter to pass in the type <see cref="T:Emik.Unions.Tagged.IProduct`2"/>.
            </param>
            <param name="firstPred">The first condition to assert. True is a valid state.</param>
            <param name="secondPred">The second condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <returns><see cref="T:Emik.Unions.Tagged.IProduct`2"/> with the parameters passed in.</returns>
        </member>
        <member name="M:Emik.Unions.Tagged.Product.New``3(``0,``1,``2,System.Predicate{Emik.Unions.Tagged.IProduct{``0,``1,``2}},System.Predicate{Emik.Unions.Tagged.IProduct{``0,``1,``2}},System.Predicate{Emik.Unions.Tagged.IProduct{``0,``1,``2}},System.String,System.String,System.String)">
            <summary>Creates a <see cref="T:Emik.Unions.Tagged.IProduct`3"/> with the provided values.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <param name="first">
            The first parameter to pass in the type <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </param>
            <param name="second">
            The second parameter to pass in the type <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </param>
            <param name="third">
            The third parameter to pass in the type <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </param>
            <param name="firstPred">The first condition to assert. True is a valid state.</param>
            <param name="secondPred">The second condition to assert. True is a valid state.</param>
            <param name="thirdPred">The third condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <param name="thirdEx">
            The expression of <paramref name="third"/> to pass as the failure value.
            </param>
            <returns><see cref="T:Emik.Unions.Tagged.IProduct`3"/> with the parameters passed in.</returns>
        </member>
        <member name="M:Emik.Unions.Tagged.Product.New``4(``0,``1,``2,``3,System.Predicate{Emik.Unions.Tagged.IProduct{``0,``1,``2,``3}},System.Predicate{Emik.Unions.Tagged.IProduct{``0,``1,``2,``3}},System.Predicate{Emik.Unions.Tagged.IProduct{``0,``1,``2,``3}},System.Predicate{Emik.Unions.Tagged.IProduct{``0,``1,``2,``3}},System.String,System.String,System.String,System.String)">
            <summary>Creates a <see cref="T:Emik.Unions.Tagged.IProduct`4"/> with the provided values.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <param name="first">
            The first parameter to pass in the type <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </param>
            <param name="second">
            The second parameter to pass in the type <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </param>
            <param name="third">
            The third parameter to pass in the type <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </param>
            <param name="fourth">
            The fourth parameter to pass in the type <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </param>
            <param name="firstPred">The first condition to assert. True is a valid state.</param>
            <param name="secondPred">The second condition to assert. True is a valid state.</param>
            <param name="thirdPred">The third condition to assert. True is a valid state.</param>
            <param name="fourthPred">The fourth condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <param name="thirdEx">
            The expression of <paramref name="third"/> to pass as the failure value.
            </param>
            <param name="fourthEx">
            The expression of <paramref name="fourth"/> to pass as the failure value.
            </param>
            <returns><see cref="T:Emik.Unions.Tagged.IProduct`4"/> with the parameters passed in.</returns>
        </member>
        <member name="T:Emik.Unions.Tagged.Product`2">
            <summary>Defines an inheritable record that automates logic for a union.</summary>
            <typeparam name="T1">The first type of the union.</typeparam>
            <typeparam name="TType">The type of the inheriting record.</typeparam>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`2.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`2"/> class.</summary>
            <remarks><para>Using this constructor means that any state is considered valid.</para></remarks>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`2.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`2"/> class.</summary>
            <param name="first">The first condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="second">The second condition to assert. True is a valid state.</param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <param name="third">The third condition to assert. True is a valid state.</param>
            <param name="thirdEx">
            The expression of <paramref name="third"/> to pass as the failure value.
            </param>
            <param name="fourth">The fourth condition to assert. True is a valid state.</param>
            <param name="fourthEx">
            The expression of <paramref name="fourth"/> to pass as the failure value.
            </param>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`2.#ctor(System.Predicate{`1},System.Predicate{`1},System.Predicate{`1},System.Predicate{`1},System.String,System.String,System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`2"/> class.</summary>
            <param name="first">The first condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="second">The second condition to assert. True is a valid state.</param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <param name="third">The third condition to assert. True is a valid state.</param>
            <param name="thirdEx">
            The expression of <paramref name="third"/> to pass as the failure value.
            </param>
            <param name="fourth">The fourth condition to assert. True is a valid state.</param>
            <param name="fourthEx">
            The expression of <paramref name="fourth"/> to pass as the failure value.
            </param>
            <exception cref="T:System.InvalidCastException">The inheriting record is not <typeparamref name="TType"/>.</exception>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`2.Emik#Unions#Tagged#IProduct{T1}#First">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`2.New(`0)">
            <summary>Attempts to create a new instance of <typeparamref name="TType"/>.</summary>
            <param name="first">The first value of the union.</param>
            <returns>A new instance of <typeparamref name="TType"/> which encapsulates all of the parameters.</returns>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`2.Item(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`2.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`2.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`2.Emik#Unions#IProperties#Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`2.Emik#Unions#IPropertyEnumerable#Enumeration">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Tagged.Product`3">
            <summary>Defines an inheritable record that automates logic for a union.</summary>
            <typeparam name="T1">The first type of the union.</typeparam>
            <typeparam name="T2">The second type of the union.</typeparam>
            <typeparam name="TType">The type of the inheriting record.</typeparam>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`3.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`3"/> class.</summary>
            <remarks><para>Using this constructor means that any state is considered valid.</para></remarks>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`3.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`3"/> class.</summary>
            <param name="first">The first condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="second">The second condition to assert. True is a valid state.</param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <param name="third">The third condition to assert. True is a valid state.</param>
            <param name="thirdEx">
            The expression of <paramref name="third"/> to pass as the failure value.
            </param>
            <param name="fourth">The fourth condition to assert. True is a valid state.</param>
            <param name="fourthEx">
            The expression of <paramref name="fourth"/> to pass as the failure value.
            </param>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`3.#ctor(System.Predicate{`2},System.Predicate{`2},System.Predicate{`2},System.Predicate{`2},System.String,System.String,System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`3"/> class.</summary>
            <param name="first">The first condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="second">The second condition to assert. True is a valid state.</param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <param name="third">The third condition to assert. True is a valid state.</param>
            <param name="thirdEx">
            The expression of <paramref name="third"/> to pass as the failure value.
            </param>
            <param name="fourth">The fourth condition to assert. True is a valid state.</param>
            <param name="fourthEx">
            The expression of <paramref name="fourth"/> to pass as the failure value.
            </param>
            <exception cref="T:System.InvalidCastException">The inheriting record is not <typeparamref name="TType"/>.</exception>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`3.Emik#Unions#Tagged#IProduct{T1,T2}#First">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`3.Emik#Unions#Tagged#IProduct{T1,T2}#Second">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`3.New(`0,`1)">
            <summary>Attempts to create a new instance of <typeparamref name="TType"/>.</summary>
            <param name="first">The first value of the union.</param>
            <param name="second">The second value of the union.</param>
            <returns>A new instance of <typeparamref name="TType"/> which encapsulates all of the parameters.</returns>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`3.Item(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`3.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`3.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`3.Emik#Unions#IProperties#Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`3.Emik#Unions#IPropertyEnumerable#Enumeration">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Tagged.Product`4">
            <summary>Defines an inheritable record that automates logic for a union.</summary>
            <typeparam name="T1">The first type of the union.</typeparam>
            <typeparam name="T2">The second type of the union.</typeparam>
            <typeparam name="T3">The third type of the union.</typeparam>
            <typeparam name="TType">The type of the inheriting record.</typeparam>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`4.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`4"/> class.</summary>
            <remarks><para>Using this constructor means that any state is considered valid.</para></remarks>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`4.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`4"/> class.</summary>
            <param name="first">The first condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="second">The second condition to assert. True is a valid state.</param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <param name="third">The third condition to assert. True is a valid state.</param>
            <param name="thirdEx">
            The expression of <paramref name="third"/> to pass as the failure value.
            </param>
            <param name="fourth">The fourth condition to assert. True is a valid state.</param>
            <param name="fourthEx">
            The expression of <paramref name="fourth"/> to pass as the failure value.
            </param>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`4.#ctor(System.Predicate{`3},System.Predicate{`3},System.Predicate{`3},System.Predicate{`3},System.String,System.String,System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`4"/> class.</summary>
            <param name="first">The first condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="second">The second condition to assert. True is a valid state.</param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <param name="third">The third condition to assert. True is a valid state.</param>
            <param name="thirdEx">
            The expression of <paramref name="third"/> to pass as the failure value.
            </param>
            <param name="fourth">The fourth condition to assert. True is a valid state.</param>
            <param name="fourthEx">
            The expression of <paramref name="fourth"/> to pass as the failure value.
            </param>
            <exception cref="T:System.InvalidCastException">The inheriting record is not <typeparamref name="TType"/>.</exception>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`4.Emik#Unions#Tagged#IProduct{T1,T2,T3}#First">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`4.Emik#Unions#Tagged#IProduct{T1,T2,T3}#Second">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`4.Emik#Unions#Tagged#IProduct{T1,T2,T3}#Third">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`4.New(`0,`1,`2)">
            <summary>Attempts to create a new instance of <typeparamref name="TType"/>.</summary>
            <param name="first">The first value of the union.</param>
            <param name="second">The second value of the union.</param>
            <param name="third">The third value of the union.</param>
            <returns>A new instance of <typeparamref name="TType"/> which encapsulates all of the parameters.</returns>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`4.Item(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`4.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`4.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`4.Emik#Unions#IProperties#Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`4.Emik#Unions#IPropertyEnumerable#Enumeration">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Tagged.Product`5">
            <summary>Defines an inheritable record that automates logic for a union.</summary>
            <typeparam name="T1">The first type of the union.</typeparam>
            <typeparam name="T2">The second type of the union.</typeparam>
            <typeparam name="T3">The third type of the union.</typeparam>
            <typeparam name="T4">The fourth type of the union.</typeparam>
            <typeparam name="TType">The type of the inheriting record.</typeparam>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`5.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`5"/> class.</summary>
            <remarks><para>Using this constructor means that any state is considered valid.</para></remarks>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`5.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`5"/> class.</summary>
            <param name="first">The first condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="second">The second condition to assert. True is a valid state.</param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <param name="third">The third condition to assert. True is a valid state.</param>
            <param name="thirdEx">
            The expression of <paramref name="third"/> to pass as the failure value.
            </param>
            <param name="fourth">The fourth condition to assert. True is a valid state.</param>
            <param name="fourthEx">
            The expression of <paramref name="fourth"/> to pass as the failure value.
            </param>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`5.#ctor(System.Predicate{`4},System.Predicate{`4},System.Predicate{`4},System.Predicate{`4},System.String,System.String,System.String,System.String)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Unions.Tagged.Product`5"/> class.</summary>
            <param name="first">The first condition to assert. True is a valid state.</param>
            <param name="firstEx">
            The expression of <paramref name="first"/> to pass as the failure value.
            </param>
            <param name="second">The second condition to assert. True is a valid state.</param>
            <param name="secondEx">
            The expression of <paramref name="second"/> to pass as the failure value.
            </param>
            <param name="third">The third condition to assert. True is a valid state.</param>
            <param name="thirdEx">
            The expression of <paramref name="third"/> to pass as the failure value.
            </param>
            <param name="fourth">The fourth condition to assert. True is a valid state.</param>
            <param name="fourthEx">
            The expression of <paramref name="fourth"/> to pass as the failure value.
            </param>
            <exception cref="T:System.InvalidCastException">The inheriting record is not <typeparamref name="TType"/>.</exception>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`5.Emik#Unions#Tagged#IProduct{T1,T2,T3,T4}#First">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`5.Emik#Unions#Tagged#IProduct{T1,T2,T3,T4}#Second">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`5.Emik#Unions#Tagged#IProduct{T1,T2,T3,T4}#Third">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`5.Emik#Unions#Tagged#IProduct{T1,T2,T3,T4}#Fourth">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`5.New(`0,`1,`2,`3)">
            <summary>Attempts to create a new instance of <typeparamref name="TType"/>.</summary>
            <param name="first">The first value of the union.</param>
            <param name="second">The second value of the union.</param>
            <param name="third">The third value of the union.</param>
            <param name="fourth">The fourth value of the union.</param>
            <returns>A new instance of <typeparamref name="TType"/> which encapsulates all of the parameters.</returns>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`5.Item(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`5.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`5.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Unions.Tagged.Product`5.Emik#Unions#IProperties#Properties">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Unions.Tagged.Product`5.Emik#Unions#IPropertyEnumerable#Enumeration">
            <inheritdoc/>
        </member>
        <member name="T:Emik.Unions.Tagged.ProductExtensions">
            <summary>A static class that provides functionality for union types.</summary>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.Index``1(Emik.Unions.Tagged.IProduct{``0},System.Int32)">
            <summary>Performs an index operation on the union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`1"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <param name="index">The index to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the index of the union.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The value <paramref name="index"/> is out of range.</exception>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.Index``1(Emik.Unions.Tagged.IProduct{``0},System.String)">
            <summary>Performs an index operation on the union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`1"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <param name="name">The name to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the name of the union.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The value <paramref name="name"/> is not a valid member.</exception>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.GetEnumerator``1(Emik.Unions.Tagged.IProduct{``0})">
            <summary>Enumerates through a <see cref="T:Emik.Unions.Tagged.IProduct`1"/>'s values.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`1"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <returns>An enumerator of objects from the items in the argument provided.</returns>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.Index``2(Emik.Unions.Tagged.IProduct{``0,``1},System.Int32)">
            <summary>Performs an index operation on the union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`2"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <param name="index">The index to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the index of the union.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The value <paramref name="index"/> is out of range.</exception>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.Index``2(Emik.Unions.Tagged.IProduct{``0,``1},System.String)">
            <summary>Performs an index operation on the union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`2"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <param name="name">The name to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the name of the union.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The value <paramref name="name"/> is not a valid member.</exception>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.GetEnumerator``2(Emik.Unions.Tagged.IProduct{``0,``1})">
            <summary>Enumerates through a <see cref="T:Emik.Unions.Tagged.IProduct`2"/>'s values.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`2"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`2"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <returns>An enumerator of objects from the items in the argument provided.</returns>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.Index``3(Emik.Unions.Tagged.IProduct{``0,``1,``2},System.Int32)">
            <summary>Performs an index operation on the union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <param name="index">The index to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the index of the union.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The value <paramref name="index"/> is out of range.</exception>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.Index``3(Emik.Unions.Tagged.IProduct{``0,``1,``2},System.String)">
            <summary>Performs an index operation on the union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <param name="name">The name to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the name of the union.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The value <paramref name="name"/> is not a valid member.</exception>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.GetEnumerator``3(Emik.Unions.Tagged.IProduct{``0,``1,``2})">
            <summary>Enumerates through a <see cref="T:Emik.Unions.Tagged.IProduct`3"/>'s values.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`3"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <returns>An enumerator of objects from the items in the argument provided.</returns>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.Index``4(Emik.Unions.Tagged.IProduct{``0,``1,``2,``3},System.Int32)">
            <summary>Performs an index operation on the union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <param name="index">The index to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the index of the union.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The value <paramref name="index"/> is out of range.</exception>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.Index``4(Emik.Unions.Tagged.IProduct{``0,``1,``2,``3},System.String)">
            <summary>Performs an index operation on the union.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <param name="name">The name to apply.</param>
            <returns>The <see cref="T:System.Object"/> corresponding to the name of the union.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The value <paramref name="name"/> is not a valid member.</exception>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.GetEnumerator``4(Emik.Unions.Tagged.IProduct{``0,``1,``2,``3})">
            <summary>Enumerates through a <see cref="T:Emik.Unions.Tagged.IProduct`4"/>'s values.</summary>
            <typeparam name="T1">
            The first generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T2">
            The second generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T3">
            The third generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <typeparam name="T4">
            The fourth generic parameter of <see cref="T:Emik.Unions.Tagged.IProduct`4"/>.
            </typeparam>
            <param name="that">The instance of the union.</param>
            <returns>An enumerator of objects from the items in the argument provided.</returns>
        </member>
        <member name="M:Emik.Unions.Tagged.ProductExtensions.GetEnumerator(Emik.Unions.IPropertyEnumerable)">
            <summary>Enumerates through a <see cref="T:Emik.Unions.IPropertyEnumerable"/>'s values.</summary>
            <param name="that">The instance of the union.</param>
            <returns>An enumerator of objects from the items in the argument provided.</returns>
        </member>
        <member name="T:Emik.Unions.Factories">
            <summary>Generates factories for types.</summary>
        </member>
        <member name="M:Emik.Unions.Factories.From``2">
            <summary>Creates a factory from a given type.</summary>
            <typeparam name="T1">The first type of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="TType">The type to create the factory from.</typeparam>
            <exception cref="T:System.MissingMemberException">
            There is no constructor on <typeparamref name="TType"/> that matches the signature of the return factory.
            </exception>
            <returns>A generated factory.</returns>
        </member>
        <member name="M:Emik.Unions.Factories.From``3">
            <summary>Creates a factory from a given type.</summary>
            <typeparam name="T1">The first type of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="T2">The second type of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="TType">The type to create the factory from.</typeparam>
            <exception cref="T:System.MissingMemberException">
            There is no constructor on <typeparamref name="TType"/> that matches the signature of the return factory.
            </exception>
            <returns>A generated factory.</returns>
        </member>
        <member name="M:Emik.Unions.Factories.From``4">
            <summary>Creates a factory from a given type.</summary>
            <typeparam name="T1">The first type of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="T2">The second type of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="T3">The third type of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="TType">The type to create the factory from.</typeparam>
            <exception cref="T:System.MissingMemberException">
            There is no constructor on <typeparamref name="TType"/> that matches the signature of the return factory.
            </exception>
            <returns>A generated factory.</returns>
        </member>
        <member name="M:Emik.Unions.Factories.From``5">
            <summary>Creates a factory from a given type.</summary>
            <typeparam name="T1">The first type of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="T2">The second type of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="T3">The third type of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="T4">The fourth type of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="TType">The type to create the factory from.</typeparam>
            <exception cref="T:System.MissingMemberException">
            There is no constructor on <typeparamref name="TType"/> that matches the signature of the return factory.
            </exception>
            <returns>A generated factory.</returns>
        </member>
        <member name="T:Emik.Unions.IProperties">
            <summary>Provides an indexer.</summary>
        </member>
        <member name="P:Emik.Unions.IProperties.Properties">
            <summary>Gets all properties of this type.</summary>
            <returns>An <see cref="T:System.Array"/> of <see cref="T:System.Reflection.PropertyInfo"/> instances.</returns>
        </member>
        <member name="P:Emik.Unions.IProperties.Item(System.Int32)">
            <summary>
            Gets an <see cref="T:System.Object"/> corresponding to the property of the type based on the index passed in.
            </summary>
            <param name="index">The property number to get its value.</param>
            <returns><see cref="T:System.Object"/> corresponding to the property number <paramref name="index"/>.</returns>
        </member>
        <member name="T:Emik.Unions.IPropertyEnumerable">
            <summary>Provides an enumeration.</summary>
        </member>
        <member name="M:Emik.Unions.IPropertyEnumerable.Enumeration">
            <summary>Enumerates through a <see cref="T:Emik.Unions.IPropertyEnumerable"/>'s values.</summary>
            <returns>An enumerator of objects from the items in the argument provided.</returns>
        </member>
        <member name="T:InlineMethod.InlineAttribute">
            <summary>Method to inline.</summary>
        </member>
        <member name="M:InlineMethod.InlineAttribute.#ctor(System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:InlineMethod.InlineAttribute"/> class.</summary>
            <param name="remove">The value to set.</param>
        </member>
        <member name="P:InlineMethod.InlineAttribute.Remove">
            <summary>Gets a value indicating whether to remove the method after inlining, if private.</summary>
        </member>
    </members>
</doc>
