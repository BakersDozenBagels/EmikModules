<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emik.Results</name>
    </assembly>
    <members>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks><para>
            Index is used by the C# compiler to support the new index syntax.
            </para><code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code></remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks><para>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means
            pointing at beyond last element.
            </para></remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <inheritdoc />
        </member>
        <member name="M:System.Index.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">
            The length of the collection that the Index will be used with. length has to be a positive value.
            </param>
            <remarks><para>
            For performance reasons, we don't validate the input length parameter and the returned offset value against
            negative values. We don't validate either the returned offset is greater than the input length.
            It is expected that Index be used with collections which always have non-negative length/count.
            If the returned offset is negative and then used to index a collection will get out of range exception which
            will be same affect as the validation.
            </para></remarks>
        </member>
        <member name="M:System.Index.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks><para>
            Range is used by the C# compiler to support the range syntax.
            </para><code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code></remarks>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <inheritdoc />
        </member>
        <member name="M:System.Range.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Range.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.RangeMethodsWithoutValueTuples">
            <summary>Implements a <see cref="M:System.RangeMethodsWithoutValueTuples.GetOffsetAndLength(System.Range,System.Int32,System.Int32@,System.Int32@)"/> overload that doesn't rely on tuples.</summary>
        </member>
        <member name="M:System.RangeMethodsWithoutValueTuples.GetOffsetAndLength(System.Range,System.Int32,System.Int32@,System.Int32@)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <remarks><para>
            For performance reasons, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </para></remarks>
            <param name="range">The <see cref="T:System.Range"/> that contains the range of elements.</param>
            <param name="length">
            The length of the collection that the range will be used with.
            <paramref name="length"/> has to be a positive value.
            </param>
            <param name="outOffset">The resulting offset.</param>
            <param name="outLength">The resulting length.</param>
        </member>
        <member name="T:System.Diagnostics.Contracts.PureAttribute">
            <summary>Indicates that a type or method is pure, that is, it does not make any visible state changes.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute"/> class
            with the specified return value condition.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>,
            the parameter will not be null even if the corresponding type allows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute"/> class
            with the specified return value condition.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute"/> class
            with the associated parameter name.
            </summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute"/> class
            with the specified parameter value.
            </summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>
            Gets a value indicating whether the condition parameter value
            is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute"/> class with a field or property member.
            </summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute"/> class
            with the list of field and property members.
            </summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute"/> class
            with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute"/> class
            with the specified return value condition and list of field and property members.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type,
            and callers do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.UnreachableException">
            <summary>Exception thrown when the program executes an instruction that was thought to be unreachable.</summary>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with a specified error message
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:System.Runtime.CompilerServices.ITuple">
            <summary>This interface is required for types that want to be indexed into by dynamic patterns.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Length">
            <summary>The number of positions in this data structure.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)">
            <summary>Get the element at position <paramref name="index"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleElementNamesAttribute">
            <summary>
            Indicates that the use of <see cref="T:System.ValueTuple" /> on a member is meant to be treated as a tuple with element names.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute" /> class.
            </summary>
            <param name="transformNames">
            Specifies, in a pre-order depth-first traversal of a type's
            construction, which <see cref="T:System.ValueTuple" /> occurrences are
            meant to carry element names.
            </param>
            <remarks><para>
            This constructor is meant to be used on types that contain an
            instantiation of <see cref="T:System.ValueTuple" /> that contains
            element names.  For instance, if <c>C</c> is a generic type with
            two type parameters, then a use of the constructed type <c>C{<see cref="T:System.ValueTuple`2" />,
            <see cref="T:System.ValueTuple`3" /></c> might be intended to
            treat the first type argument as a tuple with element names and the
            second as a tuple without element names. In which case, the
            appropriate attribute specification should use a
            <paramref name="transformNames"/> value of <c>{ "name1", "name2", null, null,
            null }</c>.
            </para></remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames">
            <summary>
            Specifies, in a pre-order depth-first traversal of a type's
            construction, which <see cref="T:System.ValueTuple" /> elements are
            meant to carry element names.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
            <summary>
            Used to indicate to the compiler that a method should be called in its containing module's initializer.
            </summary>
            <remarks><para>
            When one or more valid methods with this attribute are found in a compilation,
            the compiler will emit a module initializer that calls each of the attributed methods.<br />
            Certain requirements are imposed on any method targeted with this attribute:
            </para><list type="bullet">
            <item><description>The method must be <see langword="static"/>.</description></item>
            <item><description>
            The method must be an ordinary member method, as opposed to a property accessor,
            constructor, local function, and so on.
            </description></item>
            <item><description>The method must be parameterless..</description></item>
            <item><description>The method must return <see langword="void"/>.</description></item>
            <item><description>The method must not be generic or be contained in a generic type.</description></item>
            <item><description>
            The method's effective accessibility must be <see langword="internal"/> or <see langword="public"/>.
            </description></item>
            </list><para>
            For more information, see
            https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerFilePathAttribute">
            <inheritdoc />
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerLineNumberAttribute">
            <inheritdoc />
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerMemberNameAttribute">
            <inheritdoc />
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>Indicates that a parameter captures the expression passed for another parameter as a string.</summary>
            <remarks><para>This attribute is implemented in the compiler for C# 10 and later versions only.</para></remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.</summary>
            <param name="parameterName">The name of the parameter whose expression should be captured as a string.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>Gets the name of the parameter whose expression should be captured as a string.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
            </summary>
            <remarks><para>
            This attribute is unsafe because it may reveal uninitialized memory to the application in certain
            instances (e.g., reading from uninitialized stackalloc'd memory). If applied to a method directly,
            the attribute applies to that method and all nested functions (lambdas, local functions) below it.
            If applied to a type or module, it applies to all methods nested inside. This attribute is intentionally
            not permitted on assemblies. Use at the module level instead to apply to multiple type declarations.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is
            required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> class.</summary>
            <param name="featureName">The name of the compiler feature.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>Gets the name of the compiler feature.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            Gets or sets a value indicating whether the compiler can choose to allow access to the location
            where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>Specifies that a type has required members or that a member is required.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RuntimeHelpers">
            <summary>
            Provides a set of static methods and properties that provide support for compilers. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray``1(``0[],System.Range)">
            <summary>Slices the specified array using the specified range.</summary>
            <typeparam name="T">The type of elements in the array.</typeparam>
            <param name="array">The array to slice.</param>
            <param name="range">
            An object that determines the portion of <paramref name="array"/> to include in the slice.
            </param>
            <returns>The subarray defined by <paramref name="range"/>.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.MethodImplOptions">
            <summary>
            Specifies constants that define the details of how a method is implemented.
            This enumeration supports a bitwise combination of its member values.
            </summary>
            <remarks><para>
            This enumeration is used with the <see cref="T:System.Runtime.CompilerServices.MethodImplAttribute"/> attribute.
            You can specify multiple <see cref="T:System.Runtime.CompilerServices.MethodImplOptions"/> values by using the bitwise OR operator.
            </para></remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.Unmanaged">
            <summary>The method is implemented in unmanaged code.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.NoInlining">
            <summary>
            The method cannot be inlined.
            Inlining is an optimization by which a method call is replaced with the method body.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.ForwardRef">
            <summary>The method is declared, but its implementation is provided elsewhere.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.Synchronized">
            <summary>
            The method can be executed by only one thread at a time.
            Static methods lock on the type, whereas instance methods lock on the instance.
            Only one thread can execute in any of the instance functions,
            and only one thread can execute in any of a class's static functions.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.NoOptimization">
            <summary>
            The method is not optimized by the just-in-time (JIT) compiler or by native code generation (see Ngen.exe)
            when debugging possible code generation problems.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.PreserveSig">
            <summary>The method signature is exported exactly as declared.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining">
            <summary>The method should be inlined if possible.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization">
            <summary>The method contains code that should always be optimized by the just-in-time (JIT) compiler.</summary>
            <remarks><para>
            Use this attribute if running an unoptimized version of the method has undesirable effects,
            for instance causing too much overhead or extra memory allocation.
            </para><para>
            Methods with this attribute may not have optimal code generation.
            They bypass the first tier of Tiered Compilation and therefore can't benefit from optimizations that rely on
            tiering, for example, Dynamic PGO or optimizations based on initialized classes.
            </para></remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.InternalCall">
            <summary>
            The call is internal, that is, it calls a method that's implemented within the common language runtime.
            </summary>
        </member>
        <member name="T:System.IValueTupleInternal">
            <summary>
            Helper so we can call some tuple methods recursively without knowing the underlying types.
            </summary>
        </member>
        <member name="T:System.ValueTuple">
            <summary>
            The ValueTuple types (from arity 0 to 8) comprise the runtime implementation that underlies tuples in C# and struct tuples in F#.
            Aside from created via language syntax, they are most easily created via the ValueTuple.Create factory methods.
            The System.ValueTuple types differ from the System.Tuple types in that:
            - they are structs rather than classes,
            - they are mutable rather than readonly, and
            - their members (such as Item1, Item2, etc) are fields rather than properties.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is a <see cref="T:System.ValueTuple"/>.</returns>
        </member>
        <member name="M:System.ValueTuple.Equals(System.ValueTuple)">
            <summary>Returns a value indicating whether this instance is equal to a specified value.</summary>
            <param name="other">An instance to compare to this instance.</param>
            <returns>true if <paramref name="other"/> has the same value as this instance; otherwise, false.</returns>
        </member>
        <member name="M:System.ValueTuple.CompareTo(System.ValueTuple)">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>()</c>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Create">
            <summary>Creates a new struct 0-tuple.</summary>
            <returns>A 0-tuple.</returns>
        </member>
        <member name="M:System.ValueTuple.Create``1(``0)">
            <summary>Creates a new struct 1-tuple, or singleton.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <returns>A 1-tuple (singleton) whose value is (item1).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``2(``0,``1)">
            <summary>Creates a new struct 2-tuple, or pair.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <returns>A 2-tuple (pair) whose value is (item1, item2).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``3(``0,``1,``2)">
            <summary>Creates a new struct 3-tuple, or triple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <returns>A 3-tuple (triple) whose value is (item1, item2, item3).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``4(``0,``1,``2,``3)">
            <summary>Creates a new struct 4-tuple, or quadruple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <returns>A 4-tuple (quadruple) whose value is (item1, item2, item3, item4).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``5(``0,``1,``2,``3,``4)">
            <summary>Creates a new struct 5-tuple, or quintuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <returns>A 5-tuple (quintuple) whose value is (item1, item2, item3, item4, item5).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>Creates a new struct 6-tuple, or sextuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <returns>A 6-tuple (sextuple) whose value is (item1, item2, item3, item4, item5, item6).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>Creates a new struct 7-tuple, or septuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <returns>A 7-tuple (septuple) whose value is (item1, item2, item3, item4, item5, item6, item7).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Creates a new struct 8-tuple, or octuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <typeparam name="T8">The type of the eighth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <param name="item8">The value of the eighth component of the tuple.</param>
            <returns>An 8-tuple (octuple) whose value is (item1, item2, item3, item4, item5, item6, item7, item8).</returns>
        </member>
        <member name="T:System.ValueTuple`1">
            <summary>Represents a 1-tuple, or singleton, as a value type.</summary>
            <typeparam name="T1">The type of the tuple's only component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`1.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`1"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`1"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`1"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.ValueTuple{`0})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`1"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its field
            is equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.CompareTo(System.ValueTuple{`0})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`1.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`1.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`1"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1)</c>,
            where <c>Item1</c> represents the value of <see cref="F:System.ValueTuple`1.Item1"/>. If the field is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`2">
            <summary>
            Represents a 2-tuple, or pair, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`2.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`2.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`2"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.Object)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified object.
             </summary>
             <param name="obj">The object to compare with this instance.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
             <list type="bullet">
                 <item><description>It is a <see cref="T:System.ValueTuple`2"/> value type.</description></item>
                 <item><description>Its components are of the same types as those of the current instance.</description></item>
                 <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.ValueTuple{`0,`1})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified <see cref="T:System.ValueTuple`2"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`2.CompareTo(System.ValueTuple{`0,`1})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`2.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`2.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`2"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2)</c>,
            where <c>Item1</c> and <c>Item2</c> represent the values of the <see cref="F:System.ValueTuple`2.Item1"/>
            and <see cref="F:System.ValueTuple`2.Item2"/> fields. If either field value is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`3">
            <summary>
            Represents a 3-tuple, or triple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`3.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's third component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`3"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`3"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.ValueTuple{`0,`1,`2})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`3"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.CompareTo(System.ValueTuple{`0,`1,`2})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`3.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`3.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`3"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`4">
            <summary>
            Represents a 4-tuple, or quadruple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`4.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's fourth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`4"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`4"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.ValueTuple{`0,`1,`2,`3})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`4"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.CompareTo(System.ValueTuple{`0,`1,`2,`3})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`4.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`4.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`4"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`5">
            <summary>
            Represents a 5-tuple, or quintuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`5.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fifth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`5"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`5"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`5"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`5.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`5.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`5"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`6">
            <summary>
            Represents a 6-tuple, or sixtuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`6.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's sixth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`6"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`6"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`6"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`6.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`6.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`6"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`7">
            <summary>
            Represents a 7-tuple, or sentuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`7.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's seventh component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`7"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`7"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`7"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`7.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`7.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`7"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`8">
            <summary>
            Represents an 8-tuple, or octuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
            <typeparam name="TRest">The type of the tuple's eighth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`8.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's seventh component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Rest">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's eighth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`8"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
            <param name="rest">The value of the tuple's eight component.</param>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`8"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`8"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`8.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`8.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`8"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7, Rest)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.KeyValuePairDeconstructors">
            <summary>Allows a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> to be deconstructed, much like a tuple.</summary>
        </member>
        <member name="M:System.KeyValuePairDeconstructors.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>Deconstructs a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> into its components.</summary>
            <typeparam name="TKey">The key generic in the <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</typeparam>
            <typeparam name="TValue">The value generic in the <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</typeparam>
            <param name="kvp">The key value pair to deconstruct.</param>
            <param name="key">The key value to get assigned as the key value pair's key.</param>
            <param name="value">The key value to get assigned as the key value pair's value.</param>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyCollection`1">
            <summary>Provides a read-only, covariant view of a generic list.</summary>
            <typeparam name="T">The type of item on the list.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyCollection`1.Count">
            <summary>Gets the amount of items on the list.</summary>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyDictionary`2">
            <summary>Represents a generic read-only collection of key/value pairs.</summary>
            <typeparam name="TKey">The type of keys in the read-only dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the read-only dictionary.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Keys">
            <summary>Gets an enumerable collection that contains the keys in the read-only dictionary.</summary>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Values">
            <summary>Gets an enumerable collection that contains the values in the read-only dictionary.</summary>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Item(`0)">
            <summary>Gets the element that has the specified key in the read-only dictionary.</summary>
            <param name="key">The key to locate.</param>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the read-only dictionary contains an element that has the specified key.</summary>
            <param name="key">The key to locate.</param>
            <returns>
            <see langword="true"/> if the read-only dictionary contains an element that has the specified key;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>Gets the value that is associated with the specified key.</summary>
            <param name="key">The key to locate.</param>
            <param name="value">
            When this method returns, the value associated with the specified key, if the key is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <see langword="true"/> if the object that implements the <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>
            interface contains an element that has the specified key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyList`1">
            <summary>Represents a read-only collection of elements that can be accessed by index.</summary>
            <typeparam name="T">The type of elements in the read-only list.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyList`1.Item(System.Int32)">
            <summary>Performs an index operation on the list.</summary>
            <param name="index">The item to retrieve.</param>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlySet`1">
            <summary>Provides a readonly abstraction of a set.</summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.Contains(`0)">
            <summary>Determines if the set contains a specific item.</summary>
            <param name="item">The item to check if the set contains.</param>
            <returns><see langword="true"/> if found; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) subset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set is a proper subset of other; otherwise <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) superset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the collection is a proper superset of other; otherwise <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determine whether the current set is a subset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true"/> if the current set is a subset of other; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determine whether the current set is a super set of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true"/> if the current set is a subset of other; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set overlaps with the specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set and other share at least one common element;
            otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set is equal to other; otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="T:System.Collections.Generic.ISet`1">
            <summary>Provides the base interface for the abstraction of sets.</summary>
            <remarks><para>
            This interface provides methods for implementing sets,
            which are collections that have unique elements and specific operations.
            </para></remarks>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes all elements in the specified collection from the current set.</summary>
            <remarks><para>
            This method is an O(<c>n</c>) operation,
            where <c>n</c> is the number of elements in the <paramref name="other"/> parameter.
            </para></remarks>
            <param name="other">The collection of items to remove from the set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains only elements that are also in a specified collection.
            </summary>
            <remarks><para>This method ignores any duplicate elements in other.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains only elements that are present
            either in the current set or in the specified collection, but not both.
            </summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains all elements that are present in the current set,
            in the specified collection, or in both.
            </summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.Add(`0)">
            <summary>
            Adds an element to the current set and returns a value to indicate if the element was successfully added.
            </summary>
            <param name="item">The element to add to the set.</param>
            <returns>
            <see langword="true"/> if the element is added to the set;
            <see langword="false"/> if the element is already in the set.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) superset of a specified collection.</summary>
            <remarks><para>
            If the current set is a proper superset of <paramref name="other"/>,
            <paramref name="other"/> must have at least one element that the current set does not have.
            </para><para>
            An empty set is a proper superset of any other collection. Therefore, this method returns <see langword="true"/>
            if the current set is empty, unless the <paramref name="other"/> parameter is also an empty set.
            </para><para>
            This method always returns <see langword="false"/> if the current set is
            less than or equal to the number of elements in <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a proper superset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) subset of a specified collection.</summary>
            <remarks><para>
            If the current set is a proper subset of <paramref name="other"/>,
            <paramref name="other"/> must have at least one element that the current set does not have.
            </para><para>
            An empty set is a proper subset of any other collection. Therefore, this method returns <see langword="true"/>
            if the current set is empty, unless the <paramref name="other"/> parameter is also an empty set.
            </para><para>
            This method always returns <see langword="false"/> if the current set has
            more or the same number of elements than <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a proper subset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a set is a subset of a specified collection.</summary>
            <remarks><para>
            If <paramref name="other"/> contains the same elements as the current set,
            the current set is still considered a subset of <paramref name="other"/>.
            </para><para>
            This method always returns <see langword="false"/> if the current
            set has elements that are not in <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a subset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a superset of a specified collection.</summary>
            <remarks><para>
            If <paramref name="other"/> contains the same elements as the current set,
            the current set is still considered a superset of <paramref name="other"/>.
            </para><para>
            This method always returns <see langword="false"/> if the current
            set has fewer elements than <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a superset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set overlaps with the specified collection.</summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set and <paramref name="other"/> share at least one common element;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is equal to <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Each">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32,System.Action)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32,System.Action{System.Int32})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0,System.Action{``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0,System.Action{System.Int32,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,System.Int32,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IDictionary{``0,``1},System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{``0,``1,``2})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IDictionary{``0,``1},System.Action{``0,``1,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{``0,``1,System.Int32,``2})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="num">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.GetEnumerator(System.Int32)">
            <summary>Gets an enumeration of a number.</summary>
            <param name="num">The index to count up or down to.</param>
            <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Int32"/> from ranges 0 to <paramref name="upper"/> - 1.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,System.Func{``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TResult">The type of iterator.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The function for each loop.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,System.Converter{System.Int32,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TResult">The type of iterator.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The function for each loop.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Force">
            <summary>Extension methods to force full enumerations.</summary>
        </member>
        <member name="M:Emik.Morsels.Force.Enumerate(System.Collections.IEnumerable)">
            <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
            <param name="iterable">The collection of items to go through one-by-one.</param>
        </member>
        <member name="M:Emik.Morsels.Force.Enumerate``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
        </member>
        <member name="T:Emik.Morsels.Heap">
            <summary>Provides methods for heap-allocation analysis.</summary>
        </member>
        <member name="F:Emik.Morsels.Heap.NotForProduction">
            <summary>
            A <see langword="string"/> to use in an <see cref="T:System.ObsoleteAttribute"/> to indicate that the API isn't meant
            for production, but not for deprecated reasons.
            </summary>
        </member>
        <member name="M:Emik.Morsels.Heap.Swallow(System.Action)">
            <summary>Swallows all exceptions from a callback; Use with caution.</summary>
            <param name="action">The dangerous callback.</param>
        </member>
        <member name="M:Emik.Morsels.Heap.CountAllocation(System.Action,System.Boolean)">
            <summary>Gets the amount of bytes a callback uses.</summary>
            <remarks><para>
            This method temporarily tunes the <see cref="T:System.GC"/> to <see cref="F:System.Runtime.GCLatencyMode.LowLatency"/>
            for accurate results. As such, the parameter <paramref name="heap"/> should not cause
            substantial allocation such that collecting mid-way is required.
            </para></remarks>
            <param name="heap">The callback that causes some amount of heap allocation.</param>
            <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
            <returns>The number of bytes the <see cref="T:System.GC"/> allocated from calling <paramref name="heap"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Heap.CountAllocations(System.Action,System.Int32,System.Boolean)">
            <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
            <param name="heap">The callback that causes some amount of heap allocation.</param>
            <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
            <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
            <returns>
            An <see cref="T:System.Array"/> where each entry is a separate test of the number of
            bytes the <see cref="T:System.GC"/> allocated from calling <paramref name="heap"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.TryTake">
            <summary>Extension methods to attempt to grab values from enumerables.</summary>
        </member>
        <member name="M:Emik.Morsels.TryTake.TryCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Attempts to determine the number of elements in a sequence without forcing an enumeration.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <remarks><para>
            The method performs a series of type tests, identifying common subtypes whose
            count can be determined without enumerating; this includes <see cref="T:System.Collections.Generic.ICollection`1"/>,
            <see cref="T:System.Collections.ICollection"/>, and <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.
            </para><para>
            The method is typically a constant-time operation, but ultimately this depends on the complexity
            characteristics of the underlying collection implementation.
            </para></remarks>
            <returns>The length of the collection if pre-computed, or <see langword="null"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.EnumerateOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the last item lazily, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.FirstOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the first item, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The first item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.LastOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the last item, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.OrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns the enumeration, or an empty enumeration.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The enumeration to potentially return.</param>
            <returns>The parameter <paramref name="iterable"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.NthLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Nth``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="TKey">The key item in the collection.</typeparam>
            <typeparam name="TValue">The value item in the collection.</typeparam>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="key">The key to use to get the value.</param>
            <returns>An element from the parameter <paramref name="dictionary"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.EachLazy">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,System.Int32,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Enumerable`2">
            <summary>
            Defines an <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a <see cref="T:System.Delegate"/> that is invoked on iteration.
            </summary>
            <typeparam name="T">The type of item in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TExternal">The context element to pass into the <see cref="T:System.Delegate"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32,`1})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Delegate)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Enumerable`2"/> class.</summary>
            <param name="enumerable">
            The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create an <see cref="T:System.Collections.Generic.IEnumerator`1"/> from.
            </param>
            <param name="external">The context element.</param>
            <param name="action">The <see cref="T:System.Delegate"/> to invoke on iteration.</param>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Enumerable`2.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Enumerable`2.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Indexers">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Indexers.For(System.Index)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="index">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.For(System.Range)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="range">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Index)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Range)">
            <summary>Gets a range of items from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get a range of items from.</param>
            <param name="range">The ranges to get.</param>
            <returns>A slice from the parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.GetEnumerator(System.Index)">
            <summary>Gets an enumeration of an index.</summary>
            <param name="index">The index to count up or down to.</param>
            <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.GetEnumerator(System.Range)">
            <summary>Gets an enumeration of a range.</summary>
            <param name="range">The range to iterate over.</param>
            <returns>An enumeration from the range's start to end.</returns>
        </member>
        <member name="T:Emik.Morsels.ManyQueries">
            <summary>Methods that creates enumerations from individual items.</summary>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(``0,System.Converter{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="item">The item to check.</param>
            <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Nullable{``0},System.Converter{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="item">The item to check.</param>
            <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Peeks">
            <summary>Provides methods to use callbacks within a statement.</summary>
        </member>
        <member name="E:Emik.Morsels.Peeks.OnWrite">
            <summary>An event that is invoked every time <see cref="M:Emik.Morsels.Peeks.Write(System.String)"/> is called.</summary>
        </member>
        <member name="M:Emik.Morsels.Peeks.Shout(System.String)">
            <summary>
            Invokes <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>, and <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)"/>.
            </summary>
            <remarks><para>
            This method exists to be able to hook both conditional methods in <see cref="E:Emik.Morsels.Peeks.OnWrite"/>,
            and to allow the consumer to be able to remove this method to the same <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.
            </para></remarks>
            <param name="message">The value to send a message.</param>
        </member>
        <member name="M:Emik.Morsels.Peeks.Write(System.String)">
            <summary>Quick and dirty debugging function, invokes <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.</summary>
            <param name="message">The value to send a message.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
        </member>
        <member name="M:Emik.Morsels.Peeks.Write``1(``0)">
            <summary>Quick and dirty debugging function, invokes <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to stringify.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
        </member>
        <member name="M:Emik.Morsels.Peeks.Debug``1(``0,System.Boolean,System.Converter{``0,System.Object},System.Predicate{``0},System.Action{System.String},System.String,System.String,System.Int32,System.String)">
            <summary>Quick and dirty debugging function.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to stringify and return.</param>
            <param name="shouldLogExpression">Determines whether <paramref name="expression"/> is logged.</param>
            <param name="map">The map callback.</param>
            <param name="filter">The filter callback.</param>
            <param name="logger">The logging callback.</param>
            <param name="expression">Automatically filled by compilers; the source code of <paramref name="value"/>.</param>
            <param name="path">Automatically filled by compilers; the file's path where this method was called.</param>
            <param name="line">Automatically filled by compilers; the line number where this method was called.</param>
            <param name="member">Automatically filled by compilers; the member's name where this method was called.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Peeks.Peek``1(``0,System.Action{``0})">
            <summary>Executes an <see cref="T:System.Action`1"/>, and returns the argument.</summary>
            <typeparam name="T">The type of value and action parameter.</typeparam>
            <param name="value">The value to pass into the callback.</param>
            <param name="action">The callback to perform.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Clamped">
            <summary>Extension methods to clamp numbers.</summary>
        </member>
        <member name="M:Emik.Morsels.Clamped.Clamp(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
            <param name="number">The number to clip.</param>
            <param name="min">If specified, the smallest number to return.</param>
            <param name="max">If specified, the greatest number to return.</param>
            <returns>
            The parameter <paramref name="min"/> if <paramref name="number"/> is smaller than <paramref name="min"/>,
            otherwise, the parameter <paramref name="max"/> if <paramref name="number"/> is greater than
            <paramref name="max"/>, otherwise the parameter <paramref name="number"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Clamped.Clamp(System.Single,System.Nullable{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:Emik.Morsels.Clamped.Clamp(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>
        </member>
        <member name="T:Emik.Morsels.Collected">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Collected.ToCollectionLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Upcasts or creates an <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to upcast or encapsulate.</param>
            <returns>Itself as <see cref="T:System.Collections.Generic.ICollection`1"/>, or a collected <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Collected.ToListLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Upcasts or creates an <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to upcast or encapsulate.</param>
            <returns>Itself as <see cref="T:System.Collections.Generic.IList`1"/>, or a collected <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Collected.Collect``2(System.Collections.Generic.IEnumerable{``0},System.Converter{System.Collections.Generic.IEnumerable{``0},``1})">
            <summary>Attempts to create a list from an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <typeparam name="T">The type of item in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TList">The destination type.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to convert.</param>
            <param name="converter">The <see cref="T:System.Collections.Generic.IList`1"/> to convert it to.</param>
            <returns>
            A <typeparamref name="TList"/> from <paramref name="converter"/>, as long as every element returned
            is not <paramref langword="null"/>, otherwise <paramref langword="default"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Conditionals">
            <summary>Extension methods for nullable types and booleans.</summary>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsAnd``1(``0,System.Predicate{``0})">
            <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="predicate">The predicate to determine the return value.</param>
            <returns>
            The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
            and returned <see langword="true"/> from the predicate, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsAnd``1(System.Nullable{``0},System.Predicate{``0})">
            <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="predicate">The predicate to determine the return value.</param>
            <returns>
            The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
            and returned <see langword="true"/> from the predicate, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsFalse(System.Boolean,System.String)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="that">The value that must be <see langword="false"/>.</param>
            <param name="exThat">Filled by the compiler, the expression to assert.</param>
            <returns>The parameter <paramref name="that"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsTrue(System.Boolean,System.String)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="that">The value that must be <see langword="true"/>.</param>
            <param name="exThat">Filled by the compiler, the expression to assert.</param>
            <returns>The parameter <paramref name="that"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.NotThen(System.Boolean,System.Action,System.Action)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="value">The value to check.</param>
            <param name="ifFalse">The value to invoke when <see langword="false"/>.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then(System.Boolean,System.Action,System.Action)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="value">The value to check.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <param name="ifFalse">The value to invoke when <see langword="false"/>.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Filter``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Filters an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to only non-null values.</summary>
            <typeparam name="T">The type of value to filter.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to filter.</param>
            <returns>A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> with strictly non-null values.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Filter``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>Filters an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to only non-null values.</summary>
            <typeparam name="T">The type of value to filter.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to filter.</param>
            <returns>A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> with strictly non-null values.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.NotThen``1(System.Boolean,``0)">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is eagerly evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="ifFalse">The value to return when <see langword="false"/>.</param>
            <returns>
            The value <paramref name="ifFalse"/> if <paramref name="value"/>
            is <see langword="false"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.NotThen``1(System.Boolean,System.Func{``0})">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is lazily evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="onFalse">The value to invoke when <see langword="false"/>.</param>
            <returns>
            The value returned from <paramref name="onFalse"/> if <paramref name="value"/>
            is <see langword="false"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then``1(System.Boolean,``0)">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is eagerly evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="onTrue">The value to return when <see langword="true"/>.</param>
            <returns>
            The value <paramref name="onTrue"/> if <paramref name="value"/>
            is <see langword="true"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then``1(System.Boolean,System.Func{``0})">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is lazily evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <returns>
            The value returned from <paramref name="ifTrue"/> if <paramref name="value"/>
            is <see langword="true"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Stringifier">
            <summary>Provides stringification methods.</summary>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.Char)">
            <summary>Joins a set of values into one long <see cref="T:System.String"/>.</summary>
            <remarks><para>
            This method is more efficient than using
            <see cref="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.String)"/> for <see cref="T:System.Char"/> separators.
            </para></remarks>
            <typeparam name="T">The type of each item in the collection.</typeparam>
            <param name="values">The values to join.</param>
            <param name="separator">The separator between each item.</param>
            <returns>One long <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Joins a set of values into one long <see cref="T:System.String"/>.</summary>
            <typeparam name="T">The type of each item in the collection.</typeparam>
            <param name="values">The values to join.</param>
            <param name="separator">The separator between each item.</param>
            <returns>One long <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Nth(System.Int32,System.Boolean)">
            <summary>Converts a number to an ordinal.</summary>
            <param name="i">The number to convert.</param>
            <param name="indexByZero">Determines whether to index from zero or one.</param>
            <returns>The parameter <paramref name="i"/> as an ordinal.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Stringify``1(``0)">
            <summary>
            Converts <paramref name="source"/> into a <see cref="T:System.String"/> representation of <paramref name="source"/>.
            </summary>
            <remarks><para>
            Unlike <see cref="M:System.Object.ToString"/>, the values of all properties are printed out,
            unless they explicitly define a <see cref="M:System.Object.ToString"/>, or inherit <see cref="T:System.Collections.IEnumerable"/>,
            in which case each item within is printed out separately.
            </para></remarks>
            <typeparam name="T">The type of the source.</typeparam>
            <param name="source">The item to get a <see cref="T:System.String"/> representation of.</param>
            <returns><paramref name="source"/> as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Stringify``1(``0,System.Boolean,System.Boolean)">
            <summary>
            Converts <paramref name="source"/> into a <see cref="T:System.String"/> representation of <paramref name="source"/>.
            </summary>
            <remarks><para>
            Unlike <see cref="M:System.Object.ToString"/>, the values of all properties are printed out,
            unless they explicitly define a <see cref="M:System.Object.ToString"/>, or inherit <see cref="T:System.Collections.IEnumerable"/>,
            in which case each item within is printed out separately.
            </para></remarks>
            <typeparam name="T">The type of the source.</typeparam>
            <param name="source">The item to get a <see cref="T:System.String"/> representation of.</param>
            <param name="isSurrounded">
            Determines whether <see cref="T:System.String"/> and <see cref="T:System.Char"/> have a " and ' surrounding them.
            </param>
            <param name="isRecursive">
            Determines whether it re-calls <see cref="M:Emik.Morsels.Stringifier.Stringify``1(``0,System.Boolean,System.Boolean)"/>
            on each property in <paramref name="source"/>.
            </param>
            <returns><paramref name="source"/> as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Yes`1">
            <summary>A factory for creating iterator types that yield the same item forever.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Yes`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.Yes`1"/> struct. Prepares enumeration of a single item forever.
            </summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Yes`1.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Yes`1.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.op_Implicit(`0)~Emik.Morsels.Yes{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.op_Implicit(Emik.Morsels.Yes{`0})~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Yes`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Yes`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.GetEnumerator">
            <summary>Returns itself.</summary>
            <remarks><para>Used to allow <see langword="foreach"/> to be used on <see cref="T:Emik.Morsels.Yes`1"/>.</para></remarks>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerator#Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerator#MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.YesFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Yes`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.YesFactory.Forever``1(``0)">
            <summary>Creates a <see cref="T:Emik.Morsels.Yes`1"/> from an item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The <see cref="T:Emik.Morsels.Yes`1"/> instance that can be yielded forever.</returns>
        </member>
        <member name="T:Emik.Morsels.MethodGroupings">
            <summary>Methods to create methods.</summary>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Invoke(System.Action)">
            <summary>Invokes a method.</summary>
            <param name="del">The method to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action(System.Action)">
            <summary>Create a delegate.</summary>
            <param name="del">The method group.</param>
            <returns>An invokable method.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action1``1(System.Action{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action2``2(System.Action{``0,``1})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action3``3(System.Action{``0,``1,``2})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action4``4(System.Action{``0,``1,``2,``3})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func``1(System.Func{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func1``2(System.Func{``0,``1})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func2``3(System.Func{``0,``1,``2})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func3``4(System.Func{``0,``1,``2,``3})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func4``5(System.Func{``0,``1,``2,``3,``4})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not1``1(System.Func{``0,System.Boolean})">
            <summary>Negates a predicate.</summary>
            <typeparam name="T">The type of item for the predicate.</typeparam>
            <param name="predicate">The predicate to negate.</param>
            <returns>The argument <paramref name="predicate"/> wrapped in another that negates its result.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not2``1(System.Func{``0,System.Int32,System.Boolean})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Invoke``1(System.Func{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Invoke(System.Action)"/>
        </member>
        <member name="T:Emik.Morsels.Once`1">
            <summary>A factory for creating iterator types that yields an item once.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Once`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.Once`1"/> struct. Prepares enumeration of a single item forever.
            </summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.Current">
            <summary>Gets the item to use.</summary>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IReadOnlyList{T}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.Once`1.op_Implicit(`0)~Emik.Morsels.Once{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.op_Implicit(Emik.Morsels.Once{`0})~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Once`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Once`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.Once`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.GetEnumerator">
            <summary>
            Returns itself. Used to tell the compiler that it can be used in a <see langword="foreach"/> loop.
            </summary>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Once`1.Enumerator">
            <summary>An enumerator over <see cref="T:Emik.Morsels.Once`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.Once`1.Enumerator"/> struct.
            Prepares enumeration of a single item forever.
            </summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Once`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Once`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.op_Implicit(`0)~Emik.Morsels.Once{`0}.Enumerator">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.op_Implicit(Emik.Morsels.Once{`0}.Enumerator)~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Once`1.Enumerator.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Once`1.Enumerator.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.OnceFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Once`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.OnceFactory.Yield``1(``0)">
            <summary>Creates a <see cref="T:Emik.Morsels.Once`1"/> from an item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The <see cref="T:Emik.Morsels.Once`1"/> instance that can be yielded once.</returns>
        </member>
        <member name="T:Emik.Morsels.Split`1">
            <summary>Represents a fixed collection of 2 items.</summary>
            <typeparam name="T">The type of item in the collection.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Split`1.#ctor(`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Split`1"/> class.</summary>
            <param name="value">The value representing both values.</param>
        </member>
        <member name="M:Emik.Morsels.Split`1.#ctor(`0,`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Split`1"/> class.</summary>
            <param name="truthy">The value representing a <see langword="true"/> value.</param>
            <param name="falsy">The value representing a <see langword="false"/> value.</param>
        </member>
        <member name="P:Emik.Morsels.Split`1.Falsy">
            <summary>Gets or sets the value representing a <see langword="false"/> value.</summary>
        </member>
        <member name="P:Emik.Morsels.Split`1.Truthy">
            <summary>Gets or sets the value representing a <see langword="true"/> value.</summary>
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="M:Emik.Morsels.Split`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Clear" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.Values">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#Keys">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.Item(System.Boolean)">
            <inheritdoc cref="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.Add(System.Boolean,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Add(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.CopyTo(System.Collections.Generic.KeyValuePair{System.Boolean,`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Contains(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.TryGetValue(System.Boolean,`0@)">
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Clear">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Clear" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Remove(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#Remove(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#ContainsKey(System.Boolean)">
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyCollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#Keys">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#Values">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#ContainsKey(System.Boolean)">
            <inheritdoc cref="M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.Deconstruct(`0@,`0@)">
            <summary>Deconstructs a <see cref="T:Emik.Morsels.Split`1"/> into its components.</summary>
            <param name="truthy">The value to get assigned as <see cref="P:Emik.Morsels.Split`1.Truthy"/>.</param>
            <param name="falsy">The value to get assigned as <see cref="P:Emik.Morsels.Split`1.Falsy"/>.</param>
        </member>
        <member name="M:Emik.Morsels.Split`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.SplitFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Split`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.SplitFactory.SplitBy``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Splits an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in two based on a method provided.</summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <param name="source">The collection to split.</param>
            <param name="predicate">The method that decides where the item ends up.</param>
            <returns>
            A <see cref="T:Emik.Morsels.Split`1"/> instance that contains 2 lists containing the elements that returned
            <see langword="true"/> and <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Unforgiving">
            <summary>Provides a reference for an <see cref="T:System.Diagnostics.UnreachableException"/>.</summary>
        </member>
        <member name="P:Emik.Morsels.Unforgiving.CannotBeEmpty">
            <summary>Gets the <see cref="T:System.Exception"/> that a collection cannot be empty.</summary>
        </member>
        <member name="P:Emik.Morsels.Unforgiving.Unreachable">
            <summary>Gets the <see cref="T:System.Exception"/> that represents an unreachable state.</summary>
        </member>
        <member name="T:Emik.Morsels.NullableItems">
            <summary>Extension methods for improving nullability awareness for enumerables.</summary>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="iterable">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="iterable"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="iterator">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="iterator"/>, with <see cref="T:JetBrains.Annotations.ItemCanBeNullAttribute"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemNotNull``1(System.Collections.Generic.IList{``0})">
            <summary>Returns the list if all items are non-null.</summary>
            <typeparam name="T">The type of list.</typeparam>
            <param name="list">The list to filter.</param>
            <returns>
            The parameter <paramref name="list"/> if all items are non-<see langword="null"/>,
            otherwise <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="collection">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="collection"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="list">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="list"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlySet{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="set">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="set"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="T:Emik.Morsels.NegatedEnumerable">
            <summary>Extension methods that negate functions from <see cref="T:System.Linq.Enumerable"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.TakeUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.TakeUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.ToEnumerable(System.Collections.IEnumerator)">
            <summary>
            Negated <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>.
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <param name="iterator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> to encapsulate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating the parameter <paramref name="iterator"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.ToEnumerable``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Negated <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>.
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> to encapsulate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating the parameter <paramref name="iterator"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.WhereNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.WhereNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="T:Emik.Morsels.PowerSetFactories">
            <summary>Extension methods to create power sets.</summary>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet(System.Collections.ICollection)">
            <inheritdoc cref="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})">
            <summary>Creates a power set from a collection.</summary>
            <remarks><para>
            The power set is defined as the set of all subsets, including the empty set and the set itself.
            </para></remarks>
            <typeparam name="T">The type of item in the set.</typeparam>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The argument <paramref name="collection"/> has 32 or more elements.
            </exception>
            <param name="collection">The set to create a power set.</param>
            <returns>The power set of the parameter <paramref name="collection"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <inheritdoc cref="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="T:Emik.Morsels.ClippedList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where indices are always clamped and therefore never be out of range.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.ClippedList`1"/> class.</summary>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:Emik.Morsels.ClippedList`1.Count"/> returns a non-positive number.</exception>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.ClippedFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.ClippedList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.ClippedFactory.ToClippedLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.ClippedList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.ClippedList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.ClippedList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.GuardedList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where applying an index will always result in an optional value;
            an out of range value will always give the <see langword="default"/> value.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.GuardedList`1"/> class.</summary>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.GuardedFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.GuardedList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.GuardedFactory.ToGuardedLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.GuardedList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.GuardedList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.GuardedList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.CircularList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where elements are treated as circular;
            indices wrap around and will therefore never be out of range.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.CircularList`1"/> class.</summary>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:Emik.Morsels.CircularList`1.Count"/> returns a non-positive number.</exception>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.CircularFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.CircularList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.CircularFactory.ToCircularLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.CircularList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.CircularList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.CircularList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.RandomizedGetters">
            <summary>Extension methods for randomized getters.</summary>
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>Shuffles a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <param name="selector">The indices to swap with, when left unspecified, uses <see cref="M:Emik.Morsels.RandomizedGetters.Rand"/>.</param>
            <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.PickRandom``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>Shuffles a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <param name="selector">The indices to swap with, when left unspecified, uses <see cref="M:Emik.Morsels.RandomizedGetters.Rand"/>.</param>
            <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.ReadOnlyList`1">
            <summary>Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> and make all mutating methods a no-op.</summary>
            <typeparam name="T">The type of element in the list.</typeparam>
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.ReadOnlyList`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)" />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.ReadOnlyFactory">
            <summary>Extension methods that act as factories for <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.ReadOnlyFactory.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.</param>
            <returns>A <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Results.Extensions.Fatalities">
            <summary>Methods to determine the severity of an <see cref="T:System.Exception"/>.</summary>
        </member>
        <member name="M:Emik.Results.Extensions.Fatalities.IsFatal(System.Exception)">
            <summary>Determines whether an <see cref="T:System.Exception"/> can be handled by <see cref="T:Emik.Results.Please"/>.</summary>
            <remarks>
            <para>List of fatal exceptions:</para>
            <list type="bullet">
            <item><description><see cref="T:System.Threading.AbandonedMutexException"/></description></item>
            <item><description><see cref="T:System.AccessViolationException"/></description></item>
            <item><description><see cref="T:System.ArithmeticException"/></description></item>
            <item><description><see cref="T:System.ArgumentNullException"/></description></item>
            <item><description><see cref="T:System.ArgumentOutOfRangeException"/></description></item>
            <item><description><see cref="T:System.ArrayTypeMismatchException"/></description></item>
            <item><description><see cref="T:System.AppDomainUnloadedException"/></description></item>
            <item><description><see cref="T:System.BadImageFormatException"/></description></item>
            <item><description><c>CultureNotFoundException</c> (excluding .NET Framework 3.5)</description></item>
            <item><description><see cref="T:System.ExecutionEngineException"/></description></item>
            <item><description><see cref="T:System.Runtime.InteropServices.ExternalException"/></description></item>
            <item><description><see cref="T:Emik.Results.IFatal"/></description></item>
            <item><description><see cref="T:System.IndexOutOfRangeException"/></description></item>
            <item><description><c>InsufficientExecutionStackException</c> (.NET Framework 3.5 only)</description></item>
            <item><description><see cref="T:System.InvalidCastException"/></description></item>
            <item><description><see cref="T:System.Collections.Generic.KeyNotFoundException"/></description></item>
            <item><description><see cref="T:System.NotImplementedException"/></description></item>
            <item><description><see cref="T:System.NullReferenceException"/></description></item>
            <item><description><see cref="T:System.ObjectDisposedException"/></description></item>
            <item><description><see cref="T:System.OutOfMemoryException"/></description></item>
            <item><description><see cref="T:System.OverflowException"/></description></item>
            <item><description><see cref="T:System.RankException"/></description></item>
            <item><description><see cref="T:System.StackOverflowException"/></description></item>
            <item><description><see cref="T:System.Threading.ThreadAbortException"/></description></item>
            <item><description><see cref="T:System.TypeInitializationException"/></description></item>
            <item><description><see cref="T:System.Diagnostics.UnreachableException"/></description></item>
            </list>
            </remarks>
            <param name="ex">The exception to determine whether it can be handled.</param>
            <returns>
            The value <see langword="true"/> if the parameter <paramref name="ex"/> is of an <see cref="T:System.Exception"/>
            <see cref="T:System.Type"/> that is considered fatal, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.Fatalities.IsBenign(System.Exception)">
            <summary>Negated version of <see cref="M:Emik.Results.Extensions.Fatalities.IsFatal(System.Exception)"/>.</summary>
            <param name="ex">The exception to determine whether it can be handled.</param>
            <returns>
            The value <see langword="true"/> if the parameter <paramref name="ex"/> is of an <see cref="T:System.Exception"/>
            <see cref="T:System.Type"/> that is considered recoverable, otherwise <see langword="false"/>.
            </returns>
            <inheritdoc cref="M:Emik.Results.Extensions.Fatalities.IsFatal(System.Exception)"/>
        </member>
        <member name="T:Emik.Results.Extensions.ResultFactory">
            <summary>Additional methods for <see cref="T:Emik.Results.ResultException`1"/> that are type- or generic-sensitive.</summary>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.Then``2(System.Boolean,``0,``1)">
            <summary>Creates a result from a boolean expression.</summary>
            <remarks><para>All parameters are eagerly evaluated.</para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="value">The <see cref="T:System.Boolean"/> value to check.</param>
            <param name="ifTrue">
            The value to <see langword="return"/> when <paramref name="value"/> is <see langword="true"/>.
            </param>
            <param name="ifFalse">
            The value to <see langword="return"/> when <paramref name="value"/> is <see langword="false"/>.
            </param>
            <returns>
            The parameter <paramref name="ifTrue"/> if <paramref name="value"/> is <see langword="true"/>,
            otherwise the parameter <paramref name="ifFalse"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.Then``2(System.Boolean,System.Func{``0},System.Func{``1})">
            <summary>Creates a result from a boolean expression.</summary>
            <remarks><para>All parameters are lazily evaluated.</para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="value">The <see cref="T:System.Boolean"/> value to check.</param>
            <param name="onTrue">The value to invoke when <paramref name="value"/> is <see langword="true"/>.</param>
            <param name="onFalse">The value to invoke when <paramref name="value"/> is <see langword="false"/>.</param>
            <returns>
            The parameter <paramref name="onTrue"/> if <paramref name="value"/> is <see langword="true"/>,
            otherwise the parameter <paramref name="onFalse"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.Flatten``2(System.Collections.Generic.IEnumerable{Emik.Results.Result{``0,``1}})">
            <summary>
            Returns all <see cref="P:Emik.Results.Result`2.Ok"/> values,
            or the first-found <see cref="P:Emik.Results.Result`2.Err"/> if any exist.
            </summary>
            <remarks><para>The type must be an enumeration of results.</para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="enumerable">The iterable of results.</param>
            <returns>
            All <see cref="P:Emik.Results.Result`2.Ok"/> values, or the first <see cref="P:Emik.Results.Result`2.Err"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.FlattenErr``2(System.Collections.Generic.IEnumerable{Emik.Results.Result{``0,``1}})">
            <summary>
            Returns all <see cref="P:Emik.Results.Result`2.Err"/> values,
            or the first-found <see cref="P:Emik.Results.Result`2.Ok"/> if any exist.
            </summary>
            <remarks><para>The type must be an enumeration of results.</para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="enumerable">The iterable of results.</param>
            <returns>
            All <see cref="P:Emik.Results.Result`2.Err"/> values, or the first <see cref="P:Emik.Results.Result`2.Ok"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.Flatten``2(Emik.Results.Result{Emik.Results.Result{``0,``1},``1})">
            <summary>Maps the nested results into one result.</summary>
            <remarks><para>The parameter must be a nested <see cref="T:Emik.Results.Result`2"/>.</para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="result">The result parameter.</param>
            <returns>The nested results collapsing into one result.</returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.Flatten``2(Emik.Results.Result{``0,Emik.Results.Result{``0,``1}})">
            <summary>Maps the nested results into one result.</summary>
            <remarks><para>The parameter must be a nested <see cref="T:Emik.Results.Result`2"/>.</para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="result">The result parameter.</param>
            <returns>The nested results collapsing into one result.</returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.Flatten``2(Emik.Results.Result{Emik.Results.Result{``0,``1},Emik.Results.Result{``0,``1}})">
            <summary>Maps the nested results into one result.</summary>
            <remarks><para>The parameter must be a nested <see cref="T:Emik.Results.Result`2"/>.</para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="result">The result parameter.</param>
            <returns>The nested results collapsing into one result.</returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.IntoErr``1(``0)">
            <summary>Maps <typeparamref name="T"/> into a <see cref="T:Emik.Results.Result`2"/>.</summary>
            <typeparam name="T">The error type.</typeparam>
            <param name="err">The value to pass in.</param>
            <returns>
            A <see cref="T:Emik.Results.Result`2"/> where <paramref name="err"/> is used if it isn't <see langword="null"/>,
            or else <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.IntoErr``1(System.Nullable{``0})">
            <summary>Maps <typeparamref name="T"/> into a <see cref="T:Emik.Results.Result`2"/>.</summary>
            <typeparam name="T">The error type.</typeparam>
            <param name="err">The value to pass in.</param>
            <returns>
            A <see cref="T:Emik.Results.Result`2"/> where <paramref name="err"/> is used if it isn't <see langword="null"/>,
            or else <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.IntoErrOr``2(``1,``0)">
            <summary>Maps <typeparamref name="TErr"/> into a <see cref="T:Emik.Results.Result`2"/>.</summary>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="err">The value to pass in.</param>
            <param name="ok">The value to use instead if <paramref name="err"/> is <see langword="null"/>.</param>
            <returns>
            A <see cref="T:Emik.Results.Result`2"/> where <paramref name="err"/> is used if it isn't <see langword="null"/>,
            or else <paramref name="ok"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.IntoErrOr``2(System.Nullable{``1},``0)">
            <summary>Maps <typeparamref name="TErr"/> into a <see cref="T:Emik.Results.Result`2"/>.</summary>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="err">The value to pass in.</param>
            <param name="ok">The value to use instead if <paramref name="err"/> is <see langword="null"/>.</param>
            <returns>
            A <see cref="T:Emik.Results.Result`2"/> where <paramref name="err"/> is used if it isn't <see langword="null"/>,
            or else <paramref name="ok"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.IntoOk``1(System.Nullable{``0})">
            <summary>Maps <typeparamref name="T"/> into a <see cref="T:Emik.Results.Result`2"/>.</summary>
            <typeparam name="T">The success type.</typeparam>
            <param name="ok">The value to pass in.</param>
            <returns>
            A <see cref="T:Emik.Results.Result`2"/> where <paramref name="ok"/> is used if it isn't <see langword="null"/>,
            or else <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.IntoOk``1(``0)">
            <summary>Maps <typeparamref name="T"/> into a <see cref="T:Emik.Results.Result`2"/>.</summary>
            <typeparam name="T">The success type.</typeparam>
            <param name="ok">The value to pass in.</param>
            <returns>
            A <see cref="T:Emik.Results.Result`2"/> where <paramref name="ok"/> is used if it isn't <see langword="null"/>,
            or else <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.IntoOkOr``2(System.Nullable{``0},``1)">
            <summary>Maps <typeparamref name="TOk"/> into a <see cref="T:Emik.Results.Result`2"/>.</summary>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="ok">The value to pass in.</param>
            <param name="err">The value to use instead if <paramref name="ok"/> is <see langword="null"/>.</param>
            <returns>
            A <see cref="T:Emik.Results.Result`2"/> where <paramref name="ok"/> is used if it isn't <see langword="null"/>,
            or else <paramref name="err"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.IntoOkOr``2(``0,``1)">
            <summary>Maps <typeparamref name="TOk"/> into a <see cref="T:Emik.Results.Result`2"/>.</summary>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="ok">The value to pass in.</param>
            <param name="err">The value to use instead if <paramref name="ok"/> is <see langword="null"/>.</param>
            <returns>
            A <see cref="T:Emik.Results.Result`2"/> where <paramref name="ok"/> is used if it isn't <see langword="null"/>,
            or else <paramref name="err"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.ErrOrCast``2(Emik.Results.Result{``0,``1})">
            <summary>
            Gets the value of the <see cref="T:Emik.Results.Result`2"/> by casting into <typeparamref name="TErr"/>.
            </summary>
            <remarks><para>
            The generic parameter <typeparamref name="TOk"/> must implement or inherit <typeparamref name="TErr"/>.
            </para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="result">The result parameter.</param>
            <returns>
            The value <see cref="P:Emik.Results.Result`2.Err"/>, or <see cref="P:Emik.Results.Result`2.Ok"/> as <typeparamref name="TErr"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.ErrOrNew``2(Emik.Results.Result{``0,``1})">
            <summary>
            Gets <see cref="P:Emik.Results.Result`2.Err"/>, or calls the default constructor for <typeparamref name="TErr"/>.
            </summary>
            <remarks><para>
            The generic parameter <typeparamref name="TErr"/> must have a public default constructor.
            </para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="result">The result parameter.</param>
            <returns>
            The value <see cref="P:Emik.Results.Result`2.Err"/>, or the default constructor for <typeparamref name="TErr"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.OkOrCast``2(Emik.Results.Result{``0,``1})">
            <summary>
            Gets the value of the <see cref="T:Emik.Results.Result`2"/> by casting into <typeparamref name="TOk"/>.
            </summary>
            <remarks><para>
            The generic parameter <typeparamref name="TErr"/> must implement or inherit <typeparamref name="TOk"/>.
            </para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="result">The result parameter.</param>
            <returns>
            The value <see cref="P:Emik.Results.Result`2.Ok"/>,
            or <see cref="P:Emik.Results.Result`2.Err"/> as <typeparamref name="TOk"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.OkOr``2(Emik.Results.Result{``0,``1})">
            <summary>
            Gets the value of the <see cref="T:Emik.Results.Result`2"/> by casting into <typeparamref name="TOk"/>.
            </summary>
            <remarks><para>
            The generic parameter <typeparamref name="TErr"/> must implement or inherit <typeparamref name="TOk"/>.
            </para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="result">The result parameter.</param>
            <returns>
            The value <see cref="P:Emik.Results.Result`2.Ok"/>,
            or <see cref="P:Emik.Results.Result`2.Err"/> as <typeparamref name="TOk"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.OkOrNew``2(Emik.Results.Result{``0,``1})">
            <summary>
            Gets <see cref="P:Emik.Results.Result`2.Ok"/>, or calls the default constructor for <typeparamref name="TOk"/>.
            </summary>
            <remarks><para>
            The generic parameter <typeparamref name="TOk"/> must have a public default constructor.
            </para></remarks>
            <typeparam name="TOk">The success type.</typeparam>
            <typeparam name="TErr">The error type.</typeparam>
            <param name="result">The result parameter.</param>
            <returns>
            The value <see cref="P:Emik.Results.Result`2.Ok"/>, or the default constructor for <typeparamref name="TOk"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Extensions.ResultFactory.OkOrErr``1(Emik.Results.Result{``0,``0})">
            <summary>
            Returns the value, but unlike <see cref="P:Emik.Results.Result`2.Value"/>,
            nothing is boxed since both types are the same.
            </summary>
            <remarks><para>Both the success and error types must be the same.</para></remarks>
            <typeparam name="T">The success and error type.</typeparam>
            <param name="result">The result parameter.</param>
            <returns>The value of <paramref name="result"/>.</returns>
        </member>
        <member name="T:Emik.Results.IFatal">
            <summary>
            Non-generic <see cref="T:Emik.Results.ResultException`1"/>. Implement this to disallow catching in <see cref="T:Emik.Results.Please"/>.
            If <see cref="P:Emik.Results.IFatal.Value"/> has no appropriate implementation, simply <see langword="return"/> <see langword="null"/>.
            </summary>
            <remarks><para>For more details, see <see cref="T:Emik.Results.ResultException`1"/>.</para></remarks>
        </member>
        <member name="P:Emik.Results.IFatal.Value">
            <summary>Gets the value.</summary>
        </member>
        <member name="T:Emik.Results.Please">
            <summary>Methods to wrap try-catch into a <see cref="T:Emik.Results.Result`2"/>.</summary>
        </member>
        <member name="M:Emik.Results.Please.Try``1(System.Predicate{``0},``0)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="T">The type of the first parameter.</typeparam>
            <param name="predicate">The <see cref="T:System.Delegate"/> to invoke.</param>
            <param name="first">The first parameter to invoke <paramref name="predicate"/> with.</param>
            <returns>The result of <paramref name="predicate"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.Try(System.Action)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <param name="action">The <see cref="T:System.Delegate"/> to invoke.</param>
            <returns>The result of <paramref name="action"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.Try``1(System.Action{``0},``0)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="T">The type of the first parameter.</typeparam>
            <param name="action">The <see cref="T:System.Delegate"/> to invoke.</param>
            <param name="first">The first parameter to invoke <paramref name="action"/> with.</param>
            <returns>The result of <paramref name="action"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.Try``2(System.Action{``0,``1},``0,``1)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <param name="action">The <see cref="T:System.Delegate"/> to invoke.</param>
            <param name="first">The first parameter to invoke <paramref name="action"/> with.</param>
            <param name="second">The second parameter to invoke <paramref name="action"/> with.</param>
            <returns>The result of <paramref name="action"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.Try``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <param name="action">The <see cref="T:System.Delegate"/> to invoke.</param>
            <param name="first">The first parameter to invoke <paramref name="action"/> with.</param>
            <param name="second">The second parameter to invoke <paramref name="action"/> with.</param>
            <param name="third">The third parameter to invoke <paramref name="action"/> with.</param>
            <returns>The result of <paramref name="action"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.Try``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="T4">The type of the fourth parameter.</typeparam>
            <param name="action">The <see cref="T:System.Delegate"/> to invoke.</param>
            <param name="first">The first parameter to invoke <paramref name="action"/> with.</param>
            <param name="second">The second parameter to invoke <paramref name="action"/> with.</param>
            <param name="third">The third parameter to invoke <paramref name="action"/> with.</param>
            <param name="fourth">The fourth parameter to invoke <paramref name="action"/> with.</param>
            <returns>The result of <paramref name="action"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.Try``1(System.Func{``0})">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="TResult">The type of the result of <paramref name="func"/>.</typeparam>
            <param name="func">The <see cref="T:System.Delegate"/> to invoke.</param>
            <returns>The result of <paramref name="func"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.Try``2(System.Func{``0,``1},``0)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="T">The type of the first parameter.</typeparam>
            <typeparam name="TResult">The type of the result of <paramref name="func"/>.</typeparam>
            <param name="func">The <see cref="T:System.Delegate"/> to invoke.</param>
            <param name="first">The first parameter to invoke <paramref name="func"/> with.</param>
            <returns>The result of <paramref name="func"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.Try``3(System.Func{``0,``1,``2},``0,``1)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="TResult">The type of the result of <paramref name="func"/>.</typeparam>
            <param name="func">The <see cref="T:System.Delegate"/> to invoke.</param>
            <param name="first">The first parameter to invoke <paramref name="func"/> with.</param>
            <param name="second">The second parameter to invoke <paramref name="func"/> with.</param>
            <returns>The result of <paramref name="func"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.Try``4(System.Func{``0,``1,``2,``3},``0,``1,``2)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="TResult">The type of the result of <paramref name="func"/>.</typeparam>
            <param name="func">The <see cref="T:System.Delegate"/> to invoke.</param>
            <param name="first">The first parameter to invoke <paramref name="func"/> with.</param>
            <param name="second">The second parameter to invoke <paramref name="func"/> with.</param>
            <param name="third">The third parameter to invoke <paramref name="func"/> with.</param>
            <returns>The result of <paramref name="func"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.Try``5(System.Func{``0,``1,``2,``3,``4},``0,``1,``2,``3)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="T1">The type of the first parameter.</typeparam>
            <typeparam name="T2">The type of the second parameter.</typeparam>
            <typeparam name="T3">The type of the third parameter.</typeparam>
            <typeparam name="T4">The type of the fourth parameter.</typeparam>
            <typeparam name="TResult">The type of the result of <paramref name="func"/>.</typeparam>
            <param name="func">The <see cref="T:System.Delegate"/> to invoke.</param>
            <param name="first">The first parameter to invoke <paramref name="func"/> with.</param>
            <param name="second">The second parameter to invoke <paramref name="func"/> with.</param>
            <param name="third">The third parameter to invoke <paramref name="func"/> with.</param>
            <param name="fourth">The fourth parameter to invoke <paramref name="func"/> with.</param>
            <returns>The result of <paramref name="func"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="M:Emik.Results.Please.TryMap``2(System.Converter{``0,``1},``0)">
            <summary>Attempts to invoke a <see cref="T:System.Delegate"/>.</summary>
            <typeparam name="T">The type of the first parameter.</typeparam>
            <typeparam name="TResult">The type of the result of <paramref name="converter"/>.</typeparam>
            <param name="converter">The <see cref="T:System.Delegate"/> to invoke.</param>
            <param name="first">The first parameter to invoke <paramref name="converter"/> with.</param>
            <returns>The result of <paramref name="converter"/>, or the <see cref="T:System.Exception"/> thrown.</returns>
        </member>
        <member name="T:Emik.Results.Result">
            <summary>Methods to create result types from singular values.</summary>
        </member>
        <member name="M:Emik.Results.Result.Err">
            <summary>Creates an <see cref="P:Emik.Results.Result`2.Err"/> value.</summary>
            <returns>A <see cref="T:Emik.Results.Result`2"/> marked with <see cref="P:Emik.Results.Result`2.Err"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result.Ok">
            <summary>Creates an <see cref="P:Emik.Results.Result`2.Ok"/> value.</summary>
            <returns>A <see cref="T:Emik.Results.Result`2"/> marked with <see cref="P:Emik.Results.Result`2.Ok"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result.Err``2">
            <summary>Creates an <see cref="P:Emik.Results.Result`2.Err"/> value.</summary>
            <typeparam name="TOk">The type of <see cref="P:Emik.Results.Result`2.Ok"/>.</typeparam>
            <typeparam name="TErr">The type of <see cref="P:Emik.Results.Result`2.Err"/>.</typeparam>
            <returns>A <see cref="T:Emik.Results.Result`2"/> marked with <see cref="P:Emik.Results.Result`2.Err"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result.Ok``2">
            <summary>Creates an <see cref="P:Emik.Results.Result`2.Ok"/> value.</summary>
            <typeparam name="TOk">The type of <see cref="P:Emik.Results.Result`2.Ok"/>.</typeparam>
            <typeparam name="TErr">The type of <see cref="P:Emik.Results.Result`2.Err"/>.</typeparam>
            <returns>A <see cref="T:Emik.Results.Result`2"/> marked with <see cref="P:Emik.Results.Result`2.Ok"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result.Err``1(``0)">
            <summary>Creates an <see cref="P:Emik.Results.Result`2.Err"/> value.</summary>
            <typeparam name="T">The type of <see cref="P:Emik.Results.Result`2.Err"/>.</typeparam>
            <param name="err">The value to pass into the <see cref="T:Emik.Results.Result"/>.</param>
            <returns>A <see cref="T:Emik.Results.Result`2"/> with <paramref name="err"/> passed in.</returns>
        </member>
        <member name="M:Emik.Results.Result.Ok``1(``0)">
            <summary>Creates an <see cref="P:Emik.Results.Result`2.Ok"/> value.</summary>
            <typeparam name="T">The type of <see cref="P:Emik.Results.Result`2.Ok"/>.</typeparam>
            <param name="ok">The value to pass into the <see cref="T:Emik.Results.Result"/>.</param>
            <returns>A <see cref="T:Emik.Results.Result`2"/> with <paramref name="ok"/> passed in.</returns>
        </member>
        <member name="M:Emik.Results.Result.Err``2(``1)">
            <summary>Creates an <see cref="P:Emik.Results.Result`2.Err"/> value.</summary>
            <typeparam name="TOk">The type of <see cref="P:Emik.Results.Result`2.Ok"/>.</typeparam>
            <typeparam name="TErr">The type of <see cref="P:Emik.Results.Result`2.Err"/>.</typeparam>
            <param name="err">The value to pass into the <see cref="T:Emik.Results.Result"/>.</param>
            <returns>A <see cref="T:Emik.Results.Result`2"/> with <paramref name="err"/> passed in.</returns>
        </member>
        <member name="M:Emik.Results.Result.Ok``2(``0)">
            <summary>Creates an <see cref="P:Emik.Results.Result`2.Ok"/> value.</summary>
            <typeparam name="TOk">The type of <see cref="P:Emik.Results.Result`2.Ok"/>.</typeparam>
            <typeparam name="TErr">The type of <see cref="P:Emik.Results.Result`2.Err"/>.</typeparam>
            <param name="ok">The value to pass into the <see cref="T:Emik.Results.Result"/>.</param>
            <returns>A <see cref="T:Emik.Results.Result`2"/> with <paramref name="ok"/> passed in.</returns>
        </member>
        <member name="T:Emik.Results.ResultException`1">
            <summary>Represents an <see cref="T:System.Exception"/> thrown by <see cref="T:Emik.Results.Result`2"/>.</summary>
            <remarks><para>
            Due to the philosophy of <see cref="T:Emik.Results.ResultException`1"/>, it is generally advised but not completely
            disallowed to catch this type, as it strongly indicates an unsalvageable program state.
            </para></remarks>
            <typeparam name="T">The error value.</typeparam>
        </member>
        <member name="P:Emik.Results.ResultException`1.Value">
            <summary>Gets the value.</summary>
        </member>
        <member name="P:Emik.Results.ResultException`1.Emik#Results#IFatal#Value">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.ResultException`1.Throw(System.String,`0)">
            <summary>Throws a <see cref="T:Emik.Results.ResultException`1"/>.</summary>
            <param name="message">The message of the exception.</param>
            <param name="value">The value of the exception.</param>
            <exception cref="T:Emik.Results.ResultException`1">Always.</exception>
            <returns>This method does not return.</returns>
        </member>
        <member name="M:Emik.Results.ResultException`1.CoerceThenThrow(System.String,`0)">
            <summary>
            Throws a <see cref="T:Emik.Results.ResultException`1"/>, but the <paramref name="message"/>
            may be replaced with <paramref name="value"/> from type coercion.
            </summary>
            <param name="message">The message of the exception,
            if <paramref name="value"/> isn't a <see langword="string"/>.
            </param>
            <param name="value">The value of the exception, and message
            if <typeparamref name="T"/> is <see langword="string"/>.
            </param>
            <exception cref="T:Emik.Results.ResultException`1">Always.</exception>
            <returns>This method does not return.</returns>
        </member>
        <member name="T:Emik.Results.Result`2">
            <summary>
            <see cref="T:Emik.Results.Result`2"/> is the type used for returning and propagating errors.
            It is either <see cref="P:Emik.Results.Result`2.Ok"/>, representing success and containing a value, or <see cref="P:Emik.Results.Result`2.Err"/>,
            representing error and containing an error value.
            </summary>
            <remarks><para>
            The <see cref="T:Emik.Results.Result`2"/> type encourages that you move away from raising exceptions inside a method,
            and instead return an error value.<br/>This is to allow the callee of some function to be consciously aware that...
            </para><list type="bullet">
            <item><description>a method can fail while not forcing control flow (e.g. try-catch).</description></item>
            <item><description>let the callee decide the severity of this error.</description></item>
            <item><description>omits the overhead of catching exceptions.</description></item>
            </list></remarks>
            <typeparam name="TOk">The type of the success value.</typeparam>
            <typeparam name="TErr">The type of the error value.</typeparam>
        </member>
        <member name="M:Emik.Results.Result`2.#ctor(`1)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Results.Result`2"/> struct. The error value is specified.
            </summary>
            <param name="err">The error value to pass in.</param>
        </member>
        <member name="M:Emik.Results.Result`2.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Results.Result`2"/> struct. The success value is specified.
            </summary>
            <param name="ok">The success value to pass in.</param>
        </member>
        <member name="P:Emik.Results.Result`2.IsErr">
            <summary>
            Gets a value indicating whether this <see cref="T:Emik.Results.Result`2"/> has an <see cref="P:Emik.Results.Result`2.Err"/> value.
            </summary>
        </member>
        <member name="P:Emik.Results.Result`2.IsOk">
            <summary>
            Gets a value indicating whether this <see cref="T:Emik.Results.Result`2"/> has an <see cref="P:Emik.Results.Result`2.Ok"/> value.
            </summary>
        </member>
        <member name="P:Emik.Results.Result`2.System#Collections#Generic#ICollection{TOk}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/>
        </member>
        <member name="P:Emik.Results.Result`2.System#Collections#Generic#IReadOnlyCollection{TOk}#Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
        </member>
        <member name="P:Emik.Results.Result`2.System#Collections#Generic#ICollection{TOk}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Results.Result`2.Value">
            <summary>
            Gets <see cref="P:Emik.Results.Result`2.Ok"/> if this <see cref="T:Emik.Results.Result`2"/>
            has a success value and <see cref="P:Emik.Results.Result`2.Err"/> otherwise.
            </summary>
            <remarks><para>This process requires boxing for returns that are value-types.</para></remarks>
        </member>
        <member name="P:Emik.Results.Result`2.Err">
            <summary>Gets the error value. This value may not be set and is therefore optional.</summary>
        </member>
        <member name="P:Emik.Results.Result`2.Ok">
            <summary>Gets the success value. This value may not be set and is therefore optional.</summary>
        </member>
        <member name="P:Emik.Results.Result`2.System#Collections#Generic#IList{TOk}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Results.Result`2.System#Collections#Generic#IReadOnlyList{TOk}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Results.Result`2.op_Implicit(`1)~Emik.Results.Result{`0,`1}">
            <summary>
            Implicitly converts <typeparamref name="TErr"/> into <see cref="T:Emik.Results.Result`2"/>.
            The error value is specified.
            </summary>
            <param name="err">The error value to pass in.</param>
            <returns>An encapsulation of the parameter <paramref name="err"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.op_Implicit(`0)~Emik.Results.Result{`0,`1}">
            <summary>
            Implicitly converts <typeparamref name="TOk"/> into <see cref="T:Emik.Results.Result`2"/>.
            The success value is specified.
            </summary>
            <param name="ok">The success value to pass in.</param>
            <returns>An encapsulation of the parameter <paramref name="ok"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.op_Implicit(Emik.Results.Result{Emik.Results.Result{`0,`1},`1})~Emik.Results.Result{`0,`1}">
            <inheritdoc cref="M:Emik.Results.Extensions.ResultFactory.Flatten``2(Emik.Results.Result{Emik.Results.Result{``0,``1},``1})"/>
        </member>
        <member name="M:Emik.Results.Result`2.op_Implicit(Emik.Results.Result{`0,Emik.Results.Result{`0,`1}})~Emik.Results.Result{`0,`1}">
            <inheritdoc cref="M:Emik.Results.Extensions.ResultFactory.Flatten``2(Emik.Results.Result{``0,Emik.Results.Result{``0,``1}})"/>
        </member>
        <member name="M:Emik.Results.Result`2.op_Implicit(Emik.Results.Result{Emik.Results.Result{`0,`1},Emik.Results.Result{`0,`1}})~Emik.Results.Result{`0,`1}">
            <inheritdoc cref="M:Emik.Results.Extensions.ResultFactory.Flatten``2(Emik.Results.Result{Emik.Results.Result{``0,``1},Emik.Results.Result{``0,``1}})"/>
        </member>
        <member name="M:Emik.Results.Result`2.op_Explicit(Emik.Results.Result{`0,`1})~`1">
            <summary>Implicitly converts <see cref="T:Emik.Results.Result`2"/> into <typeparamref name="TErr"/>.</summary>
            <param name="result">The result to pass in.</param>
            <returns>The property <see cref="P:Emik.Results.Result`2.Err"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.op_Explicit(System.Nullable{Emik.Results.Result{`0,`1}})~`1">
            <summary>Implicitly converts <see cref="T:Emik.Results.Result`2"/> into <typeparamref name="TErr"/>.</summary>
            <param name="result">The result to pass in.</param>
            <returns>The property <see cref="P:Emik.Results.Result`2.Err"/>, coalesced.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.op_Explicit(Emik.Results.Result{`0,`1})~`0">
            <summary>Implicitly converts <see cref="T:Emik.Results.Result`2"/> into <typeparamref name="TOk"/>.</summary>
            <param name="result">The result to pass in.</param>
            <returns>The property <see cref="P:Emik.Results.Result`2.Ok"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.op_Explicit(System.Nullable{Emik.Results.Result{`0,`1}})~`0">
            <summary>Implicitly converts <see cref="T:Emik.Results.Result`2"/> into <typeparamref name="TOk"/>.</summary>
            <param name="result">The result to pass in.</param>
            <returns>The property <see cref="P:Emik.Results.Result`2.Ok"/>, coalesced.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.op_True(Emik.Results.Result{`0,`1})">
            <inheritdoc cref="P:Emik.Results.Result`2.IsOk"/>
        </member>
        <member name="M:Emik.Results.Result`2.op_False(Emik.Results.Result{`0,`1})">
            <inheritdoc cref="P:Emik.Results.Result`2.IsErr"/>
        </member>
        <member name="M:Emik.Results.Result`2.op_Equality(Emik.Results.Result{`0,`1},Emik.Results.Result{`0,`1})">
            <summary>
            Determines if both results have the same value.
            <see cref="P:Emik.Results.Result`2.Ok"/> and <see cref="P:Emik.Results.Result`2.Err"/> are evaluated separately.
            </summary>
            <param name="lh">The left-hand side parameter.</param>
            <param name="rh">The right-hand side parameter.</param>
            <returns>
            The value <see langword="true"/> if both are <see cref="P:Emik.Results.Result`2.Ok"/> or <see cref="P:Emik.Results.Result`2.Err"/> and
            contain the same inner value, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.op_Inequality(Emik.Results.Result{`0,`1},Emik.Results.Result{`0,`1})">
            <summary>
            Determines if both results do not have the same value.
            <see cref="P:Emik.Results.Result`2.Ok"/> and <see cref="P:Emik.Results.Result`2.Err"/> are evaluated separately.
            </summary>
            <param name="lh">The left-hand side parameter.</param>
            <param name="rh">The right-hand side parameter.</param>
            <returns>
            The value <see langword="false"/> if both are <see cref="P:Emik.Results.Result`2.Ok"/> or <see cref="P:Emik.Results.Result`2.Err"/> and
            contain the same inner value, otherwise <see langword="true"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.op_BitwiseOr(Emik.Results.Result{`0,`1},`0)">
            <inheritdoc cref="M:Emik.Results.Result`2.OkOr(`0)"/>
        </member>
        <member name="M:Emik.Results.Result`2.op_BitwiseOr(Emik.Results.Result{`0,`1},`1)">
            <inheritdoc cref="M:Emik.Results.Result`2.ErrOr(`1)"/>
        </member>
        <member name="M:Emik.Results.Result`2.op_UnaryNegation(Emik.Results.Result{`0,`1})">
            <inheritdoc cref="M:Emik.Results.Result`2.Swap"/>
        </member>
        <member name="M:Emik.Results.Result`2.op_UnaryPlus(Emik.Results.Result{`0,`1})">
            <summary>Returns itself.</summary>
            <param name="result">The parameter to return.</param>
            <returns>The parameter <paramref name="result"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.Deconstruct(`0@,`1@)">
            <summary>
            Destructures the <see cref="T:Emik.Results.Result`2"/> into 2 optional values, <see cref="P:Emik.Results.Result`2.Ok"/> and <see cref="P:Emik.Results.Result`2.Err"/>.
            </summary>
            <param name="ok">The success value.</param>
            <param name="err">The error value.</param>
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#ICollection{TOk}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#ICollection{TOk}#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#IList{TOk}#Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#IList{TOk}#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#ISet{TOk}#ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#ISet{TOk}#IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#ISet{TOk}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#ISet{TOk}#UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.Contains(`0)">
            <summary>
            Performs an equality comparison between <see cref="P:Emik.Results.Result`2.Ok"/> and the parameter,
            or <see langword="false"/>.
            </summary>
            <param name="item">The value to compare.</param>
            <returns>The result of the comparison of <see cref="P:Emik.Results.Result`2.Ok"/>, or <see langword="false"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.ContainsErr(`1)">
            <summary>
            Performs an equality comparison between <see cref="P:Emik.Results.Result`2.Err"/> and the parameter,
            or <see langword="false"/>.
            </summary>
            <param name="item">The value to compare.</param>
            <returns>
            The result of the comparison of <see cref="P:Emik.Results.Result`2.Err"/>, or <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.Equals(Emik.Results.Result{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Results.Result`2.Equals(Emik.Results.Result{`0,`1},Emik.Results.Result{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Results.Result`2.IsErrAnd(System.Predicate{`1})">
            <summary>
            Calls a <see cref="T:System.Predicate`1"/> for <see cref="P:Emik.Results.Result`2.Err"/> if <see cref="P:Emik.Results.Result`2.Err"/> is set,
            or returns <see langword="false"/>.
            </summary>
            <param name="predicate">The predicate to match the inner value with.</param>
            <returns>
            Returns <see langword="true"/> if this <see cref="T:Emik.Results.Result`2"/> has
            <see cref="P:Emik.Results.Result`2.Err"/> and the value of it matches <paramref name="predicate"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.IsOkAnd(System.Predicate{`0})">
            <summary>
            Calls a <see cref="T:System.Predicate`1"/> for <see cref="P:Emik.Results.Result`2.Ok"/> if <see cref="P:Emik.Results.Result`2.Ok"/> is set,
            or returns <see langword="false"/>.
            </summary>
            <param name="predicate">The predicate to match the inner value with.</param>
            <returns>
            Returns <see langword="true"/> if this <see cref="T:Emik.Results.Result`2"/> has
            <see cref="P:Emik.Results.Result`2.Ok"/> and the value of it matches <paramref name="predicate"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Results.Result`2.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Results.Result`2.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Results.Result`2.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Results.Result`2.Out(`0@,`1@)">
            <summary>
            Destructures the <see cref="T:Emik.Results.Result`2"/> into 2 optional values, <see cref="P:Emik.Results.Result`2.Ok"/> and <see cref="P:Emik.Results.Result`2.Err"/>.
            </summary>
            <param name="ok">The success value.</param>
            <param name="err">The error value.</param>
            <returns>The value <see cref="P:Emik.Results.Result`2.IsOk"/>, with nullability awareness for the out parameters.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.OutErr(`1@)">
            <summary>Useful for ternary operators to use a temporary value when <see cref="P:Emik.Results.Result`2.Err"/> is set.</summary>
            <param name="err">The error value.</param>
            <returns>The value <see cref="P:Emik.Results.Result`2.IsErr"/>, with nullability awareness for the out parameter.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.OutOk(`0@)">
            <summary>Useful for ternary operators to use a temporary value when <see cref="P:Emik.Results.Result`2.Ok"/> is set.</summary>
            <param name="ok">The success value.</param>
            <returns>The value <see cref="P:Emik.Results.Result`2.IsOk"/>, with nullability awareness for the out parameter.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Results.Result`2.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#ICollection{TOk}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#ISet{TOk}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.GetHashCode(Emik.Results.Result{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#IList{TOk}#IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Results.Result`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Results.Result`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Results.Result`2.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Results.Result`2.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.GetEnumerator">
            <summary>Creates an enumeration for <see cref="P:Emik.Results.Result`2.Ok"/>.</summary>
            <remarks><para>For more details, see <see cref="T:Emik.Results.Result`2.Enumerator"/>.</para></remarks>
            <returns>An <see cref="T:Emik.Results.Result`2.Enumerator"/> that doesn't return anything, or returns <see cref="P:Emik.Results.Result`2.Ok"/> once.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Results.Result`2.System#Collections#Generic#IEnumerable{TOk}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Results.Result`2.AndThen``1(System.Converter{`0,Emik.Results.Result{``0,`1}})">
            <summary>Applies a selector to <see cref="P:Emik.Results.Result`2.Ok"/> if <see cref="P:Emik.Results.Result`2.Ok"/> is set, leaving <see cref="P:Emik.Results.Result`2.Err"/> untouched.</summary>
            <typeparam name="T">The new <typeparamref name="TOk"/> type.</typeparam>
            <param name="converter">The selector to change <see cref="P:Emik.Results.Result`2.Ok"/>.</param>
            <returns>
            Another <see cref="T:Emik.Results.Result`2"/> with the result of <paramref name="converter"/>
            if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Ok"/>, otherwise <see cref="P:Emik.Results.Result`2.Err"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.AndThenErr``1(System.Converter{`1,Emik.Results.Result{`0,``0}})">
            <summary>
            Applies a selector to <see cref="P:Emik.Results.Result`2.Err"/> if <see cref="P:Emik.Results.Result`2.Err"/> is set, leaving <see cref="P:Emik.Results.Result`2.Ok"/> untouched.
            </summary>
            <typeparam name="T">The new <typeparamref name="TErr"/> type.</typeparam>
            <param name="converter">The selector to change <see cref="P:Emik.Results.Result`2.Err"/>.</param>
            <returns>
            Another <see cref="T:Emik.Results.Result`2"/> with the result of <paramref name="converter"/>
            if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>, otherwise <see cref="P:Emik.Results.Result`2.Ok"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.Inspect(System.Action{`0})">
            <summary>
            Invokes a delegate if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Ok"/>, and returns itself.
            </summary>
            <param name="action">The delegate to invoke if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Ok"/>.</param>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.InspectErr(System.Action{`1})">
            <summary>
            Invokes a delegate if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>, and returns itself.
            </summary>
            <param name="action">
            The delegate to invoke if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>.
            </param>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.Match(System.Action{`0},System.Action{`1})">
            <summary>Performs a non-exhaustive match statement.</summary>
            <param name="onOk">The delegate to invoke when <see cref="P:Emik.Results.Result`2.Ok"/>.</param>
            <param name="onErr">The delegate to invoke when <see cref="P:Emik.Results.Result`2.Err"/>.</param>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.Map``1(System.Converter{`0,``0})">
            <summary>
            Applies a selector to <see cref="P:Emik.Results.Result`2.Ok"/> if <see cref="P:Emik.Results.Result`2.Ok"/> is set, leaving <see cref="P:Emik.Results.Result`2.Err"/> untouched.
            </summary>
            <typeparam name="T">The new <typeparamref name="TOk"/> type.</typeparam>
            <param name="converter">The selector to change <see cref="P:Emik.Results.Result`2.Ok"/>.</param>
            <returns>
            Another <see cref="T:Emik.Results.Result`2"/> with the result of <paramref name="converter"/>
            if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Ok"/>, otherwise <see cref="P:Emik.Results.Result`2.Err"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.MapErr``1(System.Converter{`1,``0})">
            <summary>
            Applies a selector to <see cref="P:Emik.Results.Result`2.Err"/> if <see cref="P:Emik.Results.Result`2.Err"/> is set, leaving <see cref="P:Emik.Results.Result`2.Ok"/> untouched.
            </summary>
            <typeparam name="T">The new <typeparamref name="TErr"/> type.</typeparam>
            <param name="converter">The selector to change <see cref="P:Emik.Results.Result`2.Err"/>.</param>
            <returns>
            Another <see cref="T:Emik.Results.Result`2"/> with the result of <paramref name="converter"/>
            if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>, otherwise <see cref="P:Emik.Results.Result`2.Ok"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.Try(System.Action{`0})">
            <summary>
            Applies a selector to <see cref="P:Emik.Results.Result`2.Ok"/> if <see cref="P:Emik.Results.Result`2.Ok"/> is set, leaving <see cref="P:Emik.Results.Result`2.Err"/> untouched.
            </summary>
            <param name="action">The selector to change <see cref="P:Emik.Results.Result`2.Ok"/>.</param>
            <returns>
            Another <see cref="T:Emik.Results.Result`2"/> with the result of <paramref name="action"/>
            if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Ok"/>, otherwise <see cref="P:Emik.Results.Result`2.Err"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.Try``1(System.Converter{`0,``0})">
            <summary>
            Applies a selector to <see cref="P:Emik.Results.Result`2.Ok"/> if <see cref="P:Emik.Results.Result`2.Ok"/> is set, leaving <see cref="P:Emik.Results.Result`2.Err"/> untouched.
            </summary>
            <typeparam name="T">The new <typeparamref name="TOk"/> type.</typeparam>
            <param name="converter">The selector to change <see cref="P:Emik.Results.Result`2.Ok"/>.</param>
            <returns>
            Another <see cref="T:Emik.Results.Result`2"/> with the result of <paramref name="converter"/>
            if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Ok"/>, otherwise <see cref="P:Emik.Results.Result`2.Err"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.TryErr(System.Action{`1})">
            <summary>
            Applies a selector to <see cref="P:Emik.Results.Result`2.Err"/> if <see cref="P:Emik.Results.Result`2.Err"/> is set, leaving <see cref="P:Emik.Results.Result`2.Ok"/> untouched.
            </summary>
            <param name="action">The selector to change <see cref="P:Emik.Results.Result`2.Err"/>.</param>
            <returns>
            Another <see cref="T:Emik.Results.Result`2"/> with the result of <paramref name="action"/>
            if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>, otherwise <see cref="P:Emik.Results.Result`2.Ok"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.TryErr``1(System.Converter{`1,``0})">
            <summary>
            Applies a selector to <see cref="P:Emik.Results.Result`2.Err"/> if <see cref="P:Emik.Results.Result`2.Err"/> is set, leaving <see cref="P:Emik.Results.Result`2.Ok"/> untouched.
            </summary>
            <typeparam name="T">The new <typeparamref name="TErr"/> type.</typeparam>
            <param name="converter">The selector to change <see cref="P:Emik.Results.Result`2.Err"/>.</param>
            <returns>
            Another <see cref="T:Emik.Results.Result`2"/> with the result of <paramref name="converter"/>
            if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>, otherwise <see cref="P:Emik.Results.Result`2.Ok"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.TryMatch(System.Action{`0},System.Action{`1})">
            <summary>Performs an exhaustive match statement.</summary>
            <param name="onOk">The delegate to invoke when <see cref="P:Emik.Results.Result`2.Ok"/>.</param>
            <param name="onErr">The delegate to invoke when <see cref="P:Emik.Results.Result`2.Err"/>.</param>
            <returns>
            The result of <paramref name="onOk"/> if <see cref="P:Emik.Results.Result`2.Ok"/>, otherwise the result of <paramref name="onErr"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.TryMatch``1(System.Converter{`0,``0},System.Converter{`1,``0})">
            <summary>Performs an exhaustive match statement.</summary>
            <typeparam name="T">The return value of both converters.</typeparam>
            <param name="onOk">The delegate to invoke when <see cref="P:Emik.Results.Result`2.Ok"/>.</param>
            <param name="onErr">The delegate to invoke when <see cref="P:Emik.Results.Result`2.Err"/>.</param>
            <returns>
            The result of <paramref name="onOk"/> if <see cref="P:Emik.Results.Result`2.Ok"/>, otherwise the result of <paramref name="onErr"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.Swap">
            <summary>Swaps the success and error value.</summary>
            <returns>Itself with the generics and values swapped.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.Match``1(System.Converter{`0,``0},System.Converter{`1,``0})">
            <summary>Performs an exhaustive match statement.</summary>
            <typeparam name="T">The return value of both converters.</typeparam>
            <param name="onOk">The delegate to invoke when <see cref="P:Emik.Results.Result`2.Ok"/>.</param>
            <param name="onErr">The delegate to invoke when <see cref="P:Emik.Results.Result`2.Err"/>.</param>
            <returns>
            The result of <paramref name="onOk"/> if <see cref="P:Emik.Results.Result`2.Ok"/>, otherwise the result of <paramref name="onErr"/>.
            </returns>
        </member>
        <member name="M:Emik.Results.Result`2.ErrOr(`1)">
            <summary>Gets the <see cref="P:Emik.Results.Result`2.Ok"/> value, or the parameter.</summary>
            <remarks><para>
            The default value is eagerly evaluated, use <see cref="M:Emik.Results.Result`2.OkOr(System.Converter{`1,`0})"/> for lazy evaluation.
            </para></remarks>
            <param name="def">The default value if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>.</param>
            <returns>The value <see cref="P:Emik.Results.Result`2.Ok"/>, or <paramref name="def"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.ErrOr(System.Converter{`0,`1})">
            <summary>Gets the <see cref="P:Emik.Results.Result`2.Ok"/> value, or the returned value of the parameter.</summary>
            <remarks><para>
            The default value is lazily evaluated, use <see cref="M:Emik.Results.Result`2.OkOr(`0)"/> for eager evaluation.
            </para></remarks>
            <param name="converter">
            The delegate to invoke and return if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>.
            </param>
            <returns>The value <see cref="P:Emik.Results.Result`2.Ok"/>, or the result of <paramref name="converter"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.ExpectErr(System.String)">
            <summary>Gets the error value. Throws if this value is not set.</summary>
            <param name="message">The message to send into <see cref="T:Emik.Results.ResultException`1"/>.</param>
            <exception cref="T:Emik.Results.ResultException`1">This <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Ok"/>.</exception>
            <returns>The value <see cref="P:Emik.Results.Result`2.Err"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.Expect(System.String)">
            <summary>Gets the success value. Throws if this value is not set.</summary>
            <param name="message">The message to send into <see cref="T:Emik.Results.ResultException`1"/>.</param>
            <exception cref="T:Emik.Results.ResultException`1">This <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>.</exception>
            <returns>The value <see cref="P:Emik.Results.Result`2.Ok"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.OkOr(`0)">
            <summary>Gets the <see cref="P:Emik.Results.Result`2.Ok"/> value, or the parameter.</summary>
            <remarks><para>
            The default value is eagerly evaluated, use <see cref="M:Emik.Results.Result`2.OkOr(System.Converter{`1,`0})"/> for lazy evaluation.
            </para></remarks>
            <param name="def">The default value if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>.</param>
            <returns>The value <see cref="P:Emik.Results.Result`2.Ok"/>, or <paramref name="def"/>.</returns>
        </member>
        <member name="M:Emik.Results.Result`2.OkOr(System.Converter{`1,`0})">
            <summary>Gets the <see cref="P:Emik.Results.Result`2.Ok"/> value, or the returned value of the parameter.</summary>
            <remarks><para>
            The default value is lazily evaluated, use <see cref="M:Emik.Results.Result`2.OkOr(`0)"/> for eager evaluation.
            </para></remarks>
            <param name="converter">
            The delegate to invoke and return if this <see cref="T:Emik.Results.Result`2"/> is <see cref="P:Emik.Results.Result`2.Err"/>.
            </param>
            <returns>The value <see cref="P:Emik.Results.Result`2.Ok"/>, or the result of <paramref name="converter"/>.</returns>
        </member>
        <member name="T:Emik.Results.Result`2.Enumerator">
            <summary>Represents an enumeration that is either empty or returns a value once.</summary>
        </member>
        <member name="M:Emik.Results.Result`2.Enumerator.#ctor(`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Results.Result`2.Enumerator"/> struct.</summary>
            <param name="ok">The value to <see langword="yield"/> once.</param>
        </member>
        <member name="P:Emik.Results.Result`2.Enumerator.CanMoveNext">
            <summary>
            Gets a value indicating whether <see cref="M:Emik.Results.Result`2.Enumerator.MoveNext"/> will
            return <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Emik.Results.Result`2.Enumerator.IsEnd">
            <summary>
            Gets a value indicating whether this <see cref="T:Emik.Results.Result`2.Enumerator"/> has been used.
            </summary>
        </member>
        <member name="P:Emik.Results.Result`2.Enumerator.IsOk">
            <summary>
            Gets a value indicating whether this <see cref="T:Emik.Results.Result`2.Enumerator"/> has an <see cref="P:Emik.Results.Result`2.Ok"/> value.
            </summary>
        </member>
        <member name="P:Emik.Results.Result`2.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Results.Result`2.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.Enumerator.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Results.Result`2.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="T:InlineMethod.InlineAttribute">
            <summary>Method to inline.</summary>
        </member>
        <member name="M:InlineMethod.InlineAttribute.#ctor(System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:InlineMethod.InlineAttribute"/> class.</summary>
            <param name="remove">The value to set.</param>
        </member>
        <member name="P:InlineMethod.InlineAttribute.Remove">
            <summary>Gets a value indicating whether to remove the method after inlining, if private.</summary>
        </member>
    </members>
</doc>
